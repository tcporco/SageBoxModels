---
layout: page
title: Subcritical Measles Outbreak Size
wmd_project: Measles
wmd_prerequisite_projects:
    "BoxModels" : BoxModels
---

<!-- paper text starts below the first 3 source files -->

<source-file filename=measles-model.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py 
# requires: $(BoxModels)/boxmarkov.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# produces: measles-model.sobj
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, dynamicalsystems, boxmodel, boxmodelproduct, boxmarkov

S, E, I, R, beta, sigma, gamma, u, v = SR.var( 'S E I R beta sigma gamma u v' )
SEIR_graph = DiGraph(
    [ (S, E, beta*S*I), (E, I, sigma*E), (I, R, gamma*I) ],
    pos = { S:(0,0), E:(2,0), I:(3,0), R:(4,0) } # stretch SI arc
)
SEIR = boxmodel.BoxModel(
    SEIR_graph,
    [S,E,I,R]
)
uv = boxmodel.BoxModel(
    DiGraph( { u:(), v:() } ),
    [u,v]
)

measles_homogeneous_general = SEIR
measles_heterogeneous_general = boxmodelproduct.BoxModelProduct( SEIR, uv )

  # homogeneous assumptions
  #  p_v is proportion of population vaccinated
  #  everyone has same rate of contacts per time \alpha
  #  \zeta is probability a contact is adequate
p_v, alpha, zeta = SR.var( 'p_v alpha zeta' )

homogeneous_params = dynamicalsystems.Bindings(
  beta = alpha * zeta
)

measles_homogeneous = measles_homogeneous_general.bind( homogeneous_params )

  # parameter values we'll bind later
R_0 = dynamicalsystems.subscriptedsymbol( 'R', 0 )
R_0_u = dynamicalsystems.subscriptedsymbol( 'R', 0, 'u' )
R_0_u_hyp = dynamicalsystems.subscriptedsymbol( 'R', 0, 'u', SR('hyp') )
zeta_u = dynamicalsystems.subscriptedsymbol( zeta, 'u' )
hom_param_values = dynamicalsystems.Bindings(
  R_0_u_hyp = 17, # R_0 among the unvaccinated
  R_0 = 0.6,  # R_0 today
  zeta_u = 1, # unvaccinated get infected a lot
  sigma = 1/14,
  gamma = 1/7
) + dynamicalsystems.Bindings(
  alpha = R_0_u_hyp * gamma / zeta_u,
  zeta = zeta_u * R_0 / R_0_u_hyp
)

  # heterogeneous assumptions:
  #  two classes: u = unvaccinated, v = vaccinated
  #  \zeta_x is probability a class x person is infected by contact
  #  alpha_x_y is rate of x-y contacts
zeta_u, zeta_v, alpha_u_u, alpha_u_v, alpha_v_u, alpha_v_v = SR.var( 'zeta_u zeta_v alpha_u_u alpha_u_v alpha_v_u alpha_v_v' )

#print measles_heterogeneous_general.ode(), '\n'

heterogeneous_params_base = homogeneous_params + dynamicalsystems.Bindings(
  # \alpha_x_y is a derived quantity, the number of x-y contacts per time
  # Since
  #    \alpha_u_v = \alpha_v_u
  #    \alpha = sum( N_x N_y \alpha_x_y ) / sum( N_x N_y )
  #      = (1-p_v)^2 \alpha_u_u + 2p_v(1-p_v) \alpha_u_v + p_v^2 \alpha_v_v
  # from these things we can end up with
  beta_u_u = alpha_u_u * zeta_u,
  beta_v_u = alpha_v_u * zeta_v,
  beta_u_v = alpha_u_v * zeta_u,
  beta_v_v = alpha_v_v * zeta_v,
  # sigma is rate of becoming infectious
  sigma_u = sigma,
  sigma_v = sigma,
  # gamma is recovery rate
  gamma_u = gamma,
  gamma_v = gamma,
  # of use in analysis
  R_0_u = (1-p_v)*alpha_u_u*zeta_u/gamma
)
heterogeneous_params = heterogeneous_params_base + dynamicalsystems.Bindings(
  alpha_v_u = (alpha - (1-p_v)*alpha_u_u)/p_v,
  #alpha_v_u = (alpha - (1-p_v)^2 * alpha_u_u - p_v^2 * alpha_v_v)/(2*p_v*(1-p_v))
) + dynamicalsystems.Bindings(
  alpha_u_v = alpha_v_u,
  alpha_v_v = (alpha - (1-p_v)*alpha_v_u)/p_v,
  # also, since \zeta = p_v \zeta_v + (1-p_v) \zeta_u,
  zeta_v = (zeta - (1 - p_v) * zeta_u) / p_v
)

measles_heterogeneous_base = measles_heterogeneous_general.bind( heterogeneous_params_base )
measles_heterogeneous = measles_heterogeneous_base.bind( heterogeneous_params )

  # parameter values we'll use later
het_param_values = hom_param_values + dynamicalsystems.Bindings(
  alpha_u_u = 8
) 

if False:
    ## homogeneous model should be equal to heterogeneous model when
    ## \alpha_u_u = \alpha_p_p = \alpha
    ## and \zeta_u = \zeta_v = \zeta
    het_check = measles_heterogeneous.bind( dynamicalsystems.Bindings(
      alpha_u_u = alpha,
      alpha_v_v = alpha,
      zeta_u = zeta,
      zeta_v = zeta
    ) )
    hco = het_check.ode()
    print 'heterogeneous check:\n', hco, '\n'
    hom_check = dynamicalsystems.ODESystem( {
      S : simplify( hco._flow[SR.symbol('S_u')] + hco._flow[SR.symbol('S_v')] ),
      I : simplify( hco._flow[SR.symbol('I_u')] + hco._flow[SR.symbol('I_v')] ),
      R : simplify( hco._flow[SR.symbol('R_u')] + hco._flow[SR.symbol('R_v')] )
    }, [S,I,R] )
    print hom_check, '\n'

#print measles_heterogeneous.ode(), '\n'

p_v_base = 0.97
hp = heterogeneous_params + het_param_values + dynamicalsystems.Bindings( p_v=p_v_base )

# values for use in stochastic simulations, below
n_trials = 1000 #10000
popsize=500 #200 

save_session( 'measles-model' )
</source-file>

<source-file filename=measles-model-plots.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# requires: measles-model.sobj
# produces: measles-hom.tex measles-het.tex R_0_u.svg
# produces: %.value.tex-inline
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, dynamicalsystems, boxmodel, boxmodelproduct

# subscripts that get messed up by pickling
[ dynamicalsystems.subscriptedsymbol( 'alpha', SR(i), SR(j) ) for i in ('u','v') for j in ('u','v') ]

load_session( 'measles-model' )

measles_homogeneous.plot_boxes( filename='measles-hom.tex', figsize=(8,2) )

print measles_heterogeneous_base._flow_graph.edges()
measles_heterogeneous_base._flow_graph.set_latex_options(
    edge_label_placements={ e:p for e,p in zip(
	measles_heterogeneous_base._flow_graph.edge_iterator(),
	[ 0.5r, 0.5r, 'above', 'below', 'above', 'below' ]
    ) }
)
measles_heterogeneous_base.plot_boxes( filename='measles-het.tex', figsize=(8,2) )

# R_0_u as a function of alpha_u_u
r0v = hom_param_values( dynamicalsystems.Bindings( p_v=p_v_base )( heterogeneous_params( R_0_u ) ) )

# solve for critical value
alpha_star = solve( r0v == 1, alpha_u_u, solution_dict=True )[0][alpha_u_u]
print alpha_star
print N(het_param_values(alpha))

RP = plot( r0v, (alpha_u_u, 0, 10), legend_label='$R_{0u}$' )
RP += plot( (alpha_star,x), (x,0,2), parametric=True, color='red', thickness=0.1, legend_label=r'critical $\alpha_{uu}$' )
RP += plot( (N(het_param_values(alpha)),x), (x,0,2), parametric=True, color='gray', thickness=0.1, legend_label=r'$\alpha$' )
RP.axes_labels( [ r'$\alpha_{uu}$', r'$R_{0u}$' ] )
RP.set_legend_options( back_color='white', font_size='small' )
RP.save( filename='R_0_u.svg', figsize=4 )

# and dump out a bunch of variables' values
for aa in [
    ('alpha',),
    ('zeta',),
    ('sigma',),
    ('gamma',),
    ('p_v','p_v'),
    ('alpha_u_u', r'\alpha_{uu}', 'alpha_uu'),
    ('alpha_v_v', r'\alpha_{vv}', 'alpha_vv'),
    ('zeta_u',),
    ('zeta_v',),
    ('alpha_u_v', r'\alpha_{uv}=\alpha_{vu}', 'alpha_uv'),
    (R_0, r'R_0 = {\alpha\zeta}/{\gamma}', 'R_0'),
    (R_0_u_hyp, r'R_0', 'R_0_u-hypothetical'),
    (R_0_u, r'R_{0u} = '+latex(heterogeneous_params(R_0_u)), 'R_0_u'),
    (RDF(alpha_star), latex(alpha_u_u), 'alpha-star'),
    (popsize,'','popsize'),
    (n_trials,'','n_trials'),
    (popsize*(1-p_v),'','n_unvaccinated')
]: latex_output.write_tex_inline( *aa, bindings=hp )

#measles_homogeneous.plot().save( filename='measles-hom.svg', figsize=(4,3) )
#measles_heterogeneous_base.plot().save( filename='measles-het.svg', figsize=(4,3) )
</source-file>

In this manuscript we model subcritical outbreaks of measles, comparing
the outbreak sizes with and without heterogeneity in vaccination status.

The homogeneous model is a simple SEIR model:

<project-file filename=measles-hom.tex display=measles-hom.crop.svg/>

The heterogeneous model is the same, but stratified into two population
classes, vaccinated ($$v$$) and unvaccinated ($$u$$):

<project-file filename=measles-het.tex display=measles-het.crop.svg/>
<latex>\vspace{12pt}</latex>

Parameter values are loosely based on known data, with consistency
requirements.
For the homogeneous model:

* <project-file filename=alpha.value.tex-inline/>: rate of contact between individuals.  Chosen so that <project-file filename=R_0_u-hypothetical.value.tex-inline/> would be true if $$\zeta$$ were at the unvaccinated level -- see below.
* <project-file filename=zeta.value.tex-inline/>: probability a contact event is adequate (i.e. leads to infection if contact is between one susceptible and one infected individual), when contacts are well-mixed.  Chosen to make <project-file filename=R_0.value.tex-inline/>, given the above value of $$\alpha$$.
* <project-file filename=sigma.value.tex-inline/>: rate of transition from exposed to infectious
* <project-file filename=gamma.value.tex-inline/>: rate of recovery

And for the stratified model:

* <project-file filename=p_v.value.tex-inline/>: proportion vaccinated.
* <project-file filename=alpha_uu.value.tex-inline/>: rate of contact between unvaccinated individuals
* <project-file filename=zeta_u.value.tex-inline/>: probability a contact with an unvaccinated susceptible individual is adequate.

The implied parameters $$\zeta_v$$, $$\alpha_{uv}$$, $$\alpha_{vu}$$, and
$$\alpha_{vv}$$ are derived from consistency conditions:

$$\zeta = p_v \zeta_v + (1-p_v)\zeta_u$$

$$\alpha_{uv} = \alpha_{vu}$$

$$p_v \alpha_{uv} + (1-p_v)\alpha_{uu} = p_v\alpha_{vv} + (1-p_v)\alpha_{vu} = \alpha$$.

<!---
$$\alpha = p_v^2 \alpha_{vv} + 2 p_v (1-p_v) \alpha_{uv} + (1-p_v)^2 \alpha_{uu}$$.
--->

The derived values are

* <project-file filename='zeta_v.value.tex-inline'/>
* <project-file filename='alpha_uv.value.tex-inline'/>
* <project-file filename=alpha_vv.value.tex-inline/>

The main questions have to do with sizes of outbreaks and whether they
get large when unvaccinated people cluster together, even though the
population-wide $$R$$ is subcritical.

With the above parameters the initial spreading rate within the unvaccinated
compartment is
<project-file filename=R_0_u.value.tex-inline/>.
I suggested in an email that this quantity should predict whether the
infection can burn through that compartment.

$$R_{0u}$$ is a linear function of $$\alpha_{uu}$$:

<project-file filename=R_0_u.svg/>

As anticipated, sufficient contact among unvaccinated people can
allow this simulated measles to become critical within that subpopulation.
This critical value is attained at <project-file filename=alpha-star.value.tex-inline/>.

<source-file filename=measles-simulations.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(BoxModels)/boxmarkov.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# requires: $(SageDynamics)/stochasticdynamics.py
# requires: measles-model.sobj
# produces: measles-simulations.sobj
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, boxmodel, boxmodelproduct, boxmarkov

load_session( 'measles-model' )

def run_simulations( sim, init_state, n_trials=n_trials ):
    simulations = [
	sim.solve( init_state, end_time=Infinity )
	for _ in range(n_trials)
    ]
    return simulations

def plot_final_sizes( runs, sim, title=None, filename=None ):
    final_sizes = [ s.values('R')[-1] for s in runs ]
    print final_sizes
    import scipy.stats
    final_size_bins = scipy.stats.histogram(
        final_sizes,
        numbins=sim._N,
        defaultlimits=(1,sim._N)
    )
    print final_size_bins
    posbins = [i for i in range(len(final_size_bins[0])) if final_size_bins[0][i] > 0]
    print posbins
    cutbins = [ n/n_trials for n in final_size_bins[0][:posbins[-1]+2] ]
    print cutbins 
    #if filename is not None:
    #    ( plotbins(cutbins, color='gray') +
    #      point( ( binmean(cutbins), 0 ), color='black' )
    #    ).save(
    #        filename,
#	    title=title,
#            figsize=(4,3)
#        )
    return cutbins

print 'hom'
hom_sim = boxmarkov.BoxModelDiscreteSimulation( measles_homogeneous.bind( hom_param_values ) )
hom_runs = run_simulations( hom_sim, (popsize-1,0,1,0) )
hombins = plot_final_sizes( hom_runs, hom_sim )#, 'Final size distribution of homogeneous measles simulations', 'measles-sim-hom.svg' )

print 'het'

def calc_het(N, values=het_param_values):
    # parameters for outbreak-size experiment
    init_I_v = 0    # initial number infected among vaccinated
    init_I_u = 1/N  # initial number infected among unvaccinated
    p_v = floor( p_v_base * N ) / N
    init_cond_bindings = dynamicalsystems.Bindings(
        I_u = init_I_u,
        I_v = init_I_v,
        S_u = 1 - p_v - init_I_u,
        S_v = p_v - init_I_v,
        E_u = 0,
        E_v = 0,
        R_u = 0,
        R_v = 0
    )
    het_sim = boxmarkov.BoxModelDiscreteSimulation( measles_heterogeneous.bind( values, p_v=p_v ) )
    #print het_sim._model._bindings
    print init_cond_bindings
    init_cond = tuple(init_cond_bindings(v)*N for v in het_sim._vars)
    print init_cond
    runs = run_simulations( het_sim, init_cond )
    plots = plot_final_sizes( runs, het_sim )#, 'Final size distribution of heterogeneous measles simulations', 'measles-sim-het.svg' )
    return (het_sim, runs, plots)

(het_sim, het_runs, hetbins) = calc_het( popsize )

save_session( 'measles-simulations' )
</source-file>

<source-file filename=measles-simulation-plots.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(BoxModels)/boxmarkov.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# requires: $(SageDynamics)/stochasticdynamics.py
# requires: measles-simulations.sobj
# produces: measles-sizes.svg measles-Su.svg measles-Sv.svg measles-S-plane.svg
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, boxmodel, boxmodelproduct, boxmarkov

load_session( 'measles-simulations' )

def binmean( bins ):
    return sum( (i+1)*n for i,n in enumerate(bins) ) / sum(bins)
def plotbins( bins, **args ):
    return list_plot( [(i+1,x) for i,x in enumerate(bins)], plotjoined=True, xmin=0, xmax=20, **args )

(plotbins( hombins, color='blue', legend_label='homogeneous' )
 + point( (binmean(hombins),0), color='blue' )
 + plotbins( hetbins, color='red', legend_label='heterogeneous' )
 + point( (binmean(hetbins),0), color='red' )
).save(
    title = 'Final size distributions',
    filename = 'measles-sizes.svg',
    figsize=(4,3)
)

P = sum( r.plot( 't', 'S_u', color='red' ) for r in het_runs )
P.axes_labels( [ '$t$', '$S_u$' ] )
P.save( filename='measles-Su.svg', figsize=4 )

P = sum( r.plot( 't', 'S_v', color='purple' ) for r in het_runs )
P.axes_labels( [ '$t$', '$S_v$' ] )
P.save( filename='measles-Sv.svg', figsize=4 )

#het_ode = het_sim._model.ode()
#flow_ratio = het_ode._flow[SR.symbol('E_u')] / het_ode._flow[SR.symbol('E_v')]
#print 'flow ratio:', flow_ratio
#print 'flow ratio values:', het_runs[0].values( flow_ratio )
#flow_pairs = [ r.values( vector( ( SR.symbol('t'), flow_ratio ) ) ) for r in het_runs ]
#flow_pairs = [ [ p for p in ps if p is not NaN ] for ps in flow_pairs ]
#P = sum( list_plot( ps, plotjoined=True, color='gray' ) for ps in flow_pairs )
import numpy
Suv = [ [ v + i*numpy.random.uniform( 0, 0.01 ) for i,v in enumerate( r.values( 'S_u' ) ) ] for r in het_runs ]
Svv = [ [ v + i*numpy.random.uniform( 0, 0.01 ) for i,v in enumerate( r.values( 'S_v' ) ) ] for r in het_runs ]
colors = rainbow( len( het_runs ) )
numpy.random.shuffle( colors )
#P = sum( r.plot( 'S_u', 'S_v', color='gray' ) for r in het_runs )
P = sum( list_plot( zip( vu, vv ), plotjoined=True, color=colors.pop() ) for vu,vv in zip( Suv, Svv ) )
P += plot( x+471, (7,14), color='gray', thickness=0.2 )
P.axes_labels( [ '$S_u$', '$S_v$' ] )
P.save( filename='measles-S-plane.svg', figsize=4 )
</source-file>

Here are the simulation results with the above values, showing the distribution
of total outbreak size (final size):

<project-file filename=measles-sizes.svg/>

These distributions are generated by <project-file filename=n_trials.value.tex-inline/> simulations each, with a population of size
<project-file filename=popsize.value.tex-inline/> (thus with
<project-file filename=n_unvaccinated.value.tex-inline/> unvaccinated),
with initially one (unvaccinated) infectious individual and the
rest susceptible.
Small dots on the horizontal axis indicate the mean of each distribution.

One thing to do with this might be to vary $$\alpha_{uu}$$ from $$\alpha$$
upward and plot mean outbreak size vs. $$R_{0u}$$ or something like that.

Here is a look at the time-varying dynamics of infection by compartment.
The instantaneous direction of change reveals the ratio of infection rates
of unvaccinated vs. vaccinated people.

<project-file filename=measles-S-plane.svg/>

<source-file filename=measles-batch.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(BoxModels)/boxmarkov.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# requires: $(SageDynamics)/stochasticdynamics.py
# requires: measles-model.sobj
# produces: measles-batch.sobj
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, boxmodel, boxmodelproduct, boxmarkov

load_session( 'measles-model' )

def binmean( bins ):
    return sum( (i+1)*n for i,n in enumerate(bins) ) / sum(bins)
def plotbins( bins, **args ):
    return list_plot( [(i+1,x) for i,x in enumerate(bins)], plotjoined=True, xmin=0, xmax=20, **args )

## run some simulations, plot
def plot_final_sizes( sim, init_state, title=None, filename=None, n_trials=n_trials ):
    print '-1 trajectory:', sim.solve( init_state, end_time=Infinity )
    final_sizes = [
	sim.solve( init_state, end_time=Infinity ).values('R')[-1]
	for _ in range(n_trials)
    ]
    print 'final_sizes:',final_sizes
    import scipy.stats
    final_size_bins = scipy.stats.histogram(
        final_sizes,
        numbins=sim._N,
        defaultlimits=(1,sim._N)
    )
    print 'final_size_bins:',final_size_bins
    posbins = [i for i in range(len(final_size_bins[0])) if final_size_bins[0][i] > 0]
    print 'posbins:',posbins
    cutbins = [ n/n_trials for n in final_size_bins[0][:posbins[-1]+2] ]
    print 'cutbins:',cutbins 
    if filename is not None:
        ( plotbins(cutbins, color='gray') +
          point( ( binmean(cutbins), 0 ), color='black' )
        ).save(
            filename,
	    title=title,
            figsize=(4,3)
        )
    return cutbins

def calc_het(N, values=het_param_values):
    # parameters for outbreak-size experiment
    init_I_v = 0    # initial number infected among vaccinated
    init_I_u = 1/N  # initial number infected among unvaccinated
    p_v = floor( p_v_base * N ) / N
    init_cond_bindings = dynamicalsystems.Bindings(
        I_u = init_I_u,
        I_v = init_I_v,
        S_u = 1 - p_v - init_I_u,
        S_v = p_v - init_I_v,
        E_u = 0,
        E_v = 0,
        R_u = 0,
        R_v = 0
    )
    het_sim = boxmarkov.BoxModelDiscreteSimulation( measles_heterogeneous.bind( hom_param_values, values, p_v=p_v ) )
    print het_sim._model.ode()
    print init_cond_bindings
    init_cond = tuple(init_cond_bindings(v)*N for v in het_sim._vars)
    print init_cond
    return plot_final_sizes( het_sim, init_cond )

from scipy import arange
means = [
    (a,binmean(calc_het(popsize, values=dynamicalsystems.Bindings(alpha_u_u=a))))
    for a in arange(hom_param_values(alpha),10r,0.4r)
]

save_session( 'measles-batch' )
</source-file>

<source-file filename=measles-batch-plot.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(BoxModels)/boxmarkov.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# requires: $(SageDynamics)/stochasticdynamics.py
# requires: measles-batch.sobj
# produces: measles-batch.svg
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, boxmodel, boxmodelproduct, boxmarkov

load_session( 'measles-batch' )

P = list_plot( means, plotjoined=True )
P.axes_labels( [ '$\\alpha_{uu}$', 'mean final size' ] )
P.save( 
    #title = 'Mean final size vs. $\\alpha_{uu}$',
    filename = 'measles-batch.svg',
    figsize=(4,3)
)
</source-file>

<project-file filename=measles-batch.svg make=no/> <!--- make by hand only --->

<source-file filename=measles-kolmogorov.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmarkov.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# requires: measles-model.sobj
# produces: measles-run.tex measles-run.sobj
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, dynamicalsystems, boxmodel, boxmarkov

## not currently using this: kolmogorov equations for stochastic
## compartment model
## it's too slow.  Using discrete event simulation - see
## measles-simulate.sage.step, below.

load_session( 'measles-model' )

def print_dist( states, dist, sb ):
    st = '\n'
    for s,p in zip(states,dist):
        if p > 0:
	    st += 'P(' + str(sb(s)) + ') = ' + str(p) + '\n'
    return st

def calc_final_size_distribution( model, N, init_cond, bindings=dynamicalsystems.Bindings() ):
    #print model.ode(), '+', bindings
    model = model.bind( bindings )
    print 'p_v =', model._bindings( p_v )
    print 'zeta_v =', model._bindings( zeta_v )
    print 'alpha_u_v =', model._bindings( 'alpha_u_v' )
    print model.ode()
    M = model.embedded_discrete_markov_matrix( N, RDF )
    #print '||M|| =', max( i for j in M for i in j )
    states = model.stochastic_states( N )
    sb = model.stochastic_state_binding_function()
    state_indexes = { s:i for i,s in enumerate(states) }
    print 'N =', N, ',', len(states), 'states'
    initial_dist_b = bindings( init_cond )
    initial_state = vector( ( initial_dist_b(v) for v in model._vars ) )
    #print initial_state
    initial_dist = vector( ( 1 if s == initial_state else 0 for s in states ) )
    #print initial_dist
    #print 'p_0:', print_dist( states, initial_dist, sb )
    if initial_dist.norm() == 0: raise ValueError, 'bad initial state'
    #print 'p_1:', print_dist( states, M*initial_dist, sb )
    #print model._bindings
    if False:
        M2N = M^(2*N)
        #print '||M^2N|| =', max( i for j in M2N for i in j )
        #print M2N.str( zero='.' )
        final_dist = M2N * initial_dist
    elif False: # see if this scales better
	its = M.iterates( initial_dist, 2*N, rows=False )
	final_dist = its.column(-1)
    else: # or how about with numpy
	import scipy.linalg, numpy
	m = numpy.array(M)
        final_dist = numpy.linalg.matrix_power( m, int(2*N) ).dot( numpy.array( initial_dist ) )
    #print 'p_2N:', print_dist( states, final_dist, sb ); sys.stdout.flush()
    pR = {}
    Rx = model._bindings('R')
    for s,i in state_indexes.iteritems():
        if final_dist[i] > 0:
            Rb = sb(s)(Rx)
	    pR[Rb] = pR.get( Rb, 0 ) + final_dist[i]
    pRpts = [ (k,pR[k]) for k in sorted(pR.keys()) ]
    #print pRpts
    print
    sys.stdout.flush()
    return pRpts

def calc_hom(N):
    # parameters for outbreak-size experiment
    init_I = 1/N  # initial number infected
    init_S = N - init_I
    init_cond = dynamicalsystems.Bindings(
        S = 1 - init_I,
        I = init_I,
        R = 0
    )
    return calc_final_size_distribution(
	measles_homogeneous,
	N,
	init_cond,
	hom_param_values
    )

#hom_runs = {
#    N:calc_hom(N)
#    for N in (3,5,7,9,11)
#}

def calc_het(N):
    # parameters for outbreak-size experiment
    init_I_v = 0    # initial number infected among vaccinated
    init_I_u = 1/N  # initial number infected among unvaccinated
    p_v = floor( p_v_base * N ) / N
    init_cond = dynamicalsystems.Bindings(
        I_u = init_I_u,
        I_v = init_I_v,
        S_u = 1 - p_v - init_I_u,
        S_v = p_v - init_I_v,
        R_u = 0,
        R_v = 0
    )
    return calc_final_size_distribution(
	measles_heterogeneous,
	N,
	init_cond,
	het_param_values.merge( p_v = p_v )
    )

#het_runs = {
#    N:calc_het(N)
#    for N in (3,5,7,9,11)
#}

ltx.close()

save_session( 'measles-run' )
</source-file>

<source-file filename=measles-output.sage.step texdisplay=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py $(SageDynamics)/latex_output.py
# requires: measles-run.sobj
# produces: measles-output.tex measles-p.svg

## this is currently unused
## output of the Kolmogorov equations for the stochastic measles box models,
## which is too inefficient to use
## We use discrete event simulations instead, see measles-simulate.sage.step,
## above.

from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['BoxModels'] )
import latex_output, boxmodel, boxmodelproduct

load_session( 'measles-run' )

ltx = latex_output.latex_output( 'measles-output.tex' )

ltx.close()

colors = rainbow( len(hom_runs) )
G = Graphics()
for N in sorted(hom_runs.keys()):
    G += list_plot( hom_runs[N], plotjoined=True, color=colors.pop(), legend_label='N='+str(N) )
G.save(
  filename='measles-hom-p.svg',
  #ymax=0.01,
  title='Outbreak size distribution for homogeneous measles',
  figsize=(4,4)
)

colors = rainbow( len(het_runs) )
G = Graphics()
for N in sorted(het_runs.keys()):
    G += list_plot( het_runs[N], plotjoined=True, color=colors.pop(), legend_label='N='+str(N) )
G.save(
  filename='measles-het-p.svg',
  #ymax=0.01,
  title='Outbreak size distribution for clustered measles',
  figsize=(4,4)
)
</source-file>

<!---
<project-file filename=measles-hom.svg/>

<project-file filename=measles-het.svg/>

<project-file filename=measles-output.tex/>

<project-file filename=measles-het-p.svg/>

<project-file filename=measles-hom-p.svg/>
--->

<!-- below this line, boring utility code that makes everything work -->

<source-file filename=glue.mk display=none>
include $(BoxModels)/upstream.mk
$(BoxModels)/% : /proc/uptime
	$(MAKE) -C $(BoxModels) $*
</source-file>

