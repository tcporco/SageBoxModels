---
layout: page
title: Notes on Box Models Implementation
wmd_project: Notes
wmd_prerequisite_projects:
  BoxModels: Box_Models
---

Here is a possible (partial, I'm sure) schema for box models. 
This is probably too detailed for real use, but I want to be detailed
some of the time to make sure I'm thinking clearly:

<source-file filename="boxmodel-schema-1.cd" display="boxmodel-schema-1.cd.crop.svg">
% code borrowed from http://lalashan.mcmaster.ca/theobio/worden/index.php/Commutative_Diagram
\begin{tikzpicture}[baseline= (operator in expression).base]
\node[scale=0.95] (a) at (0,0) {
\begin{tikzcd}[swap, math mode=false, column sep=huge, row sep=large]
  box model \\
  transition \arrow{u}[swap, near start]{is a transition of} \arrow[yshift=2pt]{r}{comes from} \arrow[yshift=-2pt]{r}[swap]{goes to}
    \arrow{d}{has as rate}
  & state \arrow{ul}[swap, near end]{is a state of}
  & parameter \arrow{ull}{is a parameter of} \\
  operator in expression \arrow[loop left]{l}[swap]{has as parent}
  & state in expression \arrow{l}{has as parent} \arrow{u}[swap]{is a mention of}
  & parameter in expression \arrow[bend left]{ll}{has as parent} \arrow{u}[swap]{is a mention of}
\end{tikzcd}
};
\end{tikzpicture}
</source-file>

For this box model:

<source-file filename="SI.sage.step" display="SI.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SI.sage.out.tex SI.boxes.tex
import os
import sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
from boxmodel import *

S, I, beta = SR.var( 'S I beta' )

SI = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I] )

SI.plot_boxes( 'SI.boxes.tex', figsize=(5,5) )
</source-file>

We might have these tables:

<source-file filename="SI-tables.cd" display="SI-tables.cd.crop.svg">
\begin{tabular}{c}
\texttt{box model} \\
\hline
\textbf{id} \\
bm1
\end{tabular}
\\*[1em]
\begin{minipage}[b]{0.45\linewidth}
\begin{tabular}{ccccc}
\multicolumn{5}{c}{\texttt{transition}} \\
\hline
\textbf{id} & \textbf{from} & \textbf{to} & \textbf{rate} & \textbf{model} \\
tr1 & st1 & st2 & oe1 & bm1
\end{tabular}
\end{minipage}
\hspace{2em}
\begin{minipage}[b]{0.3\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{state}} \\
\hline
\textbf{id} & \textbf{name} & \textbf{model} \\
st1 & $S$ & bm1 \\
st2 & $I$ & bm1
\end{tabular}
\end{minipage}
\hspace{1em}
\begin{minipage}[b]{0.2\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{parameter}} \\
\hline
\textbf{id} & \textbf{name} & \textbf{model} \\
pa1 & $\beta$ & bm1
\end{tabular}
\end{minipage}
\\*[1em]
\begin{minipage}[b]{0.35\linewidth}
\begin{tabular}{cccc}
\multicolumn{3}{c}{\texttt{operator in expression}} \\
\hline
\textbf{id} & \textbf{parent} & \textbf{operator} \\
oe1 & null & *
\end{tabular}
\end{minipage}
\hspace{2em}
\begin{minipage}[b]{0.3\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{state in expression}} \\
\hline
\textbf{id} & \textbf{parent} & \textbf{state} \\
se1 & oe1 & st1 \\
se2 & oe1 & st2
\end{tabular}
\end{minipage}
\hspace{2em}
\begin{minipage}[b]{0.2\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{parameter in expression}} \\
\hline
\textbf{id} & \textbf{parent} & \textbf{parameter} \\
pe1 & oe1 & pa1
\end{tabular}
\end{minipage}
</source-file>

The bottom row of these ("... in expression") is just the formalization of
the expression tree structure.  We have fine expression trees, so I don't think
we'll try to represent these using tables, I just want to have them in the
schema diagram at least to help in clear thinking. We might be able to infer
the relevant facts about $$\beta$$ from this structure.

We want the cross operation to produce this boxmodel, by figuring out that $$\beta I$$ is implicitly an inner product, but $$\beta S$$ isn't:

<source-file filename="SI2.sage.step" display="SI2.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SI2.sage.out.tex SI2.boxes.tex
import os
import sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
from boxmodel import *

Ss, Is, betas = {}, {}, {}

for i in (1,2):
    Ss[i] = SR.symbol('S_'+str(i))
    Is[i] = SR.symbol('I_'+str(i))
    betas[i] = {}
    for j in (1,2):
	betas[i][j] = SR.symbol('beta_'+str(i)+str(j), latex_name='\\beta_{'+str(i)+str(j)+'}')

SI2 = BoxModel(
    DiGraph(
	{ Ss[i]:{ Is[i]: Ss[i]*sum( betas[i][j]*Is[j] for j in (1,2) ) } for i in (1,2) },
	pos = { Ss[1]:[ 0,1 ], Ss[2]:[ 0,0 ], Is[1]:[ 1/2,1 ], Is[2]:[ 1/2,0 ] }
    ), [ Ss[1], Ss[2], Is[1], Is[2] ] )

SI2.plot_boxes( 'SI2.boxes.tex', figsize=(5,5) )
</source-file>

with maybe these tables:

<source-file filename="SI2-tables.cd" display="SI2-tables.cd.crop.svg">
\begin{tabular}{c}
\texttt{box model} \\
\hline
\textbf{id} \\
bm1
\end{tabular}
\\*[1em]
\begin{minipage}[b]{0.45\linewidth}
\begin{tabular}{ccccc}
\multicolumn{5}{c}{\texttt{transition}} \\
\hline
\textbf{id} & \textbf{from} & \textbf{to} & \textbf{rate} & \textbf{model} \\
tr1 & st1 & st2 & oe1 & bm1 \\
tr2 & st3 & st4 & oe5 & bm1
\end{tabular}
\end{minipage}
\hspace{2em}
\begin{minipage}[b]{0.3\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{state}} \\
\hline
\textbf{id} & \textbf{name} & \textbf{model} \\
st1 & $S1$ & bm1 \\
st2 & $I1$ & bm1 \\
st3 & $S2$ & bm1 \\
st4 & $I2$ & bm1
\end{tabular}
\end{minipage}
\hspace{1em}
\begin{minipage}[b]{0.2\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{parameter}} \\
\hline
\textbf{id} & \textbf{name} & \textbf{model} \\
pa1 & $\beta_{11}$ & bm1 \\
pa2 & $\beta_{12}$ & bm1 \\
pa3 & $\beta_{21}$ & bm1 \\
pa4 & $\beta_{22}$ & bm1 \\
\end{tabular}
\end{minipage}
\\*[1em]
\begin{minipage}[b]{0.35\linewidth}
\begin{tabular}{cccc}
\multicolumn{3}{c}{\texttt{operator in expression}} \\
\hline
\textbf{id} & \textbf{parent} & \textbf{operator} \\
oe1 & null & * \\
oe2 & oe1  & + \\
oe3 & oe2  & * \\
oe4 & oe2  & * \\
oe5 & null & * \\
oe6 & oe5  & + \\
oe7 & oe6  & * \\
oe8 & oe6  & *
\end{tabular}
\end{minipage}
\hspace{2em}
\begin{minipage}[b]{0.3\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{state in expression}} \\
\hline
\textbf{id} & \textbf{parent} & \textbf{state} \\
se1 & oe1 & st1 \\
se2 & oe3 & st2 \\
se3 & oe4 & st4 \\
se4 & oe5 & st3 \\
se5 & oe7 & st2 \\
se6 & oe8 & st4
\end{tabular}
\end{minipage}
\hspace{2em}
\begin{minipage}[b]{0.2\linewidth}
\begin{tabular}{ccc}
\multicolumn{3}{c}{\texttt{parameter in expression}} \\
\hline
\textbf{id} & \textbf{parent} & \textbf{parameter} \\
pe1 & oe3 & pa1 \\
pe2 & oe4 & pa2 \\
pe3 & oe7 & pa3 \\
pe4 & oe8 & pa4
\end{tabular}
\end{minipage}
</source-file>

... at least I think that's right.  The point is that it makes $$S$$ into
$$S_1$$ and $$S_2$$, and $$I$$ into $$I_1$$ and $$I_2$$ in the usual way,
but it somehow infers that it should make $$\beta$$ into four things, and
make $$\beta I$$ into $$\beta_{11}I_1 + \beta_{12}I_2$$ and
$$\beta_{21}I_1 + \beta_{22}I_2$$ while leaving the $$S$$ factors outside.

I'm wondering if it might be able to infer that from the facts that

* the expression $$\beta S I$$ involves two state variables, therefore $$\beta$$ is double indexed;
* the variable $$S$$ is tied to the source state $$S$$, so it keeps its index.

Is that sufficient to infer that $$\beta S I$$ is actually $$S\ \text{innerproduct}}(\beta, I)$$?  Is that a sensible thing to infer?

<!-- below this line, boring utility code that makes everything work -->

<source-file filename=glue.mk display=none>
include $(BoxModels)/upstream.mk
</source-file>
