---
layout: page
title: Box Models in Sage
wmd_project: Box_Models
wmd_prerequisite_projects:
  SageDynamicsRepo: SageDynamicsRepo
---

This is a preliminary stab at automating construction of compartment (box)
models in Sage.

The BoxModel and BoxModelProduct classes are at the end of this page.

## Test by making an SIR model

<source-file filename="SIR.sage.step">
# requires: boxmodel.py graph_latex_patched.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIR.sage.out.tex SIR.boxes.tex SIR.trajectory.png SIR.sobj
import os
import sys
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from latex_output import *

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SIR = BoxModel( DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ), [S,I,R] )

save_session( 'SIR.sobj' )

ltx = latex_output( "SIR.sage.out.tex" )

SIRode = SIR.ode()

ltx.write( 'SIR model:\n', SIRode )

ltx.close()

SIR.plot_boxes( 'SIR.boxes.tex', figsize=(5,5) )

epsilon = 0.01 # initial infectious pop
trajectory = SIRode.bind( { mu:0.1, alpha:1 } ).solve( [1-epsilon,epsilon,0], end_time=80 )
#trajectory.plot( 't', [S,I,R], filename='SIR.trajectory.png', figsize=(5,5) )
P = ( trajectory.plot( 't', S, color='blue', legend_label='$S$' )
    + trajectory.plot( 't', I, color='red', legend_label='$I$' )
    + trajectory.plot( 't', R, color='green', legend_label='$R$' )
)
P.save( filename='SIR.trajectory.png', figsize=(5,4), legend_loc='upper right' )

sys.exit(0r)
</source-file>

<project-file filename="SIR.sage.out.html"/>

<project-file filename="SIR.boxes.crop.svg"/>

<project-file filename="SIR.trajectory.png"/>

## test the cross product

<source-file filename=cross.sage.step lang=sage>
# requires: boxmodel.py boxmodelproduct.py graph_latex_patched.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: cross.sage.out.tex classes.boxes.tex SIR2.boxes.tex
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from boxmodelproduct import *
from latex_output import *

#print 'make SIR model'
sys.stdout.flush()

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )
SIR = BoxModel( DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ), [S,I,R] )

#print 'make classes model'
sys.stdout.flush()

A, B, a, b = SR.var( 'A B a b' )
classes = BoxModel( DiGraph( { A:{ B:A*a }, B:{ A:B*b } } ), [A,B] )

#print 'write latex'
sys.stdout.flush()

ltx = latex_output( "cross.sage.out.tex" )

ltx.write( 'SIR model:\n', SIR.ode() )

ltx.write( 'classes:\n', classes.ode() ) 

SIR2 = BoxModelProduct( SIR, classes )

ltx.write( 'cross:\n', SIR2.ode() )

ltx.close()

#print 'write tikz boxes'
sys.stdout.flush()

#classes.plot_boxes( 'classes.boxes.tex', figsize=(5,5) )
classes.plot().save( filename='classes.boxes.crop.svg', figsize=(5,5) )

try:
    SIR2.plot_boxes( 'SIR2.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    SIR2.plot().save( filename='SIR2.boxes.crop.svg', figsize=(5,5) )
</source-file>

<project-file filename=cross.sage.out.html/>

<project-file filename=classes.boxes.crop.svg/>

<project-file filename=SIR2.boxes.crop.svg/>

## The $$\beta$$ problem

<source-file filename=beta.sage.step lang=sage>
# requires: boxmodel.py boxmodelproduct.py graph_latex_patched.py
# requires: $(SageDynamics)/dynamicalsystems.py
# produces: beta.sage.out.tex beta.boxes.tex SI.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from boxmodelproduct import *
from latex_output import *

#print 'make SI model'
sys.stdout.flush()

S, I, beta = SR.var( 'S I beta' )
SI = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I] )

save_session( 'SI.sobj' )

#print 'make classes model'
sys.stdout.flush()

a, b, rho, sigma = SR.var( 'a b rho sigma' )
classes = BoxModel( DiGraph( { a:{ b:rho }, b:{ a:sigma } } ), [a,b] )

#print 'write latex'
sys.stdout.flush()

ltx = latex_output( "beta.sage.out.tex" )

ltx.write( 'SI model:\n', SI.ode() )

ltx.write( 'classes:\n', classes.ode() ) 

SIcross = BoxModelProduct( SI, classes )

ltx.write( 'cross:\n', SIcross.ode() )

SI2 = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[S,I] } )
SI2cross = BoxModelProduct( SI2, classes )

ltx.write( 'cross with double-indexing:', SI2cross.ode() )

SIx = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[(S,deps.index),(I,deps.sumover)] } )
SIxcross = BoxModelProduct( SIx, classes )

ltx.write( 'and the cross with correct double-indexing:', SIxcross.ode() )

ltx.close()

#print 'write tikz boxes'
sys.stdout.flush()

try:
    SIxcross.plot_boxes( 'beta.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    SIxcross.plot().save( filename='beta.boxes.crop.svg', figsize=(5,5) )
</source-file>

<project-file filename=beta.sage.out.html/>

<project-file filename=beta.boxes.crop.svg/>

## The Adler averaging result

Fred Adler ([1992](http://www.sciencedirect.com/science/article/pii/002555649290080G)) has studied an SI model:

$$\frac{dI_i}{dt} = (\beta\sum_{j=1}^n \lambda_{ij}I_j) S_i$$

$$S_i = T_i - I_i$$

(which is in fact the Rushton-Mautner model, seen in the $$\beta$$ section above).

Adler's result is that removing structure by averaging classes $$i$$ together
can only decrease or preserve the reproduction ration $$R_0$$, that is, that
$$R_0$$ is nondecreasing with diversity of the box model.  I'd like to
reproduce that result in our cross-product framework.

So we begin with a basic SI model, as the horizontal structure for our crosses:

<source-file filename=adler-SI.sage.step display=adler-SI.boxes.crop.svg>
# requires: boxmodel.py graph_latex_patched.py
# requires: $(SageDynamics)/dynamicalsystems.py
# produces: adler-SI.boxes.tex adler-SI.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
import boxmodel

S, I, beta = SR.var( 'S I beta' )
lb = SR.symbol( 'lmbda', latex_name='lambda' )
SI = boxmodel.BoxModel( DiGraph( { S:{ I:lb*beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[], lb:[(S,boxmodel.deps.index), (I,boxmodel.deps.sumover)] } )

SI.plot_boxes( 'adler-SI.boxes.tex', figsize=(5,5) )

save_session( 'adler-SI' )
</source-file>

and cross with a given mixing matrix $$\Lambda$$:

<source-file filename=adler_mixing.py.step lang=py>
# requires: boxmodel.py $(SageDynamics)/dynamicalsystems.py graph_latex_patched.py
# produces:
import sys, os
#sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
from sage.all import *
import dynamicalsystems
import boxmodel

def mixing_model( Lambda ):
    # Lambda must be a square matrix;
    # or a number of states, in case we want to provide the mixing rates later
    try:
	dim = Lambda.ncols()
	if not Lambda.is_square():
	    # note is_square() actually succeeds if Lambda is a number
	    # but ncols() doesn't
	    raise ValueError( "matrix in mixing_model() must be square" )
        l_in = dynamicalsystems.indexer_2d( 'lambda' )
	bindings = dynamicalsystems.Bindings( {
	    l_in[i][j] : Lambda[i, j] for i in range(dim) for j in range(dim)
	} )
    except AttributeError: # not a matrix
	dim = Lambda
	bindings = dynamicalsystems.Bindings()
    # create disconnected graph of that many vertices
    # and bind the lambda values
    return boxmodel.BoxModel(
	DiGraph( { i:[] for i in range(dim) } ),
	bindings = bindings
    )
</source-file>

For example:

<source-file filename=adler-example.sage.step display=adler-example.boxes.crop.svg>
# requires: boxmodel.py boxmodelproduct.py $(SageDynamics)/dynamicalsystems.py
# requires: adler_mixing.py graph_latex_patched.py
# requires: adler-SI.sobj
# produces: adler-example.boxes.tex adler-example.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
#sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import boxmodel, boxmodelproduct
import adler_mixing

load_session( 'adler-SI' )

L2 = adler_mixing.mixing_model( 2 )

example = boxmodelproduct.BoxModelProduct( SI, L2 )

try:
    example.plot_boxes( 'adler-example.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    example.plot().save( filename='adler-example.boxes.crop.svg', figsize=(5,5) )
save_session( 'adler-example' )
</source-file>

In this class of models, the total size of each mixing class
$$T_i=S_i+I_i$$ is conserved.

An average over mixing classes $$i$$ is defined by replacing the groups of
the vertical model, $$G_i$$, by some smaller set of groups with

$$\bar{G}_s = \cup_{i\in\sigma_s}G_i$$,

where $$\{\sigma_s\}$$ is a partition of the non-averaged groups
$$\{1,\ldots,i,\ldots,n\}$$.

In the averaged model, the mixing rates $$\lambda_{ij}$$ are replaced by

$$b_{st} = \frac{\sum_{i\in\sigma_s}\sum_{j\in\sigma_t}T_i\lambda_{ij}T_j}{\bar{T}_s\bar{T}_t}$$.

The result is that

* _If the mixing matrix is symmetric and primitive, then the leading eigenvalue
of the Jacobian matrix associated with the combined system is less than or
equal to that associated with the full system._

This eigenvalue is closely related to the value of $$R_0$$, so it defines
the direction of change of the initial rate of infection.

We should be able to study the infection rate more or less directly...

<source-file filename=adler-R0.sage.step display=adler-R0.sage.out.html>
# requires: boxmodel.py $(SageDynamics)/dynamicalsystems.py
# requires: $(SageUtils)/latex_output.py graph_latex_patched.py
# requires: adler-example.sobj
# produces: adler-R0.sage.out.tex adler-R0.sobj
import sys
import os
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import boxmodel
#import adler_mixing

# pickling bug
lb = SR.symbol( 'lmbda', latex_name=r'\lambda' )
[ dynamicalsystems.subscriptedsymbol( lb, i, j ) for i in (0,1) for j in (0,1) ]

load_session( 'adler-example' )

ltx = latex_output( "adler-R0.sage.out.tex" )

ODE2 = example.ode()

ltx.write( ODE2 )

#ltx.write( 'equilibria are:' )
#ltx.write_block( ODE2.equilibria() )
ltx.write( 'We are interested in the rate of infection near the boundary state' )

dfeq = dict( [
	( s, SR.symbol( str(s).replace('S','T') ) )
	for s in example._aggregate_variables[SR('S')]
    ] + [
	( i, SR(0) )
	for i in example._aggregate_variables[SR('I')]
    ] )
print dfeq

ltx.write_equality( vector( ODE2._vars ), vector( [ dfeq[v] for v in ODE2._vars ] ) )

dfjac = ODE2.jacobian_matrix( at=dfeq )

ltx.write( 'The Jacobian there is' )
ltx.write_block( dfjac )

dfepss = dict( [
	( s, - SR.symbol( str(s).replace('S','\epsilon') ) )
	for s in example._aggregate_variables[SR('S')]
    ] + [
	( i, SR.symbol( str(i).replace('I','\epsilon') ) )
	for i in example._aggregate_variables[SR('I')]
    ] )
dfeps = vector( [ dfepss[v] for v in ODE2._vars ] )

ltx.write( 'In the linearization there, the growth rate in the direction' )
ltx.write_block( dfeps )

ltx.write( 'is' )

growth_vector = (dfjac * dfeps).simplify()
ltx.write_block( growth_vector )

gr_dict = { v:gv for v,gv in zip(ODE2._vars, growth_vector) }
gr_I = reduce( lambda x,y: x+y, (gr_dict[i] for i in example._aggregate_variables[SR('I')]) )
ltx.write( 'so that the growth rate of $I = I_0+I_1$ is $', gr_I, '$.' )

ltx.write( '\n\nMeanwhile, the eigenvalues of the Jacobian there are' )
ltx.write_block( dfjac.eigenvalues() )

ltx.close()

save_session( 'adler-R0' )
</source-file>


## BoxModel class

Here's a class to represent a box model, and a class to implement the cross
product. The BoxModel class constructs itself from a directed graph whose
vertices and arrows are symbolic expressions (state variables and flow rates),
and can draw itself as a directed graph and translate itself to an ODE.

<source-file filename=boxmodel.py.step lang=python>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageAdaptiveDynamics)/adaptivedynamics.py graph_latex_patched.py
import graph_latex_patched
from sage.all import *
import os
import sys
 
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import latex_output

from sage.misc.latex import _latex_file_
#from sage.symbolic.relation import solve
from sage.symbolic.function_factory import function

# constant 'enum' values for use with indexing
class deps:
    index, sumover = range(0,2)

class BoxModel(SageObject):
    """Parent class for all kinds of box models.
    Note that since this gets its variables from a graph's vertices,
    rather than from indexers, it can't be used in adaptive dynamics.
    Subclasses that generate their boxes, maybe can.
    """
    def __init__(self, graph,
	vars=None,
	parameters=None,
	parameter_dependencies={},
	flow_graph=None,
        bindings=dynamicalsystems.Bindings()):
	# we are given a directed graph whose vertex labels are state
	# variables, representing fractions of total population,
	# and whose edge labels are flow rates.
	try:
	    graph.edge_iterator()
	except AttributeError:
	    graph = DiGraph(graph)
	self._graph = graph
	self._graph.set_latex_options( edge_labels=True )
	self._graph.set_latex_options( vertex_shape='rectangle' )
	if vars is None:
	    vars = graph.vertices()
	self._vars = vars
	if parameters is None:
	    # avoid namespace confusion with boxmodelproduct.union
	    parameters = reduce( lambda x,y: x.union(y), (r.variables() for f,t,r in graph.edges()), set([]) ).difference( self._vars )
	self._parameters = parameters
	#print 'parameters:', parameters
	self._parameter_dependencies = parameter_dependencies
	for p in self._parameters:
	    if p not in self._parameter_dependencies:
		# infer connections between parameters and compartmentalization
		# for now, simple rule:
		# just connect it to the source variable of its arrow
		# TODO: inference including defined quantities like N
		#print 'infer dependencies for parameter', p
		for v,w,e in self._graph.edges():
		    if p in e.variables():
			pd = [ v ]
			#print 'found', p, 'in arrow', e
			#print 'infer dependency on', v
			if p in self._parameter_dependencies and self._parameter_dependencies[p] != pd:
			    #print 'but already inferred', self._parameter_dependencies[p]
			    #print 'dependencies of parameter', p, 'are unclear, inferring no dependencies'
			    pd = []
			self._parameter_dependencies[p] = pd
	for p, pd in self._parameter_dependencies.items():
	    try: [ d[0] for d in pd ]
	    except: self._parameter_dependencies[p] = [ (d,deps.index) for d in pd ]
	#print 'parameter dependencies:', self._parameter_dependencies
	self._bindings = bindings
	if self._graph.get_pos() is None:
	    self._graph.set_pos( { v:(i,0) for i,v in enumerate(self._vars) } )
	if flow_graph is None:
	    flow_graph = self._graph
	self._flow_graph = flow_graph
    def bind(self, *args, **vargs):
	bindings = dynamicalsystems.Bindings( *args, **vargs )
	# TODO: this will not bind cross product correctly
	bound_flow_graph = DiGraph( [
	        (bindings(v),bindings(w),bindings(e)) for v,w,e in self._flow_graph.edge_iterator()
	    ],
	    multiedges=True,
	    pos = { bindings(v):p for v,p in self._flow_graph.get_pos().items() } if self._flow_graph.get_pos() is not None else None
	)
	return BoxModel(
	    bound_flow_graph,
	    vars = [ bindings(v) for v in self._vars ],
	    parameters = [ bindings(p) for p in self._parameters ],
	    parameter_dependencies = {
		bindings(p):[(bindings(d),t) for d,t in pd] for p,pd in self._parameter_dependencies.items()
	    },
	    flow_graph = bound_flow_graph,
	    bindings = self._bindings + bindings
	)
    def add_transitions( self, trs ):
	# We take BoxModel to be an immutable object, so this operation
	# returns a new BoxModel.  trs is a list of (source,target,rate)
	# tuples suitable for adding to self._graph (rather than _flow_graph).
	nbm = deepcopy(self)
	nbm._graph.add_edges( trs )
	if self._flow_graph is not self._graph:
	    nbm._flow_graph.add_edges( trs )
	return nbm
    def ode_flow(self):
	flow = { v:0 for v in self._vars }
	#print flow
	for source,target,rate in self._flow_graph.edges():
	    #print source, '-$%s$->'%latex(rate), target
	    flow[source] -= rate
	    flow[target] += rate
	return flow
    def ode(self, time_variable=SR.symbol('t'), bindings=dynamicalsystems.Bindings()):
	return dynamicalsystems.ODESystem(
	    self.ode_flow(),
            self._vars,
	    time_variable,
            bindings = bindings+self._bindings )
    def tikz_boxes( self, raw=False, inline=False, figsize=(6,6), **options ):
	if raw:
	    g = self._graph
	else:
	    g = self._flow_graph
	lopts = {
	    'graphic_size': figsize,
	    'edge_labels': True,
	    'edge_thickness' : 0.02,
	    #'edge_fills': True,
	    #'edge_color': 'white',
	    #'edge_thickness': 0.05
	}
	graph_latex_patched.setup_latex_preamble()
	gop = graph_latex_patched.GraphLatex(g)
	if inline:
	    lopts['margins'] = (0.5,0.5,0.5,0.5)
	lopts.update( options )
	#g.set_latex_options( **lopts )
	gop.set_options( **lopts )
	if inline:
	    #return '\n\\vspace{24pt}\n' + latex( g ) + '\n\\vspace{24pt}\n'
	    return gop.latex()
	#return _latex_file_( g, title='' )
	return _latex_file_( latex_output.wrap_latex( gop.latex() ), title='' )
    def plot_boxes( self, filename=None, raw=False, inline=False, **options ):
	# new Tikz/SVG code
	#print 'plot to', filename
        LF = open( filename, 'w' )
	LT = self.tikz_boxes( raw, inline, **options )
	LF.write( LT )
        LF.close()
	return LT
    def plot( self, *args, **aargs ):
	def lx(s): return '$%s$'%latex(s)
	lfg = DiGraph(
	    [[lx(s) for s in tup] for tup in self._flow_graph.edge_iterator() ],
	    multiedges=True
	)
	vargs = {
	    'edge_labels' : True,
	    'talk' : True
	}
	print 'flow_graph pos:', self._flow_graph.get_pos()
	if 'pos' not in aargs and self._flow_graph.get_pos() is not None:
	    vargs['pos'] = { lx(v) : p for v,p in self._flow_graph.get_pos().items() }
	vargs.update( aargs )
	print 'plot vargs:', vargs
	return lfg.plot( *args, **vargs )
    def transpose_graph_in_place( self ):
	self._graph.set_pos( { v:(-y,-x) for v,(x,y) in self._graph.get_pos().iteritems() } )
	if self._flow_graph is not self._graph:
	    self._flow_graph.set_pos( { v:(-y,-x) for v,(x,y) in self._flow_graph.get_pos().iteritems() } )
    def transpose_graph( self ):
	nm = deepcopy( self )
        nm.transpose_graph_in_place()
	return nm
    def micro_transitions( self ):
	# This could produce micro transitions but it isn't right so far
	ltx = latex_output.latex_output_base( latex_output.write_to_string() )
	lines = []
	for source, target, rate in self._flow_graph.edge_iterator():
	    mu = MakeMicro( self, source )
	    ut = mu( rate )
	    print str(ut); sys.stdout.flush()
	    lines += [ r'  & ' + latex(mu.sigma_fn(SR('x'))) + r'\to' + latex(target)
		+ r' \quad\text{ at rate } '
		+ latex( ut )
	    ]
	ltx.write_align( *lines )
	return ltx._output._str
    def aggregate_compartments( self, compartment_aggregation ):
        aggregate = {}
        for vt in self._graph.vertex_iterator():
            aggregate.setdefault( tuple( compartment_aggregation( vt.operands() ) ), [] ).append( vt.operands() )
        ## aggregate is { new vertex: [old vertices], ... }
        print 'aggregate:', aggregate
        flow_sums = {}
        for v in self._graph.vertex_iterator():
	    av = compartment_aggregation( v )
	    if av not in flow_sums: flow_sums[av] = {}
	    for _,w,e in self._graph.outgoing_edge_iterator(v):
		aw = compartment_aggregation( w )
	        flow_sums[av].setdefault( aw, SR(0) )
	        flow_sums[av][aw] += e
	## flow_sums[av][aw] is sum of all transitions from
	## (aggregated vertex) av to aw
	## transitions are in terms of old vertex names

        ## now do substitutions to transform the transition sums
        agg_eqns, agg_symbols = [], []
        agg_subs = dynamicalsystems.Bindings()
        for newt,oldts in aggregate.items():
            print 'will combine', sum( oldts ), '==', newt
            agg_symbols.append( oldts[0] )
            agg_eqns.append( oldts[0] == newt - sum( oldts[1:] ) )
        agg_graph_dict = {}
        for av, ve in flow_sums.iteritems():
            agg_graph_dict[av] = {}
            for aw, e in ve.iteritems():
    	        sym = SR.symbol()
    	        print e,
    	        solns = solve( [ sym == e ] + agg_eqns, sym, *agg_symbols, solution_dict=True )
    	        #print 'solve', [ sym == e ] + agg_eqns, ',', [sym] + agg_symbols, '\n  ', solns
    	        if len(solns) == 1:
    	            #print '  ', maxima(sym), [str(k) == str(sym) for k in solns[0].keys()]
    	            el = [ex for k,ex in solns[0].items() if str(k) == str(sym)]
    	            print '==>', el[0]
    	            agg_graph_dict[av][aw] = el[0]
    	        else:
    	            raise RuntimeError, 'Could not simplify expression ' + str(e) + ':' + str(solns)
	print 'agg_graph_dict', agg_graph_dict
        #self._vc_eqns = vc_eqns
	## make list of transformed variables
	## they are in those dicts, but we want the order
        agg_vars = []
        for v in self._vars:
	    av = compartment_aggregation( v )
	    if av not in agg_vars: agg_vars.append(av)
	print 'agg_vars', agg_vars
        ## position the aggregates by matching them to a subset of original
	## compartments
	apos = {}
	for t,p in self._graph.get_pos().iteritems():
	    at = compartment_aggregation( t )
	    if at not in apos: apos[at] = p
	print 'apos', apos
        return boxmodel.BoxModel( DiGraph( agg_graph_dict, pos=apos ), agg_vars )
    def combine_arrows( self ):
	return self.aggregate_compartments( lambda x:x )
    def separate_arrows( self ):
	plus = SR('x+1').operator()
	def arrow_iterator( e ):
	    e = e.expand()
	    if e.operator() == plus:
		for t in e.operands():
		    for tt in arrow_iterator(t):
		        yield t
	    else:
		yield e
	return BoxModel( DiGraph(
		[ (v,w,ee) for v,w,e in self._graph.edge_iterator() for ee in arrow_iterator(e) ],
		pos = self._graph.get_pos(),
		multiedges=True
	    ),
	    self._vars
	)

# useful parent class: expression converter that doesn't
# do anything
from sage.symbolic.expression_conversions import SubstituteFunction
class IdentityConverter(SubstituteFunction):
    def __init__(self):
	pass
    def composition(self, ex, operator):
	# override the parent class's function replacing step
	return operator(*map(self, ex.operands()))

class MakeMicro(IdentityConverter):
    _mul = SR('a*b').operator()
    from sage.symbolic.function_factory import function
    delta_fn = function('delta', latex_name=r'\delta')
    sigma_fn = function('sigma', print_latex_func=lambda self, x:r'\sigma_{%s}' % latex(x))
    bm_sum = function( 'sum', print_latex_func=lambda self, x, s, ex:r'\sum_{%s\in %s}%s' %( latex(x), latex(s), latex(ex) ) )
    bm_indicator = function( 'indicator', print_latex_func=lambda self, ev:r'\mathbb{1}\left(%s\right)' % latex(ev) )
    bm_index_param = function( 'bm_index_param' )
    def __init__(self, model, source):
	self._model = model
	self._source = source
	self._working = False
	self._tags = { s : SR.symbol( 'text'+str(s), latex_name=r'\texttt{%s}'%str(s) ) for s in self._model._vars }
    def __call__(self, ex):
	if self._working:
	    return super(MakeMicro,self).__call__(ex)
	self._working = True
	tx = super(MakeMicro,self).__call__( ex / self._source )
	self._working = False
	return (
	   self.bm_indicator( self.sigma_fn( SR.symbol('x') ) == self._tags[self._source] ) *
	   tx.subs( { s : self.bm_sum( SR.symbol('y'), SR.symbol('X'), 1 / SR('N') * self.bm_indicator( self.sigma_fn( SR('y') ) == self._tags[s] ) ) for s in self._model._vars } )
	)
    def arithmetic(self, ex, operator):
	# do special handling to products of things, before processing the
	# things, to catch inner products
	if operator == self._mul:
	    return self.do_inner_product( *ex.operands() )
	else:
	    return reduce( operator, *map(self, ex.operands()) )
    def symbol(self, s):
	return self.do_inner_product( s ) # just in case
    def do_inner_product(self, *args):
	# leave multiplications as is, except in the case of a
	# parameter dependency marked "sumover": convert that from
	# a regular multiplication to an inner product.
	print 'processing product', args
	margs = list(args)
	sumover = []
	dummy_list = ['y', 'z', 'u', 'v', 'w', 's', 't', 'p', 'q', 'r']
	for p,pd in self._model._parameter_dependencies.items():
	    if p in margs:
		print 'found', p, 'in factors:', args
		if all( d in margs + [self._source] for d,x in pd ):
		    print 'found all of its deps', [d for d,x in pd], 'as well'
		    indices_for_p = []
		    p_times = SR(1)
		    for d,ss in pd:
			if ss == deps.sumover:
			    dummy_var = SR.symbol( dummy_list.pop(0) )
			    indices_for_p.append( dummy_var )
			    sumover.append( dummy_var )
			    print 'will sum over', dummy_var, 'in', d; sys.stdout.flush()
			    margs[margs.index(d)] = 1
			    p_times *= self.bm_indicator( self.sigma_fn( dummy_var ) == self._tags[d] )
			    print 'made it through equality'; sys.stdout.flush()
			elif d == self._source:
			    indices_for_p += [SR('x')]
			else:
			    raise ValueError, 'I am confused about dependence on ' + str(d)
		    index_of_p = margs.index(p)
		    margs[index_of_p] = self.bm_index_param( p, *indices_for_p ) * p_times
		    for dv in reversed(sumover):
			margs[index_of_p] = self.bm_sum( dv, SR.symbol('X'), 1 / SR('N') * margs[index_of_p] )
		    margs[index_of_p] = margs[index_of_p].substitute_function(
			self.bm_index_param,
			lambda *args: dynamicalsystems.subscriptedsymbol( *args )
		    )
		    print margs
		else:
		    raise RuntimeError, (
			"Missing parameter dependencies in expression " +
			str( reduce( self._mul, args ) )
		    )
	expr = reduce( self._mul, margs )
	print 'becomes', expr
	return expr
</source-file>

<source-file filename=boxmodelproduct.py.step lang=python>
# requires: boxmodel.py
from sage.all import *
import dynamicalsystems, boxmodel

# function names used by the edge generator: we can't put tuples into
# symbolic expressions directly so we represent them by instances like
# bm_state( S, a ), bm_param( beta, S, I ), etc.
from sage.symbolic.function_factory import function
bm_state = function( 'bm_state', latex_name='X' )
bm_param = function( 'bm_param', print_latex_func=lambda bmp, p, *xs:'{0}({1})'.format(latex(p),','.join( latex(x) for x in xs )) )

# The general cross product represents its states as tuples of the
# original model's states.  This function can be replaced by another
# one to, for example, make some of these derived compartments synonyms
# for one another, or simply to give them different names.
# This is distinct from a compartment aggregation function, see below,
# which adds compartments together instead of declaring them equivalent.
def default_compartment_renaming(*args):
    return tuple(args)

# A mapping from composite compartment names (tuples) into aggregate
# quantities, for the purpose of summing compartments.  This is distinct
# from a compartment renaming function, above.
def default_compartment_aggregation(*args):
    return tuple(args)

# by default, make tuples of state variables into combined state variables by
# subscripting the first with the others
default_vertex_namer = dynamicalsystems.subscriptedsymbol

# sometimes we want to use this instead.  Rather than
# (S,a) -> 'S_a', gives (S,a) -> 'X_{Sa}'.
def x_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'X', *ss )

# We are given an original parameter plus a list of tuples and indices into
# them.  For example, (beta, (S,I), 0, (I,I), 0, (I,I)),
# for the beta parameter for the transition in the first S of (S,I) to
# I as a result of contact with the first I in (I,I).
# We return a bm_param expression that can be used in SR
# (i.e. no tuples in the arguments) and ready to be made into a subscripted
# variable.
# In the simple case, we call this bm_param( beta, S, I ) because
# that's enough to uniquely identify it.  This will become beta_{SI}.
# If there are cross interactions
# between for instance the S class from the first model and the I class
# from the second model, we need more detailed subscripting, see below.
def default_param_relabeling( *vtuple ):
    print 'simple param relabeling', vtuple
    pairwise = iter(vtuple[1:-1])
    return bm_param( *( (vtuple[0],) + reduce( lambda l,m:l+m, (t[:i] + t[i+1:] for t,i in zip(pairwise,pairwise) ) ) ) )

# Fuller parameter subscripting.  For example for
# (beta, (S,I), 1, (I,I), 2, (I,I))
# we return bm_param( beta, S, I, 1, I, I, 2 ).
def full_param_relabeling( *vtuple ):
    print 'full_param_relabeling', vtuple
    from matplotlib.cbook import flatten
    return bm_param( *(flatten(vtuple[:-1])) )

def default_vertex_positioner( graph, models ):
    """default_vertex_positioner:
    construct an X-Y position for each vertex of the product graph.
    assumes the vertices of the graph are tuples of vertices of the
    models' graphs, in order."""
    directions = [ 0, pi/2, pi/6, pi/3 ] # will add more as needed, I guess
    rotations = [ matrix( [[cos(th),sin(th)],[-sin(th),cos(th)]] ) for th in directions ]
    seq = { v:i for m in models for i,v in enumerate(m._vars) }
    original_positions = [
	m._flow_graph.get_pos() if m._flow_graph.get_pos() is not None else { v:(i,0) for i,v in enumerate(m._vars) }
	for m in models
    ]
    print 'original_positions:',original_positions
    positions = {
	t : sum( r*vector(p[v]) for r,p,v in zip(rotations, original_positions, t.operands()) )
	for t in graph.vertex_iterator()
    }
    #positions = {
	#t: [
	#    sum(seq[v]*cos(d) for v,d in zip(t.operands(), directions)),
	#    - sum(seq[v]*sin(d) for v,d in zip(t.operands(), directions))
        #] for t in graph.vertex_iterator()
    #}
    print 'positions:', positions
    return positions
    import itertools
    positions = {
        tuple(a[1] for a in dtup): [
	    sum(a[0]*cos(d) for a,d in zip(dtup,self.directions)),
	    - sum(a[0]*sin(d) for a,d in zip(dtup,self.directions))
        ] for dtup in itertools.product(
	    *[ enumerate(m._vars) for m in models ]
        )
    }

def default_sop( s_tuple, i, s, t, r ):
    #print 'sop', s_tuple, i, s, t, r
    # return set of t_tuples
    return Set( [ s_tuple[:i] + (t,) + s_tuple[i+1:] ] )
def default_bop( s_tuple, i, c_tuple, i_, s, t, r ):
    # return set of t_tuples
    return Set( [ s_tuple[:i] + (t,) + s_tuple[i+1:] ] )

def tuple_inclusions( c, tup ):
    return [ iota for iota,x in enumerate(tup) if x == c ]

class BoxModelProductException(Exception): pass

# 'single edge stratifier' is called once for each edge of each
# component model, given a set of product vertices.  It loops
# over those vertices and generates all the product edges involving
# those vertices that are versions of that one component edge.
def default_single_edge_stratifier(
	source, target, rate, i, models,
	seed_set, vertex_namer, param_relabeling, compartment_renaming,
	old_set=Set(), cross_interactions=True,
	unary_operation=default_sop, binary_operation=default_bop,
	inclusions=tuple_inclusions
    ):
    print 'old set', old_set, '/ seed set', seed_set
    # produce all product edges made from this component edge
    # list the compartments involved in the transition
    rate_comps = [ x for x in rate.variables() if x in models[i]._vars ]
    rate_params = set( rate.variables() ) - set( rate_comps )
    # we can handle constant, linear or bilinear transitions
    if rate_comps == [] or rate_comps == [source]:
	for V in seed_set:
	    s_inclusions = inclusions( source, V )
	    for iota in s_inclusions:
		repl = { source: bm_state( *compartment_renaming( *V ) ) }
	        for W in unary_operation( V, iota, source, target, rate ):
		    print W
		    # TODO: param_namer
		    repl.update( { p: param_relabeling( p, V, iota, W ) for p in rate_params } )
		    yield ( V, W, rate.subs( repl ) )
    elif len(rate_comps) == 2 and source in rate_comps:
	catalyst, = set(rate_comps) - set([source])
        import itertools
	for V,C in itertools.chain( itertools.product(seed_set, old_set), itertools.product(old_set + seed_set, seed_set) ):
	    print 'consider', V, '+', C, 'at', i
	    # do only the one source inclusion here to avoid duplication
	    #s_inclusions = [ iota for iota,x in enumerate(V) if x == source and iota == i ]
	    s_inclusions = Set( inclusions( source, V ) ).intersection( Set( [i] ) )
	    print source, 'in V:', s_inclusions
	    for iota in s_inclusions:
		if cross_interactions:
		    c_inclusions = inclusions( catalyst, C )
		else:
		    c_inclusions = Set( inclusions( catalyst, C ) ).intersection( Set( [i] ) )
		print catalyst, 'in C:', c_inclusions
		for iota_ in c_inclusions:
	            print 'do edges for', V, iota, C, iota_
		    repl = {
			source: bm_state( *compartment_renaming( *V ) ),
			catalyst: bm_state( *compartment_renaming( *C ) )
		    }
		    for W in binary_operation( V, iota, C, iota_, source, target, rate ):
		        repl.update( { p: param_relabeling( p, V, iota, C, iota_, W ) for p in rate_params } )
		        print V, iota, C, iota_, ':', compartment_renaming( *W ), rate.subs( repl )
		        yield ( V, W, rate.subs( repl ) )
		        if V == C:
			    # TODO: is this within-class case right in general?
			    # A: no, needs iota_ somewhere
		            repl.update( { p: param_relabeling( p, V, iota, iota_, W ) for p in rate_params } )
		            print V, iota, iota_, ':', W, rate.subs( repl ) / bm_state(*C)
		            yield( V, W, rate.subs( repl ) / bm_state(*compartment_renaming(*C)) )
    else: # wrong variables in rate
	raise BoxModelProductException, "Don't understand rate {0}".format(rate)

def simple_edge_stratifier( *args, **kwargs ):
    kwargs['cross_interactions'] = False
    return default_single_edge_stratifier( *args, **kwargs )

# This edge generator is called to generate a set of product edges
# given a set of product compartments and the component models.
# It calls its single_edge_generator once for each edge of each
# component model, to generate all the product edges made from
# that original edge.
def default_edge_generator(
	models,
	vertex_namer, param_relabeling, compartment_renaming,
	single_edge_generator=None,
	seed_set=None, cross_interactions=True,
	unary_operation=default_sop, binary_operation=default_bop,
	inclusions=tuple_inclusions
    ):
    if single_edge_generator is None:
	single_edge_generator = default_single_edge_stratifier
    # TODO: hacky, fix
    # should be if param_relabeling is none then deduce labeling
    if (
	(param_relabeling is default_param_relabeling) and
	cross_interactions and
	any( not Set(m1._vars).intersection( Set(m2._vars) ).is_empty() for m1 in models for m2 in models if m2 is not m1 )
    ):
	param_relabeling = full_param_relabeling
    import itertools
    if seed_set is None:
	seed_set = Set( itertools.product( *(m._vars for m in models) ) )
    edges = []
    old_vertices = Set()
    while not seed_set.is_empty():
        # for each edge of each model, we generate a set of derived edges
        # in the product model
        new_edges = list( itertools.chain( *(
	    single_edge_generator(
	        v, w, r, i, models, seed_set,
	        vertex_namer, param_relabeling, compartment_renaming,
		old_set=old_vertices,
	        unary_operation=unary_operation,
		binary_operation=binary_operation,
		cross_interactions=cross_interactions,
		inclusions=inclusions
	    )
	    for i in range(len(models))
	    for v,w,r in models[i]._graph.edge_iterator()
        ) ) )
	edges += new_edges
	# the edges returned may involve vertices we didn't anticipate
	# so we expand our set of vertices dynamically
	# in which case, we have to do the generation again to include
	# transitions involving the new vertices
        old_vertices += seed_set
        seed_set = Set( v for v,w,r in new_edges ).union( Set( w for v,w,r in new_edges ) ) - old_vertices
	if len(old_vertices) + len(seed_set) > 100:
	    raise RuntimeError, 'Recursion produces too many compartments'
    return [ ( bm_state( *compartment_renaming( *V ) ), bm_state( *compartment_renaming( *W ) ), r ) for V,W,r in edges ]

class CompositeBoxModel(boxmodel.BoxModel):
    """CompositeBoxModel is a boxmodel structure in which compartment names,
    and maybe some parameters, have structure.  Unlike the base BoxModel,
    here we maintain two representations of the graph: one with structure --
    in which each compartment is represented by a 'bm_state' function of
    multiple arguments, and all or some parameters are represented by a
    'bm_param' function of multiple arguments.  Those argument lists are
    transformed to simple SR variable names by the vertex_namer and
    param_namer functions."""
    def __init__(
	    self,
	    graph,
	    var_tuples,
	    vertex_namer=x_namer,
	    param_namer=dynamicalsystems.subscriptedsymbol,
	    bindings=dynamicalsystems.Bindings()
	):

	self._graph = graph
	self._graph.set_latex_options( edge_labels=True, vertex_shape='rectangle' )

	# now for consumption by humans and math software, we map vertex
	# tuples to regular variable names with subscripts
	bm_to_vars = lambda e: e.substitute_function( bm_param, param_namer ).substitute_function( bm_state, vertex_namer )
	def bind_edges( edges, bindings ):
	    print 'here is bindings:', bindings
	    for v, w, e in edges:
	        be = bindings(bm_to_vars(e))
		print 'bind', e, 'to', bm_to_vars(e), 'to', be
	        if be != 0: yield ( bm_to_vars(v), bm_to_vars(w), be )
	self._flow_graph = DiGraph(
	    list( bind_edges( self._graph.edge_iterator(), bindings ) ),
	    multiedges=True
	)
	self._flow_graph.set_latex_options( edge_labels=True, vertex_shape='rectangle' )
	positions = self._graph.get_pos()
	if positions is not None:
	    self._flow_graph.set_pos( { bm_to_vars(v):pos for v,pos in positions.items() } )

	self._var_tuples = var_tuples
	self._vars = [ bm_to_vars(v) for v in var_tuples ]
	self._vertex_namer = vertex_namer
	self._param_namer = param_namer
	self._bindings = bindings
    def bind(self, *args, **vargs):
	return CompositeBoxModel(
	    self._graph,
	    self._tuples,
	    self._vertex_namer,
	    self._param_namer,
	    self._bindings + dynamicalsystems.Bindings( *args, **vargs )
	)
    def combine_arrows( self ):
	return self.aggregate_compartments( lambda x:tuple(x), self._param_namer, self._vertex_namer )
    def separate_arrows( self ):
	plus = SR(x+1).operator()
	def arrow_iterator( e ):
	    e = e.expand()
	    if e.operator() == plus:
		for t in e.operands(): yield t
	    else:
		yield e
	return BoxModel( DiGraph(
		[ (v,w,ee) for v,w,e in self._flow_graph.edge_iterator() for ee in arrow_iterator(e) ],
		pos = self._flow_graph._pos,
		multiedges=True
	    ),
	    self._vars
	)
    def aggregate_compartments( self, compartment_aggregation=default_compartment_aggregation,
	    param_namer_after=lambda *x:x,
	    vertex_namer_after=default_vertex_namer ):
        aggregate = {}
        for vt in self._graph.vertex_iterator():
            aggregate.setdefault( compartment_aggregation( vt.operands() ), [] ).append( vt.operands() )
        ## aggregate is { new_tuple: [old tuples], ... }
        print 'aggregate:', aggregate
        flow_sums = {}
        for v in self._graph.vertex_iterator():
	    av = bm_state( *compartment_aggregation( v.operands() ) )
	    if av not in flow_sums: flow_sums[av] = {}
	    for _,w,e in self._graph.outgoing_edge_iterator(v):
		aw = bm_state( *compartment_aggregation( w.operands() ) )
	        flow_sums[av].setdefault( aw, SR(0) )
		es = e.substitute_function( bm_param, param_namer_after ).substitute_function( bm_state, self._vertex_namer )
		print 'substitute:', e, '|||', es
	        flow_sums[av][aw] += es
	## flow_sums[av][aw] is sum of all transitions from
	## (aggregated tuple) av to aw
	## transitions are in terms of old vertex names and new param names

        ## now do substitutions to transform the transition sums
        agg_eqns, agg_symbols = [], []
        agg_subs = dynamicalsystems.Bindings()
        for newt,oldts in aggregate.items():
            #print 'will combine', sum( self._vertex_namer(*oldt) for oldt in oldts ), '==', vertex_namer_after(*newt)
	    eqn = self._vertex_namer(*oldts[0]) == vertex_namer_after(*newt) - sum( self._vertex_namer(*oldt) for oldt in oldts[1:] )
	    if eqn.lhs() != eqn.rhs():
                agg_symbols.append( self._vertex_namer(*oldts[0]) )
                agg_eqns.append( eqn )
        agg_graph_dict = {}
        for av, ve in flow_sums.iteritems():
	    vn = av.substitute_function( bm_state, vertex_namer_after )
            agg_graph_dict[vn] = {}
            for aw, e in ve.iteritems():
		wn = aw.substitute_function( bm_state, vertex_namer_after )
    	        sym = SR.symbol()
    	        print e
    	        solns = solve( [ sym == e ] + agg_eqns, sym, *agg_symbols, solution_dict=True )
    	        print 'solve', [ sym == e ] + agg_eqns, ',', [sym] + agg_symbols, '\n  ', solns
    	        if len(solns) == 1:
    	            #print '  ', maxima(sym), [str(k) == str(sym) for k in solns[0].keys()]
    	            el = [ex for k,ex in solns[0].items() if str(k) == str(sym)]
    	            print '==>', el[0]
    	            agg_graph_dict[vn][wn] = el[0]
		    # TODO: separate transformed sum into multiple arrows
    	        else:
    	            raise RuntimeError, 'Could not simplify expression ' + str(e) + ':' + str(solns)
	print 'agg_graph_dict', agg_graph_dict
        #self._vc_eqns = vc_eqns
	## make list of transformed variables
	## they are in those dicts, but we want the order
        agg_vars = []
	def xform_state( *t ):
	    s = compartment_aggregation( t )
	    return vertex_namer_after( *s )
        for v in self._var_tuples:
	    av = v.substitute_function( bm_state, xform_state )
	    if av not in agg_vars: agg_vars.append(av)
	print 'agg_vars', agg_vars
        ## position the aggregates by matching them to a subset of original
	## compartments
	apos = {}
	for t,p in self._graph.get_pos().iteritems():
	    at = t.substitute_function( bm_state, xform_state )
	    if at not in apos: apos[at] = p
	print 'apos', apos
	## The transformation produces a flow_graph only, not a structured
	## representation
        return boxmodel.BoxModel( DiGraph( agg_graph_dict, pos=apos ), agg_vars )
    def add_transitions( self, trs ):
	# it's an immutable object, so this operation
	# returns a new BoxModel.  trs is a list of (source,target,rate)
	# tuples suitable for adding to self._graph (rather than _flow_graph).
	fg = deepcopy(self._flow_graph)
	bm_to_vars = lambda e: e.substitute_function( bm_state, self._vertex_namer).substitute_function( bm_param, self._param_namer )
	fg.add_edges( [ (bm_to_vars(v), bm_to_vars(w), bm_to_vars(e)) for v,w,e in trs ] )
	return boxmodel.BoxModel(
	    fg,
	    vars = self._vars,
	    bindings = self._bindings
        )

class BoxModelProduct(CompositeBoxModel):
    def __init__(
	    self,
	    *models,
	    **kwargs
	):
	self._models = models
	compartment_renaming =  kwargs.pop( 'compartment_renaming', default_compartment_renaming )
	vertex_namer =          kwargs.pop( 'vertex_namer', default_vertex_namer )
	param_relabeling =      kwargs.pop( 'param_relabeling', default_param_relabeling )
	edge_generator =        kwargs.pop( 'edge_generator', default_edge_generator )
	single_edge_generator = kwargs.pop( 'single_edge_generator', None )
	compartment_aggregation = kwargs.pop( 'compartment_aggregation',
	    lambda x:x )
	vertex_positioner =     kwargs.pop( 'vertex_positioner', default_vertex_positioner )
	unary_operation =       kwargs.pop( 'unary_operation', default_sop )
	binary_operation =      kwargs.pop( 'binary_operation', default_bop )
	inclusions =            kwargs.pop( 'inclusions', tuple_inclusions )
	seed_set =              kwargs.pop( 'seed_set', None )
	if kwargs: raise TypeError, "Unknown named arguments to BoxModelProduct: %s" % str(kwargs)

	edges = list( edge_generator(
	    models,
	    vertex_namer,
	    param_relabeling,
	    compartment_renaming,
	    single_edge_generator=single_edge_generator,
	    unary_operation=unary_operation,
	    binary_operation=binary_operation,
	    inclusions=inclusions,
	    seed_set=seed_set
	) )
	print 'edges for product graph:', edges
	graph = DiGraph( edges, multiedges=True )

	# graphical positions of graph vertices
	graph.set_pos( vertex_positioner( graph, models ) )

	from collections import OrderedDict
	vars_d = OrderedDict( (v,None) for v,w,e in edges )
	vars_d.update( (w,None) for v,w,e in edges )
	super(BoxModelProduct,self).__init__(
	    graph, vars_d.keys(), vertex_namer
	)

	self._inclusion_tuples = {}
	for vbm in self._graph.vertex_iterator():
	    vs = vbm.operands()
	    for v in vs:
		if not v.is_numeric():
	            self._inclusion_tuples.setdefault(v, []).append( vs )

	#print self._inclusion_tuples
	self._inclusion_variables = {
	    k:[vertex_namer(*v) for v in vl]
	    for k,vl in self._inclusion_tuples.iteritems()
	}
	for k,vl in self._inclusion_variables.iteritems():
	    self._bindings[k] = sum( vl )

	# are vertices from product of graphs?
	representative_tuple = self._graph.vertex_iterator().next().operands()
	if len( representative_tuple ) == len( models ) and all( v in m._vars for v,m in zip( representative_tuple, models ) ):
	    # make list of variables, in order, by taking product
            import itertools
	    varset = set()
	    self._vars = []
	    self._tuples = []
	    for vs in itertools.product( *(m._vars for m in models) ):
	        t = compartment_renaming( *vs )
	        v = vertex_namer( *t )
	        if v not in varset:
		    varset.add(v)
		    self._vars.append(v)
		    self._tuples.append( bm_state( *t ) )
	    print 'made tuples:', self._tuples
	else:
	    # no - the edge generator gave us some other set of vertices
	    self._tuples = [ bm_state(*t) for t in sorted( t.operands() for t in self._graph.vertices()) ]
	    print 'sorted tuples:', self._tuples
	    self._vars = [ vertex_namer(*t.operands()) for t in self._tuples ]

	# now generate all the crossed parameters
	# TODO: do this right
	self._parameters = reduce( lambda x,y: set(x).union(y), (r.variables() for f,t,r in self._flow_graph.edges()), set() ).difference( self._vars )
	#print 'parameters:', self._parameters

	self._vertex_namer = vertex_namer
	self._param_relabeling = param_relabeling

def default_sop_strong( s_tuple, iset, eis ):
    # return set of t_tuples
    print 'sop', s_tuple, eis
    tl = list(s_tuple)
    for (v,w,r),i in eis: tl[i] = w
    return Set( [ tuple(tl) ] )
def default_bop_strong( s_tuple, iset, c_tuple, i_set, eis ):
    # return set of t_tuples
    tl = list(s_tuple)
    for (v,w,r),i in eis: tl[i] = w
    return Set( [ tuple(tl) ] )

# this thing is called once for each set of
# component edges, given a set of product vertices.  It loops
# over those vertices and generates all the product edges involving
# those vertices that are versions of that combination of component
# edges.
# TODO: much duplication with the regular single_edge_generator.
# maybe merge
def default_strong_edge_bundle_generator(
	eis, models,
	seed_set, vertex_namer, param_relabeling, compartment_renaming,
	old_set=Set(), cross_interactions=True,
	unary_operation=default_sop_strong, binary_operation=default_bop_strong,
	inclusions=tuple_inclusions
    ):
    if len(eis) == 0: return
    print 'old set', old_set, '/ seed set', seed_set
    # produce all product edges made from these component edges
    # what is the rate of a transition that combines some set of
    # component transitions?
    # who cares? we assume this will only be used to combine
    # instances of the same transition, in a power of a single
    # model.
    if len( Set( (r for ((w,v,r),i) in eis) ) ) != 1:
        raise RuntimeError, 'overwhelming rate construction problem involving transitions '+str(eis)
    # else: do the replacement in the one rate
    (source,target,rate),i = eis[0]
    # list the compartments involved in the transition
    rate_comps = [ x for x in rate.variables() if x in models[i]._vars ]
    rate_params = set( rate.variables() ) - set( rate_comps )
    # we can handle linear or bilinear transitions
    if rate_comps == [source]:
	for V in seed_set:
	    if all( i in inclusions( v, V ) for (v,w,r),i in eis ):
		repl = { v: bm_state( *compartment_renaming( *V ) ) }
	        for W in unary_operation( V, [i for e,i in eis], eis ):
		    print W
		    # TODO: param_namer
		    repl.update( { p: param_relabeling( p, V, iota, W ) for p in rate_params } )
		    yield ( V, W, r.subs( repl ) )
    elif len(rate_comps) == 2 and source in rate_comps:
	catalyst, = set(rate_comps) - set([source])
        import itertools
	for V,C in itertools.chain( itertools.product(seed_set, old_set), itertools.product(old_set + seed_set, seed_set) ):
	    #print 'consider', V, '+', C, 'at', eis
	    # does V have the relevant compartments?
	    # only consider the one inclusion in V, the one given by eis
	    if not all( i in inclusions( v, V ) for (v,w,r),i in eis ):
		#print V, 'does not have the inclusions in', eis
	        continue
	    iota = [ i for e,i in eis ]
	    # in general case, it's all the ways to include the 
	    # rate's catalyst compartment in C
	    # in simple case, those are the inclusions for C as well
	    if cross_interactions:
		c_inclusions = Arrangements( inclusions( catalyst, C ), len(eis) )
		#print 'inclusions of', eis, 'in', C, ':', list( c_inclusions )
	    else:
	        c_inclusions = Set( tuple( i for e,i in eis ) ) if all( i in inclusions( catalyst, C ) for e,i in eis ) else Set()
	        #print catalyst, 'in C:', list( c_inclusions )
	    for iota_ in c_inclusions:
                #print 'do edges for', V, iota, C, iota_
    	        repl = {
    		    source: bm_state( *compartment_renaming( *V ) ),
    		    catalyst: bm_state( *compartment_renaming( *C ) )
    	        }
    	        ts = binary_operation( V, list( iota ), C, list( iota_ ), eis )
		print 'bop returns', ts
		# TODO: check if in-compartment interaction is right
    	        for W in ts:
    	            repl.update( { p: param_relabeling( p, V, iota, C, iota_, W ) for p in rate_params } )
    	            #print V, iota, C, iota_, ':', compartment_renaming( *W ), rate.subs( repl )
    	            yield ( V, W, rate.subs( repl ) )
    	            if V == C:
    		        # TODO: is this within-class case right in general?
    	                repl.update( { p: param_relabeling( p, V, iota, iota_, W ) for p in rate_params } )
    	                #print V, iota, iota_, ':', W, rate.subs( repl ) / bm_state(*C)
    	                yield( V, W, rate.subs( repl ) / bm_state(*compartment_renaming(*C)) )
    else: # wrong variables in rate
	raise BoxModelProductException, "Don't understand rate {0}".format(rate)

def strong_edge_generator(
	models,
	vertex_namer, param_relabeling, compartment_renaming,
	single_edge_generator=None,
	seed_set=None, cross_interactions=True,
	unary_operation=default_sop, binary_operation=default_bop,
	inclusions=tuple_inclusions
    ):
    if single_edge_generator is None:
	single_edge_generator = default_strong_edge_bundle_generator
    # TODO: hacky, fix
    if (
	(param_relabeling is default_param_relabeling) and
	cross_interactions and
	any( not Set(m1._vars).intersection( Set(m2._vars) ).is_empty() for m1 in models for m2 in models if m2 is not m1 )
    ):
	param_relabeling = full_param_relabeling
    import itertools
    if seed_set is None:
	seed_set = Set( itertools.product( *(m._vars for m in models) ) )
    edges = []
    old_vertices = Set()
    while not seed_set.is_empty():
        # for each edge of each model, we generate a set of derived edges
        # in the product model
        new_edges = list( itertools.chain( *[
	    # call this thing once for each edge in each model, and
	    # in fact more generally once for each tuple ( (e1,i1), (ex,ix), ... )
	    # where ei is an edge in model i for some set of the models
	    single_edge_generator(
	        eis, models, seed_set,
	        vertex_namer, param_relabeling, compartment_renaming,
		old_set=old_vertices,
	        unary_operation=unary_operation,
		binary_operation=binary_operation,
		cross_interactions=cross_interactions,
		inclusions=inclusions
	    )
	    for iset in Subsets( Set( range(len(models)) ) )
	    for eis in itertools.product( *([(e,i) for e in models[i]._graph.edge_iterator()] for i in iset) )
        ] ) )
	edges += new_edges
	# the edges returned may involve vertices we didn't anticipate
	# so we expand our set of vertices dynamically
	# in which case, we have to do the generation again to include
	# transitions involving the new vertices
        old_vertices += seed_set
        seed_set = Set( v for v,w,r in new_edges ).union( Set( w for v,w,r in new_edges ) ) - old_vertices
	if len(old_vertices) + len(seed_set) > 100:
	    raise RuntimeError, 'Recursion produces too many compartments'
    return [ ( bm_state( *compartment_renaming( *V ) ), bm_state( *compartment_renaming( *W ) ), r ) for V,W,r in edges ]

def cross( *models ):
    return BoxModelProduct( *models )

def union_edge_generator( models, vertex_namer, param_namer, compartment_renaming ):
    import itertools
    return itertools.chain( *(m._graph.edge_iterator() for m in models) )

def union_positioner( graph, models, compartment_renaming ):
    return {
	v:(x,-i)
	for i,pos in enumerate( m._graph.get_pos() for m in models )
	for v,(x,y) in pos.iteritems()
    }

## union is not a product, but it's easy to implement as one
## it just combines the graphs "side by side"
## (except if they share vertices and possibly edges, they'll be combined)
## note if we didn't combine those it would be direct sum rather than union
def union( *models ):
    """union of the models' vertex and edge sets"""
    return BoxModelProduct( *models,
	vertex_namer = boxmodelproduct.x_namer,
	edge_generator = union_edge_generator,
	vertex_positioner = union_positioner
    )

## TODO: rewrite using new strong_edge_generator with bop
def strong_product( *models, **kwargs ):
    compartment_renaming =  kwargs.pop( 'compartment_renaming',  default_compartment_renaming )
    vertex_namer =    kwargs.pop( 'vertex_namer',    default_vertex_namer )
    param_namer =     kwargs.pop( 'param_namer',     default_vertex_namer )
    vertex_positioner = kwargs.pop( 'vertex_positioner', default_vertex_positioner )
    if kwargs: raise TypeError, "Unknown named arguments to BoxModelProduct: %s" % str(kwargs)
    return BoxModelProduct( *models,
	edge_generator = strong_edge_generator,
	vertex_namer = vertex_namer,
	compartment_renaming = compartment_renaming,
	param_namer = param_namer,
	vertex_positioner = vertex_positioner
    )

def power( model, i, compartment_renaming=lambda *x:x, param_relabeling=default_param_relabeling ):
    return BoxModelProduct(
	*([model] * i),
	vertex_namer = x_namer,
	compartment_renaming=compartment_renaming,
	param_relabeling=param_relabeling
    )

def write_product_formula( M1, M2, M12, tfnm, op=r'\times', size1=(3,1), size2=(1,4), size12=(4,4) ):
    # do I need to do this before opening the file, to get preamble right?
    Mtz = M1.tikz_boxes( figsize=size1, inline=True )
    import latex_output
    ltx = latex_output.latex_output( tfnm )
    ltx.write( '$\\raisebox{-0.5\\height}{\\hbox{', Mtz, '}}', op, '\\raisebox{-0.5\\height}{\\hbox{', M2.transpose_graph().tikz_boxes( figsize=size2, inline=True ), '}} = \\raisebox{-0.5\\height}{\\hbox{', M12.tikz_boxes( figsize=size12, inline=True ), '}}$' )
    ltx.close()

</source-file>

<source-file filename=upstream.mk>
# Makefile to connect the Sage code here with the code in SageDynamics

# the three upstream projects are all bundled into one git repo
export SageUtils            = $(realpath $(SageDynamicsRepo)/SageUtils)
export SageDynamics         = $(realpath $(SageDynamicsRepo)/SageDynamics)
export SageAdaptiveDynamics = $(realpath $(SageDynamicsRepo)/SageAdaptiveDynamics)

# When we need something from the upstream projects, make it there
$(SageDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageDynamics) $*

$(SageAdaptiveDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageAdaptiveDynamics) $*

# The good makefile stuff is upstream, just reuse it
-include $(SageUtils)/sage.mk
-include $(SageUtils)/step.mk
</source-file>

<!-- this is sage's src/sage/graph/graph_latex.py with the patch
  from the 't/18046/graphs_with_multiedges_and_latex' branch, which
  provides multigraph support in the tikz directed graph output feature.
  My BoxModel class uses this patched version of the GraphLatex class,
  because BoxModelProduct data tends to need it, because it often has
  multiple transitions between the same two compartments.
-->
<source-file filename=graph_latex_patched.py>
r"""
LaTeX options for graphs

This module provides a class to hold, manipulate and employ various
options for rendering a graph in LaTeX, in addition to providing
the code that actually generates a LaTeX representation
of a (combinatorial) graph.

AUTHORS:

- Rob Beezer (2009-05-20): :class:`~sage.graphs.graph_latex.GraphLatex` class
- Fidel Barerra Cruz (2009-05-20): ``tkz-graph`` commands to render a graph
- Nicolas M. Thiery (2010-02): dot2tex/graphviz interface
- Rob Beezer (2010-05-29): Extended range of ``tkz-graph`` options
- Jacob Laas (2015-03-31): added ability to render tkz-graph graphs with multiedges

LaTeX Versions of Graphs
-------------------------------------

.. image:: ../../media/heawood-graph-latex.png
:align: center

Many mathematical objects in Sage have LaTeX representations, and graphs are no exception.  For a graph ``g``, the command ``view(g)``, issued at the Sage command line or in the notebook, will create a graphic version of ``g``.  Similarly, ``latex(g)`` will return a (long) string that is a representation of the graph in LaTeX.  Other ways of employing LaTeX in Sage, such as ``%latex`` in a notebook cell, or the Typeset checkbox in the notebook, will handle ``g`` appropriately.

Support through the ``tkz-graph`` package is by Alain Matthes, the author of ``tkz-graph``, whose work can be found at his `Altermundus.com <http://altermundus.com/>`_ site.

The range of possible options for customizing the appearance of a graph are carefully documented at :meth:`sage.graphs.graph_latex.GraphLatex.set_option`.  As a broad overview, the following options are supported:

- Pre-built Styles:  the pre-built styles of the tkz-graph package provide nice drawings quickly
- Dimensions: can be specified in natural units, then uniformly scaled after design work
- Vertex Colors: the perimeter and fill color for vertices can be specified, including on a per-vertex basis
- Vertex Shapes: may be circles, shaded spheres, rectangles or diamonds, including on a per-vertex basis
- Vertex Sizes: may be specified as minimums, and will automatically sized to contain vertex labels, including on a per-vertex basis
- Vertex Labels: can use latex formatting, and may have their colors specified, including on a per-vertex basis
- Vertex Label Placement: can be interior to the vertex, or external at a configurable location
- Edge Colors: a solid color with or without a second color down the middle, on a per-edge basis
- Edge Thickness: can be set, including on a per-edge basis
- Edge Labels: can use latex formatting, and may have their colors specified, including on a per-edge basis
- Edge Label Placement: can be to the left, right, above, below, inline, and then sloped or horizontal
- Digraph Edges: are slightly curved, with arrowheads
- Loops: may be specified by their size, and with a direction equaling one of the four compass points

To use LaTeX in Sage you of course need a working TeX installation and it will work best if you have the ``dvipng`` and ``convert`` utilities.  For graphs you need the ``tkz-graph.sty`` and ``tkz-berge.sty`` style files of the  tkz-graph package.  TeX, dvipng, and convert should be widely available through package managers or installers.  You may need to install the tkz-graph style files in the appropriate locations, a task beyond the scope of this introduction.  Primary locations for these programs are:

- TeX: http://ctan.org/
- dvipng: http://sourceforge.net/projects/dvipng/
- convert: http://www.imagemagick.org (the ImageMagick suite)
- tkz-graph: http://altermundus.com/pages/tkz/

Customizing the output is accomplished in several ways.  Suppose ``g`` is a graph, then ``g.set_latex_options()`` can be used to efficiently set or modify various options.  Setting individual options, or querying options, can be accomplished by first using a command like ``opts = g.latex_options()`` to obtain a :class:`sage.graphs.graph_latex.GraphLatex` object which has several methods to set and retrieve options.

Here is a minimal session demonstrating how to use these features. The following setup should work in the notebook or at the command-line. ::

sage: H = graphs.HeawoodGraph()
sage: H.set_latex_options(
...   graphic_size=(5,5),
...   vertex_size=0.2,
...   edge_thickness=0.04,
...   edge_color='green',
...   vertex_color='green',
...   vertex_label_color='red'
...   )

At this point, ``view(H)`` should call ``pdflatex`` to process the string created by ``latex(H)`` and then display the resulting graphic.

To use this image in a LaTeX document, you could of course just copy and save the resulting graphic.  However, the ``latex()`` command will produce the underlying LaTeX code, which can be incorporated into a standalone LaTeX document.  ::

sage: from sage.graphs.graph_latex import check_tkz_graph
sage: check_tkz_graph()  # random - depends on TeX installation
sage: latex(H)
\begin{tikzpicture}
%
\useasboundingbox (0,0) rectangle (5.0cm,5.0cm);
%
\definecolor{cv0}{rgb}{0.0,0.502,0.0}
\definecolor{cfv0}{rgb}{1.0,1.0,1.0}
\definecolor{clv0}{rgb}{1.0,0.0,0.0}
\definecolor{cv1}{rgb}{0.0,0.502,0.0}
\definecolor{cfv1}{rgb}{1.0,1.0,1.0}
\definecolor{clv1}{rgb}{1.0,0.0,0.0}
\definecolor{cv2}{rgb}{0.0,0.502,0.0}
\definecolor{cfv2}{rgb}{1.0,1.0,1.0}
\definecolor{clv2}{rgb}{1.0,0.0,0.0}
\definecolor{cv3}{rgb}{0.0,0.502,0.0}
\definecolor{cfv3}{rgb}{1.0,1.0,1.0}
\definecolor{clv3}{rgb}{1.0,0.0,0.0}
\definecolor{cv4}{rgb}{0.0,0.502,0.0}
\definecolor{cfv4}{rgb}{1.0,1.0,1.0}
\definecolor{clv4}{rgb}{1.0,0.0,0.0}
\definecolor{cv5}{rgb}{0.0,0.502,0.0}
\definecolor{cfv5}{rgb}{1.0,1.0,1.0}
\definecolor{clv5}{rgb}{1.0,0.0,0.0}
\definecolor{cv6}{rgb}{0.0,0.502,0.0}
\definecolor{cfv6}{rgb}{1.0,1.0,1.0}
\definecolor{clv6}{rgb}{1.0,0.0,0.0}
\definecolor{cv7}{rgb}{0.0,0.502,0.0}
\definecolor{cfv7}{rgb}{1.0,1.0,1.0}
\definecolor{clv7}{rgb}{1.0,0.0,0.0}
\definecolor{cv8}{rgb}{0.0,0.502,0.0}
\definecolor{cfv8}{rgb}{1.0,1.0,1.0}
\definecolor{clv8}{rgb}{1.0,0.0,0.0}
\definecolor{cv9}{rgb}{0.0,0.502,0.0}
\definecolor{cfv9}{rgb}{1.0,1.0,1.0}
\definecolor{clv9}{rgb}{1.0,0.0,0.0}
\definecolor{cv10}{rgb}{0.0,0.502,0.0}
\definecolor{cfv10}{rgb}{1.0,1.0,1.0}
\definecolor{clv10}{rgb}{1.0,0.0,0.0}
\definecolor{cv11}{rgb}{0.0,0.502,0.0}
\definecolor{cfv11}{rgb}{1.0,1.0,1.0}
\definecolor{clv11}{rgb}{1.0,0.0,0.0}
\definecolor{cv12}{rgb}{0.0,0.502,0.0}
\definecolor{cfv12}{rgb}{1.0,1.0,1.0}
\definecolor{clv12}{rgb}{1.0,0.0,0.0}
\definecolor{cv13}{rgb}{0.0,0.502,0.0}
\definecolor{cfv13}{rgb}{1.0,1.0,1.0}
\definecolor{clv13}{rgb}{1.0,0.0,0.0}
\definecolor{cv0v1}{rgb}{0.0,0.502,0.0}
\definecolor{cv0v5}{rgb}{0.0,0.502,0.0}
\definecolor{cv0v13}{rgb}{0.0,0.502,0.0}
\definecolor{cv1v2}{rgb}{0.0,0.502,0.0}
\definecolor{cv1v10}{rgb}{0.0,0.502,0.0}
\definecolor{cv2v3}{rgb}{0.0,0.502,0.0}
\definecolor{cv2v7}{rgb}{0.0,0.502,0.0}
\definecolor{cv3v4}{rgb}{0.0,0.502,0.0}
\definecolor{cv3v12}{rgb}{0.0,0.502,0.0}
\definecolor{cv4v5}{rgb}{0.0,0.502,0.0}
\definecolor{cv4v9}{rgb}{0.0,0.502,0.0}
\definecolor{cv5v6}{rgb}{0.0,0.502,0.0}
\definecolor{cv6v7}{rgb}{0.0,0.502,0.0}
\definecolor{cv6v11}{rgb}{0.0,0.502,0.0}
\definecolor{cv7v8}{rgb}{0.0,0.502,0.0}
\definecolor{cv8v9}{rgb}{0.0,0.502,0.0}
\definecolor{cv8v13}{rgb}{0.0,0.502,0.0}
\definecolor{cv9v10}{rgb}{0.0,0.502,0.0}
\definecolor{cv10v11}{rgb}{0.0,0.502,0.0}
\definecolor{cv11v12}{rgb}{0.0,0.502,0.0}
\definecolor{cv12v13}{rgb}{0.0,0.502,0.0}
%
\Vertex[style={minimum size=0.2cm,draw=cv0,fill=cfv0,text=clv0,shape=circle},LabelOut=false,L=\hbox{$0$},x=2.5cm,y=5.0cm]{v0}
\Vertex[style={minimum size=0.2cm,draw=cv1,fill=cfv1,text=clv1,shape=circle},LabelOut=false,L=\hbox{$1$},x=1.3874cm,y=4.7524cm]{v1}
\Vertex[style={minimum size=0.2cm,draw=cv2,fill=cfv2,text=clv2,shape=circle},LabelOut=false,L=\hbox{$2$},x=0.4952cm,y=4.0587cm]{v2}
\Vertex[style={minimum size=0.2cm,draw=cv3,fill=cfv3,text=clv3,shape=circle},LabelOut=false,L=\hbox{$3$},x=0.0cm,y=3.0563cm]{v3}
\Vertex[style={minimum size=0.2cm,draw=cv4,fill=cfv4,text=clv4,shape=circle},LabelOut=false,L=\hbox{$4$},x=0.0cm,y=1.9437cm]{v4}
\Vertex[style={minimum size=0.2cm,draw=cv5,fill=cfv5,text=clv5,shape=circle},LabelOut=false,L=\hbox{$5$},x=0.4952cm,y=0.9413cm]{v5}
\Vertex[style={minimum size=0.2cm,draw=cv6,fill=cfv6,text=clv6,shape=circle},LabelOut=false,L=\hbox{$6$},x=1.3874cm,y=0.2476cm]{v6}
\Vertex[style={minimum size=0.2cm,draw=cv7,fill=cfv7,text=clv7,shape=circle},LabelOut=false,L=\hbox{$7$},x=2.5cm,y=0.0cm]{v7}
\Vertex[style={minimum size=0.2cm,draw=cv8,fill=cfv8,text=clv8,shape=circle},LabelOut=false,L=\hbox{$8$},x=3.6126cm,y=0.2476cm]{v8}
\Vertex[style={minimum size=0.2cm,draw=cv9,fill=cfv9,text=clv9,shape=circle},LabelOut=false,L=\hbox{$9$},x=4.5048cm,y=0.9413cm]{v9}
\Vertex[style={minimum size=0.2cm,draw=cv10,fill=cfv10,text=clv10,shape=circle},LabelOut=false,L=\hbox{$10$},x=5.0cm,y=1.9437cm]{v10}
\Vertex[style={minimum size=0.2cm,draw=cv11,fill=cfv11,text=clv11,shape=circle},LabelOut=false,L=\hbox{$11$},x=5.0cm,y=3.0563cm]{v11}
\Vertex[style={minimum size=0.2cm,draw=cv12,fill=cfv12,text=clv12,shape=circle},LabelOut=false,L=\hbox{$12$},x=4.5048cm,y=4.0587cm]{v12}
\Vertex[style={minimum size=0.2cm,draw=cv13,fill=cfv13,text=clv13,shape=circle},LabelOut=false,L=\hbox{$13$},x=3.6126cm,y=4.7524cm]{v13}
%
\Edge[lw=0.04cm,style={color=cv0v1,},](v0)(v1)
\Edge[lw=0.04cm,style={color=cv0v5,},](v0)(v5)
\Edge[lw=0.04cm,style={color=cv0v13,},](v0)(v13)
\Edge[lw=0.04cm,style={color=cv1v2,},](v1)(v2)
\Edge[lw=0.04cm,style={color=cv1v10,},](v1)(v10)
\Edge[lw=0.04cm,style={color=cv2v3,},](v2)(v3)
\Edge[lw=0.04cm,style={color=cv2v7,},](v2)(v7)
\Edge[lw=0.04cm,style={color=cv3v4,},](v3)(v4)
\Edge[lw=0.04cm,style={color=cv3v12,},](v3)(v12)
\Edge[lw=0.04cm,style={color=cv4v5,},](v4)(v5)
\Edge[lw=0.04cm,style={color=cv4v9,},](v4)(v9)
\Edge[lw=0.04cm,style={color=cv5v6,},](v5)(v6)
\Edge[lw=0.04cm,style={color=cv6v7,},](v6)(v7)
\Edge[lw=0.04cm,style={color=cv6v11,},](v6)(v11)
\Edge[lw=0.04cm,style={color=cv7v8,},](v7)(v8)
\Edge[lw=0.04cm,style={color=cv8v9,},](v8)(v9)
\Edge[lw=0.04cm,style={color=cv8v13,},](v8)(v13)
\Edge[lw=0.04cm,style={color=cv9v10,},](v9)(v10)
\Edge[lw=0.04cm,style={color=cv10v11,},](v10)(v11)
\Edge[lw=0.04cm,style={color=cv11v12,},](v11)(v12)
\Edge[lw=0.04cm,style={color=cv12v13,},](v12)(v13)
%
\end{tikzpicture}

EXAMPLES:

This example illustrates switching between the built-in styles when using the tkz_graph format.  ::

sage: g = graphs.PetersenGraph()
sage: g.set_latex_options(tkz_style = 'Classic')
sage: from sage.graphs.graph_latex import check_tkz_graph
sage: check_tkz_graph()  # random - depends on TeX installation
sage: latex(g)
\begin{tikzpicture}
...
\GraphInit[vstyle=Classic]
...
\end{tikzpicture}
sage: opts = g.latex_options()
sage: opts
LaTeX options for Petersen graph: {'tkz_style': 'Classic'}
sage: g.set_latex_options(tkz_style = 'Art')
sage: opts.get_option('tkz_style')
'Art'
sage: opts
LaTeX options for Petersen graph: {'tkz_style': 'Art'}
sage: latex(g)
\begin{tikzpicture}
...
\GraphInit[vstyle=Art]
...
\end{tikzpicture}

This example illustrates using the optional dot2tex module::

sage: g = graphs.PetersenGraph()
sage: g.set_latex_options(format='dot2tex',prog='neato') # optional - dot2tex
sage: from sage.graphs.graph_latex import check_tkz_graph
sage: check_tkz_graph()  # random - depends on TeX installation
sage: latex(g) # optional - dot2tex
\begin{tikzpicture}[>=latex,line join=bevel,]
...
\end{tikzpicture}

Among other things, this supports the flexible ``edge_options`` option
(see :meth:`sage.graphs.generic_graph.GenericGraph.graphviz_string`);
here we color in red all edges touching the vertex ``0``::

sage: g = graphs.PetersenGraph()
sage: g.set_latex_options(format="dot2tex", edge_options = lambda (u,v,label): {"color": "red"} if u==0 else {})
sage: latex(g) # optional - dot2tex
\begin{tikzpicture}[>=latex,line join=bevel,]
...
\end{tikzpicture}


TEST:

This graph will look horrible, but it illustrates (and tests) a
great variety of the possible options available through Sage's
interface to the ``tkz-graph`` package.  So it is worth viewing
this in the notebook to see the effects of various defaults and
choices. ::

sage: var('x y u w')
(x, y, u, w)
sage: G = Graph(loops=True)
sage: for i in range(5):
...      for j in range(i+1, 5):
...           G.add_edge((i, j), label=(x^i*y^j).expand())
sage: G.add_edge((0,0), label=sin(u))
sage: G.add_edge((4,4), label=w^5)
sage: G.set_pos(G.layout_circular())
sage: G.set_latex_options(
...   units='in',
...   graphic_size=(8,8),
...   margins=(1,2,2,1),
...   scale=0.5,
...   vertex_color='0.8',
...   vertex_colors={1:'aqua', 3:'y', 4:'#0000FF'},
...   vertex_fill_color='blue',
...   vertex_fill_colors={1:'green', 3:'b', 4:'#FF00FF'},
...   vertex_label_color='brown',
...   vertex_label_colors={0:'g',1:'purple',2:'#007F00'},
...   vertex_shape='diamond',
...   vertex_shapes={1:'rectangle', 2:'sphere', 3:'sphere', 4:'circle'},
...   vertex_size=0.3,
...   vertex_sizes={0:1.0, 2:0.3, 4:1.0},
...   vertex_label_placements = {2:(0.6, 180), 4:(0,45)},
...   edge_color='purple',
...   edge_colors={(0,2):'g',(3,4):'red'},
...   edge_fills=True,
...   edge_fill_color='green',
...   edge_label_colors={(2,3):'y',(0,4):'blue'},
...   edge_thickness=0.05,
...   edge_thicknesses={(3,4):0.2, (0,4):0.02},
...   edge_labels=True,
...   edge_label_sloped=True,
...   edge_label_slopes={(0,3):False, (2,4):False},
...   edge_label_placement=0.50,
...   edge_label_placements={(0,4):'above', (2,3):'left', (0,0):'above', (4,4):'below'},
...   loop_placement=(2.0, 'NO'),
...   loop_placements={4:(8.0, 'EA')}
...   )
sage: from sage.graphs.graph_latex import check_tkz_graph
sage: check_tkz_graph()  # random - depends on TeX installation
sage: print latex(G)
\begin{tikzpicture}
%
\useasboundingbox (0,0) rectangle (4.0in,4.0in);
%
\definecolor{cv0}{rgb}{0.8,0.8,0.8}
\definecolor{cfv0}{rgb}{0.0,0.0,1.0}
\definecolor{clv0}{rgb}{0.0,0.5,0.0}
\definecolor{cv1}{rgb}{0.0,1.0,1.0}
\definecolor{cfv1}{rgb}{0.0,0.502,0.0}
\definecolor{clv1}{rgb}{0.502,0.0,0.502}
\definecolor{cv2}{rgb}{0.8,0.8,0.8}
\definecolor{cfv2}{rgb}{0.0,0.0,1.0}
\definecolor{clv2}{rgb}{0.0,0.498,0.0}
\definecolor{cv3}{rgb}{0.75,0.75,0.0}
\definecolor{cfv3}{rgb}{0.0,0.0,1.0}
\definecolor{clv3}{rgb}{0.6471,0.1647,0.1647}
\definecolor{cv4}{rgb}{0.0,0.0,1.0}
\definecolor{cfv4}{rgb}{1.0,0.0,1.0}
\definecolor{clv4}{rgb}{0.6471,0.1647,0.1647}
\definecolor{cv0v0}{rgb}{0.502,0.0,0.502}
\definecolor{cfv0v0}{rgb}{0.0,0.502,0.0}
\definecolor{clv0v0}{rgb}{0.0,0.0,0.0}
\definecolor{cv0v1}{rgb}{0.502,0.0,0.502}
\definecolor{cfv0v1}{rgb}{0.0,0.502,0.0}
\definecolor{clv0v1}{rgb}{0.0,0.0,0.0}
\definecolor{cv0v2}{rgb}{0.0,0.5,0.0}
\definecolor{cfv0v2}{rgb}{0.0,0.502,0.0}
\definecolor{clv0v2}{rgb}{0.0,0.0,0.0}
\definecolor{cv0v3}{rgb}{0.502,0.0,0.502}
\definecolor{cfv0v3}{rgb}{0.0,0.502,0.0}
\definecolor{clv0v3}{rgb}{0.0,0.0,0.0}
\definecolor{cv0v4}{rgb}{0.502,0.0,0.502}
\definecolor{cfv0v4}{rgb}{0.0,0.502,0.0}
\definecolor{clv0v4}{rgb}{0.0,0.0,1.0}
\definecolor{cv1v2}{rgb}{0.502,0.0,0.502}
\definecolor{cfv1v2}{rgb}{0.0,0.502,0.0}
\definecolor{clv1v2}{rgb}{0.0,0.0,0.0}
\definecolor{cv1v3}{rgb}{0.502,0.0,0.502}
\definecolor{cfv1v3}{rgb}{0.0,0.502,0.0}
\definecolor{clv1v3}{rgb}{0.0,0.0,0.0}
\definecolor{cv1v4}{rgb}{0.502,0.0,0.502}
\definecolor{cfv1v4}{rgb}{0.0,0.502,0.0}
\definecolor{clv1v4}{rgb}{0.0,0.0,0.0}
\definecolor{cv2v3}{rgb}{0.502,0.0,0.502}
\definecolor{cfv2v3}{rgb}{0.0,0.502,0.0}
\definecolor{clv2v3}{rgb}{0.75,0.75,0.0}
\definecolor{cv2v4}{rgb}{0.502,0.0,0.502}
\definecolor{cfv2v4}{rgb}{0.0,0.502,0.0}
\definecolor{clv2v4}{rgb}{0.0,0.0,0.0}
\definecolor{cv3v4}{rgb}{1.0,0.0,0.0}
\definecolor{cfv3v4}{rgb}{0.0,0.502,0.0}
\definecolor{clv3v4}{rgb}{0.0,0.0,0.0}
\definecolor{cv4v4}{rgb}{0.502,0.0,0.502}
\definecolor{cfv4v4}{rgb}{0.0,0.502,0.0}
\definecolor{clv4v4}{rgb}{0.0,0.0,0.0}
%
\Vertex[style={minimum size=0.5in,draw=cv0,fill=cfv0,text=clv0,shape=diamond},LabelOut=false,L=\hbox{$0$},x=1.75in,y=3.0in]{v0}
\Vertex[style={minimum size=0.15in,draw=cv1,fill=cfv1,text=clv1,shape=rectangle},LabelOut=false,L=\hbox{$1$},x=0.5in,y=2.0451in]{v1}
\Vertex[style={minimum size=0.15in,draw=cv2,fill=cfv2,text=clv2,shape=circle,shading=ball,line width=0pt,ball color=cv2,},LabelOut=true,Ldist=0.3in,Lpos=180.0,L=\hbox{$2$},x=0.9775in,y=0.5in]{v2}
\Vertex[style={minimum size=0.15in,draw=cv3,fill=cfv3,text=clv3,shape=circle,shading=ball,line width=0pt,ball color=cv3,},LabelOut=false,L=\hbox{$3$},x=2.5225in,y=0.5in]{v3}
\Vertex[style={minimum size=0.5in,draw=cv4,fill=cfv4,text=clv4,shape=circle},LabelOut=true,Ldist=0.0in,Lpos=45.0,L=\hbox{$4$},x=3.0in,y=2.0451in]{v4}
%
\Loop[dist=1.0in,dir=NO,style={color=cv0v0,double=cfv0v0},labelstyle={sloped,above,text=clv0v0,},label=\hbox{$\sin\left(u\right)$},](v0)
\Edge[lw=0.025in,style={color=cv0v1,double=cfv0v1},labelstyle={sloped,pos=0.5,text=clv0v1,},label=\hbox{$y$},](v0)(v1)
\Edge[lw=0.025in,style={color=cv0v2,double=cfv0v2},labelstyle={sloped,pos=0.5,text=clv0v2,},label=\hbox{$y^{2}$},](v0)(v2)
\Edge[lw=0.025in,style={color=cv0v3,double=cfv0v3},labelstyle={pos=0.5,text=clv0v3,},label=\hbox{$y^{3}$},](v0)(v3)
\Edge[lw=0.01in,style={color=cv0v4,double=cfv0v4},labelstyle={sloped,above,text=clv0v4,},label=\hbox{$y^{4}$},](v0)(v4)
\Edge[lw=0.025in,style={color=cv1v2,double=cfv1v2},labelstyle={sloped,pos=0.5,text=clv1v2,},label=\hbox{$x y^{2}$},](v1)(v2)
\Edge[lw=0.025in,style={color=cv1v3,double=cfv1v3},labelstyle={sloped,pos=0.5,text=clv1v3,},label=\hbox{$x y^{3}$},](v1)(v3)
\Edge[lw=0.025in,style={color=cv1v4,double=cfv1v4},labelstyle={sloped,pos=0.5,text=clv1v4,},label=\hbox{$x y^{4}$},](v1)(v4)
\Edge[lw=0.025in,style={color=cv2v3,double=cfv2v3},labelstyle={sloped,left,text=clv2v3,},label=\hbox{$x^{2} y^{3}$},](v2)(v3)
\Edge[lw=0.025in,style={color=cv2v4,double=cfv2v4},labelstyle={pos=0.5,text=clv2v4,},label=\hbox{$x^{2} y^{4}$},](v2)(v4)
\Edge[lw=0.1in,style={color=cv3v4,double=cfv3v4},labelstyle={sloped,pos=0.5,text=clv3v4,},label=\hbox{$x^{3} y^{4}$},](v3)(v4)
\Loop[dist=4.0in,dir=EA,style={color=cv4v4,double=cfv4v4},labelstyle={sloped,below,text=clv4v4,},label=\hbox{$w^{5}$},](v4)
%
\end{tikzpicture}

GraphLatex class and functions
------------------------------
"""
#*****************************************************************************
#       Copyright (C) 2009 Robert Beezer <beezer@ups.edu>
#       Copyright (C) 2009 Fidel Barrera Cruz <fidel.barrera@gmail.com>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.structure.sage_object import SageObject
from sage.misc.cachefunc import cached_function
from sage.misc.latex import latex

def check_tkz_graph():
r"""
Checks if the proper LaTeX
packages for the ``tikzpicture`` environment are
installed in the user's environment, and issue
a warning otherwise.

The warning is only issued on the first call to this function. So
any doctest that illustrates the use of the tkz-graph packages
should call this once as having random output to exhaust the
warnings before testing output.

See also :meth:`sage.misc.latex.Latex.check_file`

TESTS::

sage: from sage.graphs.graph_latex import check_tkz_graph
sage: check_tkz_graph()  # random - depends on TeX installation
sage: check_tkz_graph()  # at least the second time, so no output
"""
latex.check_file("tikz.sty", """This package is required to render graphs in LaTeX.
Visit '...'.
""")
latex.check_file("tkz-graph.sty", """This package is required to render graphs in LaTeX.
Visit 'http://altermundus.com/pages/tkz/'.
""")
latex.check_file("tkz-berge.sty", """This package is required to render graphs in LaTeX.
Visit 'http://altermundus.com/pages/tkz/'.
""")

def have_tkz_graph():
r"""
Returns ``True`` if the proper LaTeX packages
for the ``tikzpicture`` environment are installed in the
user's environment, namely tikz, tkz-graph and tkz-berge.

The result is cached.

See also :meth:`sage.misc.latex.Latex.has_file`

TESTS::

sage: from sage.graphs.graph_latex import have_tkz_graph
sage: have_tkz_graph()  # random - depends on TeX installation
sage: have_tkz_graph() in [True, False]
True
"""
return latex.has_file("tikz.sty") and latex.has_file("tkz-graph.sty") and latex.has_file("tkz-berge.sty")

@cached_function
def setup_latex_preamble():
"""
Adds appropriate ``\usepackage{...}``, and other instructions to
the latex preamble for the packages that are needed for processing
graphs(``tikz``, ``tkz-graph``, ``tkz-berge``), if available
in the ``LaTeX`` installation.

See also :meth:`sage.misc.latex.Latex.add_package_to_preamble_if_available`.

EXAMPLES::

sage: sage.graphs.graph_latex.setup_latex_preamble()

TESTS::

sage: ("\\usepackage{tikz}" in latex.extra_preamble()) == latex.has_file("tikz.sty")
True
"""
latex.add_package_to_preamble_if_available("tikz")
latex.add_to_mathjax_avoid_list("tikz")
latex.add_package_to_preamble_if_available("tkz-graph")
latex.add_package_to_preamble_if_available("tkz-berge")
if have_tkz_graph():
latex.add_to_preamble("\\usetikzlibrary{arrows,shapes}")

class GraphLatex(SageObject):
r"""
A class to hold, manipulate and employ options for converting
a graph to LaTeX.

This class serves two purposes.  First it holds the values of
various options designed to work with the ``tkz-graph``
LaTeX package for rendering graphs.  As such, a
graph that uses this class will hold a reference to it. Second,
this class contains the code to convert a graph into the
corresponding LaTeX constructs, returning a string.

EXAMPLES::

sage: from sage.graphs.graph_latex import GraphLatex
sage: opts = GraphLatex(graphs.PetersenGraph())
sage: opts
LaTeX options for Petersen graph: {}
sage: g = graphs.PetersenGraph()
sage: opts = g.latex_options()
sage: g == loads(dumps(g))
True
"""

#  These are the "allowed" options for a graph, private to the class,
#  along with their default value and description
#  This allows intelligent errors when non-existent options are referenced
#  Additionally, for each new option added here:
#    1.  Document values in GraphLatex.set_option() docstring
#    2.  Describe also in docstring for the sage.graphs.graph_latex module
#
# TODO: use some standard option handling mechanism
# This dictionary could also contain type information (list of admissible values)
# and a description
# See e.g. @option
__graphlatex_options = {
    'tkz_style': 'Custom',
    'format': 'tkz_graph',
    'layout': 'acyclic',
    'prog': 'dot',
    'units': 'cm',
    'scale': 1.0,
    'graphic_size': (5, 5),
    'margins': (0,0,0,0),
    'vertex_color': 'black',
    'vertex_colors': {},
    'vertex_fill_color': 'white',
    'vertex_fill_colors': {},
    'vertex_shape': 'circle',
    'vertex_shapes': {},
    'vertex_size': 1.0,
    'vertex_sizes': {},
    'vertex_labels': True,
    'vertex_labels_math': True,
    'vertex_label_color': 'black',
    'vertex_label_colors': {},
    'vertex_label_placement': 'center',
    'vertex_label_placements': {},
    'edge_options': (),
    'edge_color': 'black',
    'edge_colors': {},
    'edge_fills': False,
    'edge_fill_color': 'black',
    'edge_fill_colors': {},
    'edge_thickness': 0.1,
    'edge_thicknesses': {},
    'edge_labels': False,
    'edge_labels_math': True,
    'edge_label_color': 'black',
    'edge_label_colors': {},
    'edge_label_sloped': True,
    'edge_label_slopes': {},
    'edge_label_placement': 0.50,
    'edge_label_placements': {},
    'loop_placement': (3.0, 'NO'),
    'loop_placements': {},
    'color_by_label' : False,
    'rankdir': 'down'
    }

def __init__(self, graph, **options):
r"""
Returns a GraphLatex object, which holds all the parameters needed for
creating a LaTeX string that will be rendered as a picture of the graph.

See :mod:`sage.graphs.graph_latex` for more documentation.

EXAMPLES::

    sage: from sage.graphs.graph_latex import GraphLatex
    sage: GraphLatex(graphs.PetersenGraph())
    LaTeX options for Petersen graph: {}
"""
self._graph = graph
self._options = {}
self.set_options(**options)

def __eq__(self, other):
r"""
Two :class:`sage.graphs.graph_latex.GraphLatex` objects
are equal if their options are equal.

The graphs they are associated with are ignored in the comparison.

TESTS::

    sage: from sage.graphs.graph_latex import GraphLatex
    sage: opts1 = GraphLatex(graphs.PetersenGraph())
    sage: opts2 = GraphLatex(graphs.CompleteGraph(10))
    sage: opts1.set_option('tkz_style', 'Art')
    sage: opts2.set_option('tkz_style', 'Art')
    sage: opts1 == opts2
    True
    sage: opts2.set_option('tkz_style', 'Normal')
    sage: opts1 == opts2
    False
"""
if not(isinstance(other, GraphLatex)):
    return False
else:
    return self._options == other._options

def _repr_(self):
r"""
Returns a string representation of a
:class:`sage.graphs.graph_latex.GraphLatex` object
which includes the name of the graph and the dictionary
of current options.

EXAMPLES::

    sage: g = graphs.PetersenGraph()
    sage: opts = g.latex_options()
    sage: opts.set_option('tkz_style', 'Classic')
    sage: opts.set_option('vertex_size', 3.6)
    sage: print opts._repr_()
    LaTeX options for Petersen graph: {'tkz_style': 'Classic', 'vertex_size': 3.60000000000000}
"""
return "LaTeX options for %s: %s"%(self._graph, self._options)

def set_option(self, option_name, option_value = None):
r"""
Sets, modifies, clears a LaTeX
option for controlling the rendering of a graph.

The possible options are documented here, because ultimately it is this
routine that sets the values.  However, the
:meth:`sage.graphs.generic_graph.GenericGraph.set_latex_options` method
is the easiest way to set options, and allows several to be set at once.

INPUTS:

- ``option_name`` - a string for a latex option contained in the list
  ``sage.graphs.graph_latex.GraphLatex.__graphlatex_options``. A
  ``ValueError`` is raised if the option is not allowed.

- ``option_value`` - a value for the option.  If omitted, or
  set to ``None``, the option will use the default value.

The output can be either handled internally by ``Sage``, or
delegated to the external software ``dot2tex`` and
``graphviz``. This is controlled by the option 'format':

- ``format`` -- default: 'tkz_graph' -- either 'dot2tex'
  or 'tkz_graph'.

If format is 'dot2tex', then all the LaTeX generation
will be delegated to ``dot2tex`` (which must be installed).

For ``tkz_graph``, the possible option names, and associated
values are given below.  This first group allows you to set a
style for a graph and specify some sizes related to the eventual
image. (For more information consult the
documentation for the ``tkz-graph`` package.)

- ``tkz_style`` -- default: 'Custom' -- the name of a pre-defined
  ``tkz-graph`` style such as 'Shade', 'Art', 'Normal', 'Dijkstra',
  'Welsh', 'Classic', and 'Simple', or the string 'Custom'.  Using
  one of these styles alone will often give a reasonably good
  drawing with minimal effort. For a custom appearance set this
  to 'Custom' and use the options described below to override
  the default values.

- ``units`` -- default: 'cm' -- a natural unit of measurement
  used for all dimensions.  Possible values are:
  'in','mm','cm','pt', 'em', 'ex'

- ``scale`` -- default: '1.0' -- a dimensionless number that
  multiplies every linear dimension.  So you can design at sizes
  you are accustomed to, then shrink or expand to meet other needs.
  Though fonts do not scale.

- ``graphic_size`` -- default: (5,5) -- overall dimensions
  (width, length) of the bounding box around the entire graphic image

- ``margins`` -- default: (0,0,0,0) -- portion of graphic given
  over to a plain border as a tuple of four numbers:
  (left, right, top, bottom).  These are subtracted from the
  ``graphic_size`` to create the area left for the vertices
  of the graph itself.  Note that the processing done by
  Sage will trim the graphic down to the minimum
  possible size, removing any border.  So this is only useful
  if you use the latex string in a latex document.


If not using a pre-built style the following options are used, so
the following defaults will apply.  It is not possible to begin with
a pre-built style and modify it (other than editing the latex
string by hand after the fact).

- ``vertex_color`` -- default: 'black' -- a single color
  to use as the default for outline of vertices. For the
  ``sphere`` shape this color is used for the entire vertex,
  which is drawn with a 3D shading.  Colors must be specified
  as a string recognized by the matplotlib library:
  a standard color name like 'red', or a hex string like
  '#2D87A7', or a single character from the choices
  'rgbcmykw'. Additionally, a number between 0 and 1
  will create a grayscale value.  These color specifications
  are consistent throughout the options for a ``tkzpicture``.

- ``vertex_colors`` -- a dictionary whose keys are vertices
  of the graph and whose values are colors.  These will be used
  to color the outline of vertices.  See the explanation
  above for the ``vertex_color`` option to see possible values.
  These values need only be specified for a proper subset of the
  vertices.  Specified values will supersede a default value.

- ``vertex_fill_color`` -- default: 'white' -- a single color
  to use as the default for the fill color of vertices.  See
  the explanation above for the ``vertex_color`` option
  to see possible values.  This color is ignored for the
  ``sphere`` vertex shape.

- ``vertex__fill_colors`` -- a dictionary whose keys are vertices
  of the graph and whose values are colors.  These will be used
  to fill the interior of vertices.  See the explanation
  above for the ``vertex_color`` option to see possible values.
  These values need only be specified for a proper subset of the
  vertices.  Specified values will supersede a default value.

- ``vertex_shape`` -- default: 'circle' -- a string for
  the shape of the vertices. Allowable values are 'circle',
  'sphere', 'rectangle', 'diamond'. The sphere shape has
  a 3D look to its coloring and is uses only one color,
  that specified by ``vertex_color`` and ``vertex_colors``,
  which are normally used for the outline of the vertex.

- ``vertex_shapes`` -- a dictionary whose keys are vertices
  of the graph and whose values are shapes.  See ``vertex_shape``
  for the allowable possibilities.

- ``vertex_size``-- default: 1.0 -- the minimum size of a vertex
  as a number.  Vertices will expand to contain their labels if
  the labels are placed inside the vertices.  If you set this
  value to zero the vertex will be as small as possible
  (up to tkz-graph's "inner sep" parameter), while still
  containing labels.  However, if labels are not of a uniform
  size, then the verrices will not be either.

- ``vertex_sizes`` -- a dictionary of sizes for some of the vertices.

- ``vertex_labels`` -- default: ``True`` -- a boolean to
  determine whether or not to display the vertex labels.
  If ``False`` subsequent options about vertex labels are ignored.

- ``vertex_labels_math`` -- default: ``True`` -- when true, if a label
  is a string that begins and ends with dollar signs, then the string
  will be rendered as a latex string.  Otherwise, the label will be
  automatically subjected to the ``latex()`` method and rendered
  accordingly.  If ``False`` the label is rendered as its textual
  representation according to the ``_repr`` method.  Support for
  arbitrarily-complicated mathematics is not especially robust.

- ``vertex_label_color`` -- default: 'black' -- a single color to use
  as the default for labels of vertices. See the explanation above
  for the ``vertex_color`` option to see possible values.

- ``vertex_label_colors`` --  a dictionary whose keys are vertices
  of the graph and whose values are colors.  These will be used
  for the text of the labels of vertices.  See the explanation
  above for the ``vertex_color`` option to see possible values.
  These values need only be specified for a proper subset of the
  vertices.  Specified values will supersede a default value.

- ``vertex_label_placement`` -- default: 'center' --  if 'center'
  the label is centered in the interior of the vertex and the vertex
  will expand to contain the label.  Giving instead a pair of numbers
  will place the label exterior to the vertex at a certain distance
  from the edge, and at an angle to the positive x-axis, similar
  in spirt to polar coordinates.

- ``vertex_label_placements`` -- a dictionary of placements
  indexed by the vertices.  See the explanation for
  ``vertex_label_placement`` for the possible values.

- ``edge_color`` -- default: 'black' -- a single color to use as
  the default for an edge. See the explanation above for the
  ``vertex_color`` option to see possible values.

- ``edge_colors`` -- a dictionary whose keys are edges of the
  graph and whose values are colors.  These will be used to
  color the edges.See the explanation above for the
  ``vertex_color`` option to see possible values.  These
  values need only be specified for a proper subset of the
  vertices.  Specified values will supersede a default value.

- ``edge_fills`` -- default: ``False`` -- a boolean that
  determines if an edge has a second color running down
  the middle.  This can be a useful effect for highlighting
  edge crossings.

- ``edge_fill_color`` -- default: 'black' -- a single color
  to use as the default for the fill color of an edge.
  The boolean switch ``edge_fills`` must be set to True
  for theis to have an effect.  See the explanation above
  for the ``vertex_color`` option to see possible values.

- ``edge__fill_colors`` -- a dictionary whose keys are edges
  of the graph and whose values are colors. See the explanation
  above for the ``vertex_color`` option to see possible values.
  These values need only be specified for a proper subset of the
  vertices.  Specified values will supersede a default value.

- ``edge_thickness`` -- default: 0.1 - a number specifying the
  width of the edges.  Note that tkz-graph does not interpret
  this number for loops.

- ``edge_thicknesses`` -- a dictionary of thicknesses for
  some of the edges of a graph.  These values need only
  be specified for a proper subset of the vertices.  Specified
  values will supersede a default value. If a tuple of vertices
  points to a set of multiedges, you must specify thicknesses
  as a list of numbers for the entire set of multiedges, where
  the order of the values match the order in which the multiedges
  were defined.

- ``edge_labels`` -- default: ``False`` -- a boolean that
  determines if edge labels are shown.  If ``False`` subsequent
  options about edge labels are ignored.

- ``edge_labels_math`` -- default:  ``True`` -- a boolean that
  controls how edge labels are rendered.  Read the explanation
  for the ``vertex_labels_math`` option, which behaves identically.
  Support for arbitrarily-complicated mathematics is not
  especially robust.

- ``edge_label_color`` -- default: 'black' -- a single color
  to use as the default for labels of edges.  See the explanation
  above for the ``vertex_color`` option to see possible values.

- ``edge_label_colors`` --  a dictionary whose keys are edges
  of the graph and whose values are colors.  These will be used
  for the text of the labels of edges.  See the explanation
  above for the ``vertex_color`` option to see possible values.
  These values need only be specified for a proper subset of
  the vertices.  Specified values will supersede a default
  value. Note that labels must be used for this to have any
  effect, and no care is taken to ensure that label and
  fill colors work well together.

- ``edge_label_sloped`` -- default: ``True`` a boolean that
  specifies how edge labels are place.  ``False`` results
  in a horizontal label, while ``True`` means the label
  is rotated to follow the direction of the edge it labels.

- ``edge_label_slopes`` -- a dictionary of booleans, indexed
  by some subset of the edges.  See the ``edge_label_sloped``
  option for a description of sloped edge labels.

- ``edge_label_placement`` -- default: 0.50 -- a number between
  0.0 and 1.0, or one of: 'above', 'below', 'left', 'right'.  These
  adjust the location of an edge label along an edge.  A
  number specifies how far along the edge the label is
  located.  ``left`` and ``right`` are conveniences.
  ``above`` and ``below`` move the label off the edge
  itself while leaving it near the midpoint of the edge.
  The default value of ``0.50`` places the label on the
  midpoint of the edge.

- ``edge_label_placements`` -- a dictionary of edge placements,
  indexed by the edges.  See the ``edge_label_placement`` option
  for a description of the allowable values.

- ``loop_placement`` -- default: (3.0, 'NO') -- a pair,
  that determines how loops are rendered.  the first
  element of the pair is a distance, which determines
  how big the loop is and the second element is a string
  specifying a compass point (North, South, East, West)
  as one of 'NO','SO','EA','WE'.

- ``loop_placements`` -- a dictionary of loop placements.
  See the ``loop_placements`` option for the allowable values.
  While loops are technically edges, this dictionary is
  indexed by vertices.

For the 'dot2tex' format, the possible option names and
associated values are given below:

- ``prog`` -- the program used for the layout. It must be a
  string corresponding to one of the software of the graphviz
  suite: 'dot', 'neato', 'twopi', 'circo' or 'fdp'.

- ``edge_labels`` -- a boolean (default: False). Whether to
  display the labels on edges.

- ``edge_colors`` -- a color. Can be used to set a global
  color to the edge of the graph.

- ``color_by_label`` - a boolean (default: False). Colors the
  edges according to their labels

OUTPUTS:

There are none.  Success happens silently.

EXAMPLES:

Set, then modify, then clear the ``tkz_style`` option, and
finally show an error for an unrecognized option name::

    sage: g = graphs.PetersenGraph()
    sage: opts = g.latex_options()
    sage: opts
    LaTeX options for Petersen graph: {}
    sage: opts.set_option('tkz_style', 'Art')
    sage: opts
    LaTeX options for Petersen graph: {'tkz_style': 'Art'}
    sage: opts.set_option('tkz_style', 'Simple')
    sage: opts
    LaTeX options for Petersen graph: {'tkz_style': 'Simple'}
    sage: opts.set_option('tkz_style')
    sage: opts
    LaTeX options for Petersen graph: {}
    sage: opts.set_option('bad_name', 'nonsense')
    Traceback (most recent call last):
    ...
    ValueError: bad_name is not a LaTeX option for a graph.

See :meth:`sage.graphs.generic_graph.GenericGraph.layout_graphviz` for
installation instructions for ``graphviz`` and ``dot2tex``. Further
more, pgf >= 2.00 should be available inside LaTeX's tree for LaTeX
compilation (e.g. when using ``view``). In case your LaTeX distribution
does not provide it, here are short instructions:

   - download pgf from http://sourceforge.net/projects/pgf/
   - unpack it in ``/usr/share/texmf/tex/generic`` (depends on your system)
   - clean out remaining pgf files from older version
   - run texhash


TESTS:

These test all of the options and one example of each allowable
proper input.  They should all execute silently. ::

    sage: G=Graph()
    sage: G.add_edge((0,1))
    sage: opts = G.latex_options()
    sage: opts.set_option('tkz_style', 'Custom')
    sage: opts.set_option('tkz_style', 'Art')
    sage: opts.set_option('format', 'tkz_graph')
    sage: opts.set_option('layout', 'acyclic')
    sage: opts.set_option('prog', 'dot')
    sage: opts.set_option('units', 'cm')
    sage: opts.set_option('scale', 1.0)
    sage: opts.set_option('graphic_size', (5, 5))
    sage: opts.set_option('margins', (0,0,0,0))
    sage: opts.set_option('vertex_color', 'black')
    sage: opts.set_option('vertex_colors', {0:'#ABCDEF'})
    sage: opts.set_option('vertex_fill_color', 'white')
    sage: opts.set_option('vertex_fill_colors', {0:'c'})
    sage: opts.set_option('vertex_shape', 'circle')
    sage: opts.set_option('vertex_shapes', {0:'sphere'})
    sage: opts.set_option('vertex_size', 1.0)
    sage: opts.set_option('vertex_sizes', {0:3.4})
    sage: opts.set_option('vertex_labels', True)
    sage: opts.set_option('vertex_labels_math', True)
    sage: opts.set_option('vertex_label_color', 'black')
    sage: opts.set_option('vertex_label_colors', {0:'.23'})
    sage: opts.set_option('vertex_label_placement', 'center')
    sage: opts.set_option('vertex_label_placement', (3, 4.2))
    sage: opts.set_option('vertex_label_placements', {0:'center'})
    sage: opts.set_option('vertex_label_placements', {0:(4.7,1)})
    sage: opts.set_option('edge_color', 'black')
    sage: opts.set_option('edge_colors', {(0,1):'w'})
    sage: opts.set_option('edge_fills', False)
    sage: opts.set_option('edge_fill_color', 'black')
    sage: opts.set_option('edge_fill_colors', {(0,1):"#123456"})
    sage: opts.set_option('edge_thickness', 0.1)
    sage: opts.set_option('edge_thicknesses', {(0,1):5.2})
    sage: opts.set_option('edge_labels', False)
    sage: opts.set_option('edge_labels_math', True)
    sage: opts.set_option('edge_label_color', 'black')
    sage: opts.set_option('edge_label_colors', {(0,1):'red'})
    sage: opts.set_option('edge_label_sloped', True)
    sage: opts.set_option('edge_label_slopes', {(0,1): False})
    sage: opts.set_option('edge_label_placement', 'left')
    sage: opts.set_option('edge_label_placement', 0.50)
    sage: opts.set_option('edge_label_placements', {(0,1):'above'})
    sage: opts.set_option('edge_label_placements', {(0,1):0.75})
    sage: opts.set_option('loop_placement', (3.0, 'NO'))
    sage: opts.set_option('loop_placements', {0:(5.7,'WE')})

These test some of the logic of possible failures.  Some tests,
such as inputs of colors, are handled by somewhat general sections
of code and are not tested for each possible option. ::

    sage: G=Graph()
    sage: G.add_edge((0,1))
    sage: opts = G.latex_options()
    sage: opts.set_option('tkz_style', 'Crazed')
    Traceback (most recent call last):
    ...
    ValueError: tkz_style is not "Custom", nor an implemented tkz-graph style
    sage: opts.set_option('format', 'NonExistent')
    Traceback (most recent call last):
    ...
    ValueError: format option must be one of: tkz_graph, dot2tex not NonExistent
    sage: opts.set_option('units', 'furlongs')
    Traceback (most recent call last):
    ...
    ValueError: units option must be one of: in, mm, cm, pt, em, ex, not furlongs
    sage: opts.set_option('graphic_size', (1,2,3))
    Traceback (most recent call last):
    ...
    ValueError: graphic_size option must be an ordered pair, not (1, 2, 3)
    sage: opts.set_option('margins', (1,2,3))
    Traceback (most recent call last):
    ...
    ValueError: margins option must be 4-tuple, not (1, 2, 3)
    sage: opts.set_option('vertex_color', 'chartruse')
    Traceback (most recent call last):
    ...
    ValueError: vertex_color option needs to be a matplotlib color (always as a string), not chartruse
    sage: opts.set_option('vertex_labels_math', 'maybe')
    Traceback (most recent call last):
    ...
    ValueError: vertex_labels_math option must be True or False, not maybe
    sage: opts.set_option('vertex_shape', 'decagon')
    Traceback (most recent call last):
    ...
    ValueError: vertex_shape option must be the shape of a vertex, not decagon
    sage: opts.set_option('scale', 'big')
    Traceback (most recent call last):
    ...
    ValueError: scale option must be a positive number, not big
    sage: opts.set_option('scale', -6)
    Traceback (most recent call last):
    ...
    ValueError: scale option must be a positive number, not -6
    sage: opts.set_option('vertex_label_placement', (2,-4))
    Traceback (most recent call last):
    ...
    ValueError: vertex_label_placement option must be None, or a pair of positive numbers, not (2, -4)
    sage: opts.set_option('edge_label_placement', 3.6)
    Traceback (most recent call last):
    ...
    ValueError: edge_label_placement option must be a number between 0.0 and 1.0 or a place (like "above"), not 3.60000000000000
    sage: opts.set_option('loop_placement', (5,'SW'))
    Traceback (most recent call last):
    ...
    ValueError: loop_placement option must be a pair that is a positive number followed by a compass point abbreviation, not (5, 'SW')
    sage: opts.set_option('vertex_fill_colors', {0:'#GG0000'})
    Traceback (most recent call last):
    ...
    ValueError: vertex_fill_colors option for 0 needs to be a matplotlib color (always as a string), not #GG0000
    sage: opts.set_option('vertex_sizes', {0:-10})
    Traceback (most recent call last):
    ...
    ValueError: vertex_sizes option for 0 needs to be a positive number, not -10
    sage: opts.set_option('edge_label_slopes', {(0,1):'possibly'})
    Traceback (most recent call last):
    ...
    ValueError: edge_label_slopes option for (0, 1) needs to be True or False, not possibly
    sage: opts.set_option('vertex_shapes', {0:'pentagon'})
    Traceback (most recent call last):
    ...
    ValueError: vertex_shapes option for 0 needs to be a vertex shape, not pentagon
    sage: opts.set_option('vertex_label_placements', {0:(1,2,3)})
    Traceback (most recent call last):
    ...
    ValueError: vertex_label_placements option for 0 needs to be None or a pair of positive numbers, not (1, 2, 3)
    sage: opts.set_option('edge_label_placements', {(0,1):'partway'})
    Traceback (most recent call last):
    ...
    ValueError: edge_label_placements option for (0, 1) needs to be a number between 0.0 and 1.0 or a place (like "above"), not partway
    sage: opts.set_option('loop_placements', {0:(-3,'WE')})
    Traceback (most recent call last):
    ...
    ValueError: loop_placements option for 0 needs to be a positive number and a compass point (like "EA"), not (-3, 'WE')
    sage: opts.set_option('margins', (1,2,3,-5))
    Traceback (most recent call last):
    ...
    ValueError: margins option of (1, 2, 3, -5) cannot contain -5
"""
#TODO: Needed improvements, possible extensions, dubious ideas
#- digraph edges should be optionally curved or straight with
#perhaps a variable curvature (exit angle from vertex).  Always
#curved now to allow for bidirectional, and the curvature is
#varied across a set of multiedges.
#- the "draw" option will make boxes around labels as
#extensions of the edge color and thickness
#- edge labels can have colored backgrounds (which look like
#fills when boxed.
#- edge label fonts can be sized (latex style), which will
#make scaling work totally
#- edges can be dotted or dashed, Beezer suggests calling
#this "edge shape" to mirror vertex shapes
#- "line width" works for vertices, should be configurable
#- allow injection of latex code to style a pre-built style
#for example, \SetUpVertex[style={fill=green}] could overide
#color selection in a style like "Art"
#- "inner sep" is distance from vertex label to edge of vertex
#this should be set as small as possible - but bigger than the
#line width.
#- aspect ratio could be preserved, see hints near
#creation of affine transformation.
#- "outer sep" causes edges to stop some distance before
#reaching vertices.  Seems of limited value.

from matplotlib.colors import ColorConverter
from sage.rings.integer import Integer
from sage.rings.real_mpfr import RealLiteral


cc = ColorConverter()  # used as a color tester

if not(option_name in GraphLatex.__graphlatex_options):
    raise ValueError( "%s is not a LaTeX option for a graph." % option_name )
if option_value is None:    # clear the option, if set
    if option_name in self._options:
	del self._options[option_name]
else:
    # Test options here when attempt to set
    name = option_name; value = option_value
    #
    # Tuples of constants
    #
    formats = ('tkz_graph', 'dot2tex')
    styles = ('Custom', 'Shade', 'Art', 'Normal', 'Dijkstra', 'Welsh', 'Classic', 'Simple')
    unit_names = ('in','mm','cm','pt', 'em', 'ex')
    shape_names = ('circle', 'sphere','rectangle', 'diamond')
    label_places = ('above', 'below', 'right', 'left')
    compass_points = ('NO', 'SO', 'EA', 'WE')
    number_types = (int, Integer, float, RealLiteral)
    #
    # Options with structurally similar tests
    #
    boolean_options = ('vertex_labels','vertex_labels_math','edge_fills','edge_labels','edge_labels_math','edge_label_sloped')
    color_options = ('vertex_color', 'vertex_fill_color', 'vertex_label_color','edge_color','edge_fill_color','edge_label_color')
    color_dicts = ('vertex_colors','vertex_fill_colors','vertex_label_colors','edge_colors','edge_fill_colors','edge_label_colors')
    boolean_dicts = ('edge_label_slopes',)
    positive_scalars = ('scale', 'vertex_size', 'edge_thickness')
    positive_scalar_dicts=('vertex_sizes', 'edge_thicknesses')
    positive_tuples=('graphic_size', 'margins')
    #
    #  Checks/test on single values (ie graph-wide defaults)
    #
    if name == 'tkz_style' and not( value in styles ):
	raise ValueError('%s is not "Custom", nor an implemented tkz-graph style' % name)
    elif name == 'format' and not( value in formats ):
	raise ValueError('%s option must be one of: tkz_graph, dot2tex not %s' % (name, value))
    elif name == 'units' and not( value in unit_names ):
	raise ValueError('%s option must be one of: in, mm, cm, pt, em, ex, not %s' % (name, value))
    elif name == 'graphic_size' and not( isinstance(value, tuple) and (len(value) == 2) ):
	raise ValueError( '%s option must be an ordered pair, not %s' % (name, value))
    elif name == 'margins' and not( (isinstance(value, tuple)) and (len(value) == 4) ):
	raise ValueError( '%s option must be 4-tuple, not %s' % (name, value))
    elif name in color_options:
	try:
	    cc.to_rgb(value)
	except Exception:
	    raise ValueError('%s option needs to be a matplotlib color (always as a string), not %s' % (name, value))
    elif name in boolean_options and not isinstance(value, bool):
	raise ValueError('%s option must be True or False, not %s' % (name, value))
    elif name == 'vertex_shape' and not value in shape_names:
	raise ValueError('%s option must be the shape of a vertex, not %s' % (name, value))
    elif name in positive_scalars and not ( isinstance(value, number_types) and (value >= 0.0) ):
	raise ValueError( '%s option must be a positive number, not %s' % (name, value))
    elif name == 'vertex_label_placement' and not( value == 'center') and not( isinstance(value, tuple) and len(value) == 2 and isinstance(value[0], number_types) and value[0]>=0 and isinstance(value[1], number_types) and value[1]>=0 ):
	raise ValueError( '%s option must be None, or a pair of positive numbers, not %s' % (name, value))
    elif name == 'edge_label_placement' and not( (isinstance(value, number_types) and (0<= value) and (value <= 1)) or (value in label_places)):
	raise ValueError( '%s option must be a number between 0.0 and 1.0 or a place (like "above"), not %s' % (name, value))
    elif name == 'loop_placement' and not( (isinstance(value, tuple)) and (len(value) == 2) and (value[0] >=0) and (value[1] in compass_points) ):
	raise ValueError( '%s option must be a pair that is a positive number followed by a compass point abbreviation, not %s' % (name, value))
    #
    #  Checks/test on dictionaries of values (ie per-vertex or per-edge defaults)
    #
    elif name in color_dicts:
	if not isinstance(value, dict):
	    raise TypeError('%s option must be a dictionary, not %s' (name, value))
	else:
	    for key, c in value.items():
		try:
		    cc.to_rgb(c)
		except Exception:
		    raise ValueError('%s option for %s needs to be a matplotlib color (always as a string), not %s' % (name, key, c))
    elif name in positive_scalar_dicts:
	if not isinstance(value, dict):
	    raise TypeError('%s option must be a dictionary, not %s' (name, value))
	else:
	    for key, x in value.items():
		if isinstance(x, list) and (not isinstance(x[0], number_types) or not x[0] >= 0.0):
		    raise ValueError('%s option for %s needs to be a list of positive numbers, not %s' % (name, key, x))
		elif not isinstance(x, list) and (not isinstance(x, number_types) or not x >= 0.0):
		    raise ValueError('%s option for %s needs to be a positive number, not %s' % (name, key, x))
    elif name in boolean_dicts:
	if not isinstance(value, dict):
	    raise TypeError('%s option must be a dictionary, not %s' (name, value))
	else:
	    for key, b in value.items():
		if not isinstance(b, bool):
		    raise ValueError('%s option for %s needs to be True or False, not %s' % (name, key, b))
    elif name == 'vertex_shapes':
	if not isinstance(value, dict):
	    raise TypeError('%s option must be a dictionary, not %s' (name, value))
	else:
	    for key, s in value.items():
		if not s in shape_names:
		    raise ValueError('%s option for %s needs to be a vertex shape, not %s' % (name, key, s))
    elif name == 'vertex_label_placements':
	if not isinstance(value, dict):
	    raise TypeError('%s option must be a dictionary, not %s' (name, value))
	else:
	    for key, p in value.items():
		if not( p == 'center') and not( isinstance(p, tuple) and len(p) == 2 and isinstance(p[0], number_types) and p[0]>=0 and type(p[1]) in number_types and p[1]>=0 ):
		    raise ValueError('%s option for %s needs to be None or a pair of positive numbers, not %s' % (name, key, p))
    elif name == 'edge_label_placements':
	if not isinstance(value, dict):
	    raise TypeError('%s option must be a dictionary, not %s' (name, value))
	else:
	    for key, p in value.items():
		if not(type(p) in [float, RealLiteral] and (0 <= p) and (p <= 1)) and not(p in label_places):
		    raise ValueError('%s option for %s needs to be a number between 0.0 and 1.0 or a place (like "above"), not %s' % (name, key, p))
    elif name == 'loop_placements':
	if not isinstance(value, dict):
	    raise TypeError('%s option must be a dictionary, not %s' (name, value))
	else:
	    for key, p in value.items():
		if not( (isinstance(p, tuple)) and (len(p)==2) and (p[0] >=0) and (p[1] in compass_points) ):
		    raise ValueError('%s option for %s needs to be a positive number and a compass point (like "EA"), not %s' % (name, key, p))
    # These have been verified as tuples before going into this next check
    elif name in positive_tuples:
	for x in value:
	    if not isinstance(x, number_types) or not x >= 0.0:
		raise ValueError( '%s option of %s cannot contain %s' % (name, value, x))
    #
    # Verified.  Set it.
    self._options[option_name] = option_value


def set_options(self, **kwds):
r"""
Set several LaTeX options for a graph all at once.

INPUTS:

 - kwds - any number of option/value pairs to se many graph latex
   options at once (a variable number, in any order). Existing
   values are overwritten, new values are added.  Existing
   values can be cleared by setting the value to ``None``.
   Errors are raised in the :func:`set_option` method.

EXAMPLES::

    sage: g = graphs.PetersenGraph()
    sage: opts = g.latex_options()
    sage: opts.set_options(tkz_style = 'Welsh')
    sage: opts.get_option('tkz_style')
    'Welsh'
"""
if kwds:
    for name, value in kwds.items():
	self.set_option(name, value)

def get_option(self, option_name):
r"""
Returns the current value of the named option.

INPUT:

- option_name - the name of an option

OUTPUT:

If the name is not present in
``__graphlatex_options`` it is an
error to ask for it.  If an option has not been set then the
default value is returned. Otherwise, the value of the
option is returned.

EXAMPLES::

    sage: g = graphs.PetersenGraph()
    sage: opts = g.latex_options()
    sage: opts.set_option('tkz_style', 'Art')
    sage: opts.get_option('tkz_style')
    'Art'
    sage: opts.set_option('tkz_style')
    sage: opts.get_option('tkz_style') == "Custom"
    True
    sage: opts.get_option('bad_name')
    Traceback (most recent call last):
    ...
    ValueError: bad_name is not a Latex option for a graph.
"""
if not(option_name in GraphLatex.__graphlatex_options):
    raise ValueError( "%s is not a Latex option for a graph." % option_name )
else:
    if option_name in self._options:
	return self._options[option_name]
    else:
	return GraphLatex.__graphlatex_options[option_name]

def latex(self):
r"""
Returns a string in LaTeX representing a graph.

This is the command that is invoked by
``sage.graphs.generic_graph.GenericGraph._latex_`` for a graph, so
it returns a string of LaTeX commands that can be incorporated into a
LaTeX document unmodified.  The exact contents of this string are
influenced by the options set via the methods
:meth:`sage.graphs.generic_graph.GenericGraph.set_latex_options`,
:meth:`set_option`, and :meth:`set_options`.

By setting the ``format`` option different packages can be used to
create the latex version of a graph.  Supported packages are
``tkz-graph`` and ``dot2tex``.

EXAMPLES::

    sage: from sage.graphs.graph_latex import check_tkz_graph
    sage: check_tkz_graph()  # random - depends on TeX installation
    sage: g = graphs.CompleteGraph(2)
    sage: opts = g.latex_options()
    sage: print opts.latex()
    \begin{tikzpicture}
    %
    \useasboundingbox (0,0) rectangle (5.0cm,5.0cm);
    %
    \definecolor{cv0}{rgb}{0.0,0.0,0.0}
    \definecolor{cfv0}{rgb}{1.0,1.0,1.0}
    \definecolor{clv0}{rgb}{0.0,0.0,0.0}
    \definecolor{cv1}{rgb}{0.0,0.0,0.0}
    \definecolor{cfv1}{rgb}{1.0,1.0,1.0}
    \definecolor{clv1}{rgb}{0.0,0.0,0.0}
    \definecolor{cv0v1}{rgb}{0.0,0.0,0.0}
    %
    \Vertex[style={minimum size=1.0cm,draw=cv0,fill=cfv0,text=clv0,shape=circle},LabelOut=false,L=\hbox{$0$},x=5.0cm,y=5.0cm]{v0}
    \Vertex[style={minimum size=1.0cm,draw=cv1,fill=cfv1,text=clv1,shape=circle},LabelOut=false,L=\hbox{$1$},x=0.0cm,y=0.0cm]{v1}
    %
    \Edge[lw=0.1cm,style={color=cv0v1,},](v0)(v1)
    %
    \end{tikzpicture}
"""
format = self.get_option('format')
if format  == "tkz_graph":
    return self.tkz_picture()
elif format == "dot2tex":
    return self.dot2tex_picture()

def dot2tex_picture(self):
r"""
Calls dot2tex to construct a string of LaTeX commands
representing a graph as a ``tikzpicture``.

EXAMPLES::

    sage: g = digraphs.ButterflyGraph(1)
    sage: from sage.graphs.graph_latex import check_tkz_graph
    sage: check_tkz_graph()  # random - depends on TeX installation
    sage: print g.latex_options().dot2tex_picture()  # optional - dot2tex graphviz
    \begin{tikzpicture}[>=latex,line join=bevel,]
    %%
      \node (node_3) at (...bp,...bp) [draw,draw=none] {$\left(1, 1\right)$};
      \node (node_2) at (...bp,...bp) [draw,draw=none] {$\left(1, 0\right)$};
      \node (node_1) at (...bp,...bp) [draw,draw=none] {$\left(0, 1\right)$};
      \node (node_0) at (...bp,...bp) [draw,draw=none] {$\left(0, 0\right)$};
      \draw [black,->] (node_0) ..controls (...bp,...bp) and (...bp,...bp)  .. (node_3);
      \draw [black,->] (node_2) ..controls (...bp,...bp) and (...bp,...bp)  .. (node_1);
      \draw [black,->] (node_0) ..controls (...bp,...bp) and (...bp,...bp)  .. (node_1);
      \draw [black,->] (node_2) ..controls (...bp,...bp) and (...bp,...bp)  .. (node_3);
    %
    \end{tikzpicture}

We make sure :trac:`13624` is fixed:: 

    sage: G = DiGraph() 
    sage: G.add_edge(3333, 88, 'my_label') 
    sage: G.set_latex_options(edge_labels=True) 
    sage: print G.latex_options().dot2tex_picture() # optional - dot2tex graphviz 
    \begin{tikzpicture}[>=latex,line join=bevel,] 
    %% 
    \node (node_1) at (...bp,...bp) [draw,draw=none] {$3333$};
      \node (node_0) at (...bp,...bp) [draw,draw=none] {$88$};
      \draw [black,->] (node_1) ..controls (...bp,...bp) and (...bp,...bp)  .. (node_0);
      \definecolor{strokecol}{rgb}{0.0,0.0,0.0}; 
      \pgfsetstrokecolor{strokecol} 
      \draw (...bp,...bp) node {$\text{\texttt{my{\char`\_}label}}$}; 
    % 
    \end{tikzpicture} 

Note: there is a lot of overlap between what tkz_picture and
dot2tex do. It would be best to merge them! dot2tex probably
can work without graphviz if layout information is provided.
"""
from sage.graphs.dot2tex_utils import assert_have_dot2tex
assert_have_dot2tex()

options = self.__graphlatex_options.copy()
options.update(self._options)
dotdata = self._graph.graphviz_string(labels="latex", **options)
import dot2tex
return dot2tex.dot2tex(
	dotdata,
	format = 'tikz',
	autosize = True,
	crop = True,
	figonly = 'True',
	prog=self.get_option('prog'))
# usepdflatex = True, debug = True)

def tkz_picture(self):
r"""
Return a string of LaTeX commands representing a graph as a ``tikzpicture``.

This routine interprets the graph's properties and the options in
``_options`` to render the graph with commands from the ``tkz-graph``
LaTeX package.

This requires that the LaTeX optional packages
tkz-graph and tkz-berge be installed.  You may also need a
current version of the pgf package.  If the tkz-graph and
tkz-berge packages are present in the system's TeX
installation, the appropriate ``\\usepackage{}`` commands
will be added to the LaTeX preamble as part of
the initialization of the graph. If these two packages
are not present, then this command will return a warning
on its first use, but will return a string that could be
used elsewhere, such as a LaTeX document.

For more information about tkz-graph you can visit
`Altermundus.com <http://altermundus.com/>`_

EXAMPLES:

With a pre-built ``tkz-graph`` style specified, the latex
representation will be relatively simple. ::

    sage: from sage.graphs.graph_latex import check_tkz_graph
    sage: check_tkz_graph()  # random - depends on TeX installation
    sage: g = graphs.CompleteGraph(3)
    sage: opts = g.latex_options()
    sage: g.set_latex_options(tkz_style='Art')
    sage: print opts.tkz_picture()
    \begin{tikzpicture}
    %
    \GraphInit[vstyle=Art]
    %
    \useasboundingbox (0,0) rectangle (5.0cm,5.0cm);
    %
    \Vertex[L=\hbox{$0$},x=2.5cm,y=5.0cm]{v0}
    \Vertex[L=\hbox{$1$},x=0.0cm,y=0.0cm]{v1}
    \Vertex[L=\hbox{$2$},x=5.0cm,y=0.0cm]{v2}
    %
    \Edge[](v0)(v1)
    \Edge[](v0)(v2)
    \Edge[](v1)(v2)
    %
    \end{tikzpicture}

Setting the style to "Custom" results in various configurable
aspects set to the defaults, so the string is more involved. ::

    sage: from sage.graphs.graph_latex import check_tkz_graph
    sage: check_tkz_graph()  # random - depends on TeX installation
    sage: g = graphs.CompleteGraph(3)
    sage: opts = g.latex_options()
    sage: g.set_latex_options(tkz_style='Custom')
    sage: print opts.tkz_picture()
    \begin{tikzpicture}
    %
    \useasboundingbox (0,0) rectangle (5.0cm,5.0cm);
    %
    \definecolor{cv0}{rgb}{0.0,0.0,0.0}
    \definecolor{cfv0}{rgb}{1.0,1.0,1.0}
    \definecolor{clv0}{rgb}{0.0,0.0,0.0}
    \definecolor{cv1}{rgb}{0.0,0.0,0.0}
    \definecolor{cfv1}{rgb}{1.0,1.0,1.0}
    \definecolor{clv1}{rgb}{0.0,0.0,0.0}
    \definecolor{cv2}{rgb}{0.0,0.0,0.0}
    \definecolor{cfv2}{rgb}{1.0,1.0,1.0}
    \definecolor{clv2}{rgb}{0.0,0.0,0.0}
    \definecolor{cv0v1}{rgb}{0.0,0.0,0.0}
    \definecolor{cv0v2}{rgb}{0.0,0.0,0.0}
    \definecolor{cv1v2}{rgb}{0.0,0.0,0.0}
    %
    \Vertex[style={minimum size=1.0cm,draw=cv0,fill=cfv0,text=clv0,shape=circle},LabelOut=false,L=\hbox{$0$},x=2.5cm,y=5.0cm]{v0}
    \Vertex[style={minimum size=1.0cm,draw=cv1,fill=cfv1,text=clv1,shape=circle},LabelOut=false,L=\hbox{$1$},x=0.0cm,y=0.0cm]{v1}
    \Vertex[style={minimum size=1.0cm,draw=cv2,fill=cfv2,text=clv2,shape=circle},LabelOut=false,L=\hbox{$2$},x=5.0cm,y=0.0cm]{v2}
    %
    \Edge[lw=0.1cm,style={color=cv0v1,},](v0)(v1)
    \Edge[lw=0.1cm,style={color=cv0v2,},](v0)(v2)
    \Edge[lw=0.1cm,style={color=cv1v2,},](v1)(v2)
    %
    \end{tikzpicture}

See the introduction to the :mod:`~sage.graphs.graph_latex` module
for more information on the use of this routine.

TESTS:

Graphs with preset layouts that are vertical or horizontal
can cause problems. First test is a horizontal layout on a
path with three vertices. ::

    sage: from sage.graphs.graph_latex import check_tkz_graph
    sage: check_tkz_graph()  # random - depends on TeX installation
    sage: g = graphs.PathGraph(3)
    sage: opts = g.latex_options()
    sage: print opts.tkz_picture()
    \begin{tikzpicture}
    ...
    \end{tikzpicture}

Scaling to a bounding box is problematic for graphs with
just one vertex, or none. ::

    sage: from sage.graphs.graph_latex import check_tkz_graph
    sage: check_tkz_graph()  # random - depends on TeX installation
    sage: g = graphs.CompleteGraph(1)
    sage: opts = g.latex_options()
    sage: print opts.tkz_picture()
    \begin{tikzpicture}
    ...
    \end{tikzpicture}
"""

# This routine does not handle color customizations of multiedges.
if self._graph.has_multiple_edges() and self.get_option('edge_colors'):
	raise NotImplementedError("Edge-specific colors are not available for multiedges.")

from matplotlib.colors import ColorConverter
from sage.misc.latex import latex
from sage.rings.real_mpfr import RealLiteral  # remove?
import copy

# On first use of this method, the next call may print warnings
# as a side effect, but will be silent on any subsequent use.
check_tkz_graph()

# Overhead
cc = ColorConverter()  # .to_rgb method to convert "colors" to triples
prefix = 'v'  # leading string on internal (to tkz-graph) vertex names

####################
###  Pre-built syles
####################

# We preserve the pre-built style OR
# get defaults for each option, but we do not mix the two
style = self.get_option('tkz_style')
customized = (style == 'Custom')
# We don't do much for a pre-built style
# Layout information from the graph
# And vertex labels (if used) are the latex representation of Sage objects
if not customized:
    vertex_labels_math = True

###################################
###  Layout, image sizing placement
###################################

units = self.get_option('units')
scale = self.get_option('scale')
graphic_size = self.get_option('graphic_size')
margins = self.get_option('margins')

# The positions of the vertices will get scaled to fill the
# specified size of the image, as given by graphic_size.
# But first a border is subtracted away and the graph
# is scaled to fit there.

# Lower left, upper right corners of box inside borders
llx = margins[0]; lly = margins[3]
urx = graphic_size[0]-margins[1]; ury = graphic_size[1]-margins[2]
# width and height of space
w = urx - llx; h = ury - lly

# TODO: Could use self._graph._layout_bounding_box(pos)
# trans = lambda x,y: [x[0]-y[0],x[1]-y[1]]
# Determine the spread in the x and y directions (i.e. xmax, ymax)
# Needs care for perfectly horizontal and vertical layouts

# We grab the graph's layout (or it is computed as a consequence of the request)
pos = self._graph.layout()

if len(pos.values()) > 0:
    xmin = min([ i[0] for i in pos.values()])
    ymin = min([ i[1] for i in pos.values()])
    xmax = max([ i[0] for i in pos.values()])
    ymax = max([ i[1] for i in pos.values()])
else:
    xmax, ymax = 0, 0

# Linear scaling factors that will be used to scale the image to
# fit into the bordered region.  Purely horizontal, or purely vertical,
# layouts get put in the middle of the bounding box by setting the
# scaling to a constant value on a midline
xspread = xmax - xmin
if xspread == 0:
    x_scale = 0.0
    llx = llx + 0.5*w
else:
    x_scale = float(w)/xspread
yspread = ymax - ymin
if yspread == 0:
    y_scale = 0.0
    lly = lly + 0.5*h
else:
    y_scale = float(h)/yspread
# Could preserve aspect ratio here by setting both scale factors to the minimum
# and doing a shift of the larger to center
# A linear function will map layout positions into the bordered graphic space
translate = lambda p: ((p[0]-xmin)*x_scale+llx, (p[1]-ymin)*y_scale+lly)


# The positions of the vertices will get scaled to fill the
# specified size of the image, as given by graphic_size.
# But first a border is subtracted away and the graph
# is scaled to fit there.

# Lower left, upper right corners of box inside borders
llx = margins[0]; lly = margins[3]
urx = graphic_size[0]-margins[1]; ury = graphic_size[1]-margins[2]
# width and height of space
w = urx - llx; h = ury - lly

# TODO: Could use self._graph._layout_bounding_box(pos)
# trans = lambda x,y: [x[0]-y[0],x[1]-y[1]]
# Determine the spread in the x and y directions (i.e. xmax, ymax)
# Needs care for perfectly horizontal and vertical layouts
### pos = copy.deepcopy(self._graph.layout(layout = layout, labels = "latex"))
pos = self._graph.layout()
if len(pos.values()) > 0:
    xmin = min([ i[0] for i in pos.values()])
    ymin = min([ i[1] for i in pos.values()])
    xmax = max([ i[0] for i in pos.values()])
    ymax = max([ i[1] for i in pos.values()])
else:
    xmax, ymax = 0, 0

# Linear scaling factors that will be used to scale the image to
# fit into the bordered region.  Purely horizontal, or purely vertical,
# layouts get put in the middle of the bounding box by setting the
# scaling to a constant value on a midline
xspread = xmax - xmin
if xspread == 0:
    x_scale = 0.0
    llx = llx + 0.5*w
else:
    x_scale = float(w)/xspread
yspread = ymax - ymin
if yspread == 0:
    y_scale = 0.0
    lly = lly + 0.5*h
else:
    y_scale = float(h)/yspread

# Could preserve aspect ratio here by setting both scale factors to the minimum
# and doing a shift of the larger to center
# A linear function will map layout positions into the bordered graphic space
translate = lambda p: ((p[0]-xmin)*x_scale+llx, (p[1]-ymin)*y_scale+lly)

#############
###  Vertices
#############

# We record the index of each vertex in the graph's list of vertices
# Which is just a convenience for forming vertex names internal to tkz-graph
index_of_vertex={}
vertex_list = self._graph.vertices()
for u in self._graph:
    index_of_vertex[u]=vertex_list.index(u)

# Vertex labels can be switched on/off, and we don't record
# or use this type of extra information if they are switched off
vertex_labels = self.get_option('vertex_labels')

# We collect options for vertices, default values and and for-some-vertices information
# These are combined into dictionaries on a per-vertex basis, for all vertices
# This only applies for a custom style
#
# Defaults
#
if customized:
    dvc = cc.to_rgb(self.get_option('vertex_color'))
    dvfc = cc.to_rgb(self.get_option('vertex_fill_color'))
    dsh = self.get_option( 'vertex_shape' )
    dvs = self.get_option('vertex_size')
    #
    # Default label information, if using vertex labels
    #
    if vertex_labels:
	vertex_labels_math = self.get_option('vertex_labels_math')
	dvlc = cc.to_rgb(self.get_option('vertex_label_color'))
	dvlp = self.get_option('vertex_label_placement')
	# needs test for a pair of numbers, angle and distance (or None)

    # Retrieve dictionaries for selected vertices
    vertex_colors = self.get_option('vertex_colors')
    vertex_fill_colors = self.get_option('vertex_fill_colors')
    vertex_shapes = self.get_option('vertex_shapes')
    vertex_sizes = self.get_option('vertex_sizes')
    if vertex_labels:
	vertex_label_colors = self.get_option('vertex_label_colors')
	vertex_label_placements = self.get_option('vertex_label_placements')

    # Form dictionaries, each indexed for all vertices
    v_color = {}
    vf_color = {}
    v_shape = {}
    v_size = {}
    if vertex_labels:
	vl_color = {}
	vl_placement = {}
    for u in vertex_list:
	#
	c = dvc
	if u in vertex_colors:
	    c = cc.to_rgb(vertex_colors[u])
	v_color[ u ] = c
	#
	c = dvfc
	if u in vertex_fill_colors:
	    c = cc.to_rgb(vertex_fill_colors[u])
	vf_color[u] = c
	#
	sh = dsh
	if u in vertex_shapes:
	    sh = vertex_shapes[u]
	v_shape[u] = sh
	#
	vs = dvs
	if u in vertex_sizes:
	    vs = vertex_sizes[u]
	v_size[u] = vs
	#
	if vertex_labels:
	    #
	    c = dvlc
	    if u in vertex_label_colors:
		c = cc.to_rgb(vertex_label_colors[u])
	    vl_color[u] = c
	    #
	    vlp = dvlp
	    if u in vertex_label_placements:
		vlp = vertex_label_placements[u]
		# test vlp here
	    vl_placement[u] = vlp

##########
###  Edges
##########

if customized:
    # An "edge fill" is a bit unusual, so we allow it to
    # be turned off as the default.
    edge_fills = self.get_option('edge_fills')

    # Edge labels can be switched on/off, and we don't record
    # or use this type of extra information if they are switched off
    edge_labels = self.get_option('edge_labels')

    # We collect options for edges, default values and for-some-edges information
    # These are combined into dictionaries on a per-edge basis, for all edges
    #
    # Defaults
    #
    dec = cc.to_rgb(self.get_option('edge_color'))
    if edge_fills:
	defc = cc.to_rgb(self.get_option('edge_fill_color'))
    det = self.get_option('edge_thickness')
    #
    if edge_labels:
	edge_labels_math = self.get_option('edge_labels_math')
	delc = cc.to_rgb(self.get_option('edge_label_color'))
	dels = self.get_option('edge_label_sloped')
	delp = self.get_option('edge_label_placement')

    # Retrieve dictionaries for selected edges
    edge_colors = self.get_option('edge_colors')
    if edge_fills:
	edge_fill_colors = self.get_option('edge_fill_colors')
    edge_thicknesses = self.get_option('edge_thicknesses')
    if edge_labels:
	edge_label_colors = self.get_option('edge_label_colors')
	edge_label_slopes = self.get_option('edge_label_slopes')
	edge_label_placements = self.get_option('edge_label_placements')

    # Form dictionaries, each indexed for all edges
    #
    # A key of a dictionary indexed by edges may be
    # set for an edge of an undirected
    # graph in the "wrong" order, so we use a
    # "reverse" to test for this case.  Everything formed
    # here conforms to the order used in the graph.
    #
    e_color = {}
    if edge_fills:
	ef_color = {}
    e_thick = {}
    if edge_labels:
	el_color = {}
	el_slope={}
	el_placement={}

    for e in self._graph.edges():
	edge=(e[0],e[1]); reverse=(e[1],e[0])
	#
	c = dec
	if edge in edge_colors or (not self._graph.is_directed() and reverse in edge_colors):
	    if edge in edge_colors:
		c = cc.to_rgb(edge_colors[edge])
	    else:
		c = cc.to_rgb(edge_colors[reverse])
	e_color[edge] = c
	#
	if edge_fills:
	    c = defc
	    if edge in edge_fill_colors or (not self._graph.is_directed() and reverse in edge_fill_colors):
		if edge in edge_colors:
		    c = cc.to_rgb(edge_fill_colors[edge])
		else:
		    c = cc.to_rgb(edge_fill_colors[reverse])
	    ef_color[edge] = c
	#
	et = det
	if edge in edge_thicknesses or (not self._graph.is_directed() and reverse in edge_thicknesses):
	    if edge in edge_thicknesses:
		et = edge_thicknesses[edge]
	    else:
		et = edge_thicknesses[reverse]
	e_thick[edge] = et
	#
	if edge_labels:
	    c = delc
	    if edge in edge_label_colors or (not self._graph.is_directed() and reverse in edge_label_colors):
		if edge in edge_label_colors:
		    c = cc.to_rgb(edge_label_colors[edge])
		else:
		    c = cc.to_rgb(edge_label_colors[reverse])
	    el_color[edge] = c
	    #
	    els = dels
	    if edge in edge_label_slopes or (not self._graph.is_directed() and reverse in edge_label_slopes):
		if edge in edge_label_slopes:
		    els = edge_label_slopes[edge]
		else:
		    els = edge_label_slopes[reverse]
	    el_slope[edge] = els
	    #
	    elp = delp
	    if edge in edge_label_placements or (not self._graph.is_directed() and reverse in edge_label_placements):
		if edge in edge_label_placements:
		    elp = edge_label_placements[edge]
		else:
		    elp = edge_label_placements[reverse]
	    el_placement[edge] = elp

##########
###  Loops
##########

# Loops can be styled much like any other edge
# By indexing on a pair of two equal vertices
# Though edge thickness is not implemented in tkz-graph!
# Size and direction are unique, and are indexed by the vertex
# rather than on edges.

# Loop placements are pairs of  length, compass-point
if customized:
    if self._graph.has_loops():
	dlp = self.get_option('loop_placement')
	loop_placements = self.get_option('loop_placements')
	lp_placement = {}
	for u in vertex_list:
	    lp = dlp
	    if u in loop_placements:
		lp = loop_placements[u]
	    lp_placement[u] = lp


############################
###  Build the output string
############################

# s is the eventual tkz string
# Everything should now be in place
# We build a list and then concatenate it as the return value
s = ['\\begin{tikzpicture}\n%\n']

if not customized:
    s+=['\\GraphInit[vstyle=', style, ']\n%\n']

# Specify the bounding box for the latex result
# If too big, then the latex paper size may need to be expanded
s+=['\\useasboundingbox (0,0) rectangle (', str(round(scale*graphic_size[0],4)), units, ',', str(round(scale*graphic_size[1],4)), units, ');\n%\n']

# Internal strings representing colors are defined here in custom style
if customized:
    # Define all the colors for the vertices: perimeter, fill, label
    vertex_color_names = {}
    vertex_fill_color_names = {}
    vertex_label_color_names = {}
    for u in vertex_list:
	vertex_color_names[ u ] = 'c' + prefix + str(index_of_vertex[ u ])
	s+=['\definecolor{', vertex_color_names[ u ], '}{rgb}', '{']
	s+=[str(round( v_color[u][0],4)), ',']
	s+=[str(round( v_color[u][1],4)), ',']
	s+=[str(round( v_color[u][2],4)), '}\n']
	vertex_fill_color_names[ u ] = 'cf' + prefix + str(index_of_vertex[ u ])
	s+=['\definecolor{', vertex_fill_color_names[ u ], '}{rgb}', '{']
	s+=[str(round( vf_color[u][0],4)), ',']
	s+=[str(round( vf_color[u][1],4)), ',']
	s+=[str(round( vf_color[u][2],4)), '}\n']
	if vertex_labels:
	    vertex_label_color_names[u] = 'cl' + prefix + str(index_of_vertex[ u ])
	    s+=['\definecolor{', vertex_label_color_names[ u ], '}{rgb}{']
	    s+=[str(round( vl_color[u][0],4)), ',']
	    s+=[str(round( vl_color[u][1],4)), ',']
	    s+=[str(round( vl_color[u][2],4)), '}\n']
    # Define all the colors for the edges: perimeter, fill, label
    edge_color_names = {}
    edge_fill_color_names = {}
    edge_label_color_names = {}
    for e in self._graph.edges():
	edge = (e[0], e[1])
	edge_color_names[edge] = 'c' + prefix + str(index_of_vertex[edge[0]])+ prefix + str(index_of_vertex[edge[1]])
	s+=['\definecolor{', edge_color_names[edge], '}{rgb}{']
	s+=[str(round( e_color[edge][0],4)), ',']
	s+=[str(round( e_color[edge][1],4)), ',']
	s+=[str(round( e_color[edge][2],4)), '}\n']
	if edge_fills:
	    edge_fill_color_names[edge] = 'cf' + prefix + str(index_of_vertex[edge[0]])+ prefix + str(index_of_vertex[edge[1]])
	    s+=['\definecolor{', edge_fill_color_names[edge], '}{rgb}{']
	    s+=[str(round( ef_color[edge][0],4)), ',']
	    s+=[str(round( ef_color[edge][1],4)), ',']
	    s+=[str(round( ef_color[edge][2],4)), '}\n']
	if edge_labels:
	    edge_label_color_names[edge] = 'cl' + prefix + str(index_of_vertex[edge[0]])+ prefix + str(index_of_vertex[edge[1]])
	    s+=['\definecolor{', edge_label_color_names[edge], '}{rgb}{']
	    s+=[str(round( el_color[edge][0],4)), ',']
	    s+=[str(round( el_color[edge][1],4)), ',']
	    s+=[str(round( el_color[edge][2],4)), '}\n']
    s = s+['%\n']

# Create each vertex
for u in vertex_list:
    s+=['\\Vertex[']
    # colors, shapes, sizes, labels/placement for 'Custom' style
    if customized:
	s+=['style={'] # begin style list
	s+=['minimum size=', str(round(scale*v_size[u],4)), units, ',']
	s+=['draw=', vertex_color_names[u], ',']
	s+=['fill=', vertex_fill_color_names[u], ',']
	if vertex_labels:
	    s+=['text=', vertex_label_color_names[u], ',']
	if v_shape[u] == 'sphere':
	    s+=['shape=circle,shading=ball,line width=0pt,ball color=', vertex_color_names[u], ',']
	else:
	    s+=['shape=', v_shape[u]]
	s+=['},']  # end style list
	if vertex_labels:
	    if vl_placement[u] == 'center':
		s+=['LabelOut=false,']
	    else:
		s+=['LabelOut=true,']
		s+=['Ldist=', str(round(scale*vl_placement[u][0],4)), units, ',']
		s+=['Lpos=',str(round(vl_placement[u][1],4)), ',']  # degrees, no units
	else:
	    s+=['NoLabel,']
    # vertex label information is available to all pre-built styles
    # but may be ignored by the style, so not apparent
    if vertex_labels or not customized:
	if vertex_labels_math and not (isinstance(u, str) and u[0]=='$' and u[-1]=='$'):
	    lab = '\hbox{$%s$}' % latex(u)
	else:
	    lab = '\hbox{%s}' % u
	s+=['L=', lab, ',']
    scaled_pos = translate(pos[u])
    s+=['x=', str(round(scale*scaled_pos[0],4)), units, ',']
    s+=['y=', str(round(scale*scaled_pos[1],4)), units]
    s+=[']']
    s+=['{', prefix, str(index_of_vertex[u]), '}\n']
s+=['%\n']

# Create each edge or loop
multiedge_index = 0
previous_edge = ""
for e in self._graph.edges():
    edge = (e[0],e[1])
    loop = e[0] == e[1]
    if edge == previous_edge:
	multiedge_index += 1
    else:
	multiedge_index = 0
    if loop:
	u=e[0]
	s+=['\\Loop[']
	if customized:
	    s+=['dist=', str(round(scale*lp_placement[u][0],4)), units, ',']
	    s+=['dir=', lp_placement[u][1], ',']
    else:
	s+=['\\Edge[']
    # colors, shapes, sizes, labels/placement for 'Custom' style
    if customized:
	if not loop:  # lw not available for loops!
	    edge_thickness = e_thick[edge]
	    if  self._graph.allows_multiple_edges() and isinstance(edge_thickness, list):
		reverse_index = len(edge_thickness) - (multiedge_index+1)
		edge_thickness = edge_thickness[reverse_index]
	    s+=['lw=', str(round(scale*edge_thickness,4)), units, ',']
	s+=['style={']  # begin style list
	if self._graph.is_directed():
	    s+=['->,']
	if (self._graph.is_directed() or self._graph.allows_multiple_edges()) and not loop:
	    s+=['bend right=', str(10+20*multiedge_index), ',']
	s+=['color=', edge_color_names[edge], ',']
	if edge_fills:
	    s+=['double=', edge_fill_color_names[edge]]
	s+=['},']     # end style list
	if edge_labels:
	    s+=['labelstyle={']
	    if el_slope[edge]:
		s+=['sloped,']
	    if isinstance(el_placement[edge], str):
		s+=[el_placement[edge],',']
	    else:
		s+=['pos=', str(round(el_placement[edge],4)), ',']  # no units needed
	    s+=['text=', edge_label_color_names[edge], ',']
	    s+=['},']
	    if self._graph.allows_multiple_edges():
		edge_label_text = self._graph.edge_label(edge[0],edge[1])[multiedge_index]
	    else:
		edge_label_text = self._graph.edge_label(edge[0],edge[1])
	    if edge_labels_math and not (isinstance(edge_label_text, str) and edge_label_text[0]=='$' and edge_label_text[-1]=='$'):
		lab = '\hbox{$%s$}' % latex(edge_label_text)
	    else:
		lab = '\hbox{%s}' % edge_label_text
	    s+=['label=', lab, ',']
    s+=[']']
    if not loop:
	s+=['(', prefix, str(index_of_vertex[e[0]]), ')']
    s+=['(', prefix, str(index_of_vertex[e[1]]), ')\n']
    previous_edge = edge

# Wrap it up
s+=['%\n']
s+=['\\end{tikzpicture}']

return ''.join(s)
</source-file>
