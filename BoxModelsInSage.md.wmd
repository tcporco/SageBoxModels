---
layout: page
title: Box Models in Sage
wmd_project: Box_Models
wmd_prerequisite_projects:
  SageDynamicsRepo: SageDynamicsRepo
---

This is a preliminary stab at automating construction of compartment (box)
models in Sage.

The BoxModel and BoxModelProduct classes are at the end of this page.

## Test by making an SIR model

<source-file filename="SIR.sage.step">
# requires: boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIR.sage.out.tex SIR.boxes.tex SIR.trajectory.png SIR.sobj
import os
import sys
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from latex_output import *

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SIR = BoxModel( DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ), [S,I,R] )

save_session( 'SIR.sobj' )

ltx = latex_output( "SIR.sage.out.tex" )

SIRode = SIR.ode()

ltx.write( 'SIR model:\n', SIRode )

ltx.close()

SIR.plot_boxes( 'SIR.boxes.tex', figsize=(5,5) )

epsilon = 0.01 # initial infectious pop
trajectory = SIRode.bind( { mu:0.1, alpha:1 } ).solve( [1-epsilon,epsilon,0], end_time=80 )
#trajectory.plot( 't', [S,I,R], filename='SIR.trajectory.png', figsize=(5,5) )
P = ( trajectory.plot( 't', S, color='blue', legend_label='$S$' )
    + trajectory.plot( 't', I, color='red', legend_label='$I$' )
    + trajectory.plot( 't', R, color='green', legend_label='$R$' )
)
P.save( filename='SIR.trajectory.png', figsize=(5,4), legend_loc='upper right' )

sys.exit(0r)
</source-file>

<project-file filename="SIR.sage.out.html"/>

<project-file filename="SIR.boxes.crop.svg"/>

<project-file filename="SIR.trajectory.png"/>

## test the cross product

<source-file filename=cross.sage.step lang=sage>
# requires: boxmodel.py boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: cross.sage.out.tex classes.boxes.tex SIR2.boxes.tex
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from boxmodelproduct import *
from latex_output import *

#print 'make SIR model'
sys.stdout.flush()

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )
SIR = BoxModel( DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ), [S,I,R] )

#print 'make classes model'
sys.stdout.flush()

A, B, a, b = SR.var( 'A B a b' )
classes = BoxModel( DiGraph( { A:{ B:A*a }, B:{ A:B*b } } ), [A,B] )

#print 'write latex'
sys.stdout.flush()

ltx = latex_output( "cross.sage.out.tex" )

ltx.write( 'SIR model:\n', SIR.ode() )

ltx.write( 'classes:\n', classes.ode() ) 

SIR2 = BoxModelProduct( SIR, classes )

ltx.write( 'cross:\n', SIR2.ode() )

ltx.close()

#print 'write tikz boxes'
sys.stdout.flush()

#classes.plot_boxes( 'classes.boxes.tex', figsize=(5,5) )
classes.plot().save( filename='classes.boxes.crop.svg', figsize=(5,5) )

try:
    SIR2.plot_boxes( 'SIR2.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    SIR2.plot().save( filename='SIR2.boxes.crop.svg', figsize=(5,5) )
</source-file>

<project-file filename=cross.sage.out.html/>

<project-file filename=classes.boxes.crop.svg/>

<project-file filename=SIR2.boxes.crop.svg/>

## The $$\beta$$ problem

<source-file filename=beta.sage.step lang=sage>
# requires: boxmodel.py boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# produces: beta.sage.out.tex beta.boxes.tex SI.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from boxmodelproduct import *
from latex_output import *

#print 'make SI model'
sys.stdout.flush()

S, I, beta = SR.var( 'S I beta' )
SI = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I] )

save_session( 'SI.sobj' )

#print 'make classes model'
sys.stdout.flush()

a, b, rho, sigma = SR.var( 'a b rho sigma' )
classes = BoxModel( DiGraph( { a:{ b:rho }, b:{ a:sigma } } ), [a,b] )

#print 'write latex'
sys.stdout.flush()

ltx = latex_output( "beta.sage.out.tex" )

ltx.write( 'SI model:\n', SI.ode() )

ltx.write( 'classes:\n', classes.ode() ) 

SIcross = BoxModelProduct( SI, classes )

ltx.write( 'cross:\n', SIcross.ode() )

SI2 = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[S,I] } )
SI2cross = BoxModelProduct( SI2, classes )

ltx.write( 'cross with double-indexing:', SI2cross.ode() )

SIx = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[(S,deps.index),(I,deps.sumover)] } )
SIxcross = BoxModelProduct( SIx, classes )

ltx.write( 'and the cross with correct double-indexing:', SIxcross.ode() )

ltx.close()

#print 'write tikz boxes'
sys.stdout.flush()

try:
    SIxcross.plot_boxes( 'beta.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    SIxcross.plot().save( filename='beta.boxes.crop.svg', figsize=(5,5) )
</source-file>

<project-file filename=beta.sage.out.html/>

<project-file filename=beta.boxes.crop.svg/>

## The Adler averaging result

Fred Adler ([1992](http://www.sciencedirect.com/science/article/pii/002555649290080G)) has studied an SI model:

$$\frac{dI_i}{dt} = (\beta\sum_{j=1}^n \lambda_{ij}I_j) S_i$$

$$S_i = T_i - I_i$$

(which is in fact the Rushton-Mautner model, seen in the $$\beta$$ section above).

Adler's result is that removing structure by averaging classes $$i$$ together
can only decrease or preserve the reproduction ration $$R_0$$, that is, that
$$R_0$$ is nondecreasing with diversity of the box model.  I'd like to
reproduce that result in our cross-product framework.

So we begin with a basic SI model, as the horizontal structure for our crosses:

<source-file filename=adler-SI.sage.step display=adler-SI.boxes.crop.svg>
# requires: boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# produces: adler-SI.boxes.tex adler-SI.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
import boxmodel

S, I, beta = SR.var( 'S I beta' )
lb = SR.symbol( 'lambda' )
SI = boxmodel.BoxModel( DiGraph( { S:{ I:lb*beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[], lb:[(S,boxmodel.deps.index), (I,boxmodel.deps.sumover)] } )

SI.plot_boxes( 'adler-SI.boxes.tex', figsize=(5,5) )

save_session( 'adler-SI' )
</source-file>

and cross with a given mixing matrix $$\Lambda$$:

<source-file filename=adler_mixing.py.step lang=py>
# requires: boxmodel.py $(SageDynamics)/dynamicalsystems.py
# produces:
import sys, os
#sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
from sage.all import *
import dynamicalsystems
import boxmodel

def mixing_model( Lambda ):
    # Lambda must be a square matrix;
    # or a number of states, in case we want to provide the mixing rates later
    try:
	dim = Lambda.ncols()
	if not Lambda.is_square():
	    # note is_square() actually succeeds if Lambda is a number
	    # but ncols() doesn't
	    raise ValueError( "matrix in mixing_model() must be square" )
        l_in = dynamicalsystems.indexer_2d( 'lambda' )
	bindings = dynamicalsystems.Bindings( {
	    l_in[i][j] : Lambda[i, j] for i in range(dim) for j in range(dim)
	} )
    except AttributeError: # not a matrix
	dim = Lambda
	bindings = dynamicalsystems.Bindings()
    # create disconnected graph of that many vertices
    # and bind the lambda values
    return boxmodel.BoxModel(
	DiGraph( { i:[] for i in range(dim) } ),
	bindings = bindings
    )
</source-file>

For example:

<source-file filename=adler-example.sage.step display=adler-example.boxes.crop.svg>
# requires: boxmodel.py boxmodelproduct.py $(SageDynamics)/dynamicalsystems.py
# requires: adler_mixing.py
# requires: adler-SI.sobj
# produces: adler-example.boxes.tex adler-example.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
#sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import boxmodel, boxmodelproduct
import adler_mixing

load_session( 'adler-SI' )

L2 = adler_mixing.mixing_model( 2 )

example = boxmodelproduct.BoxModelProduct( SI, L2 )

try:
    example.plot_boxes( 'adler-example.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    example.plot().save( filename='adler-example.boxes.crop.svg', figsize=(5,5) )
save_session( 'adler-example' )
</source-file>

In this class of models, the total size of each mixing class
$$T_i=S_i+I_i$$ is conserved.

An average over mixing classes $$i$$ is defined by replacing the groups of
the vertical model, $$G_i$$, by some smaller set of groups with

$$\bar{G}_s = \cup_{i\in\sigma_s}G_i$$,

where $$\{\sigma_s\}$$ is a partition of the non-averaged groups
$$\{1,\ldots,i,\ldots,n\}$$.

In the averaged model, the mixing rates $$\lambda_{ij}$$ are replaced by

$$b_{st} = \frac{\sum_{i\in\sigma_s}\sum_{j\in\sigma_t}T_i\lambda_{ij}T_j}{\bar{T}_s\bar{T}_t}$$.

The result is that

* _If the mixing matrix is symmetric and primitive, then the leading eigenvalue
of the Jacobian matrix associated with the combined system is less than or
equal to that associated with the full system._

This eigenvalue is closely related to the value of $$R_0$$, so it defines
the direction of change of the initial rate of infection.

We should be able to study the infection rate more or less directly...

<source-file filename=adler-R0.sage.step display=adler-R0.sage.out.html>
# requires: boxmodel.py $(SageDynamics)/dynamicalsystems.py
# requires: $(SageUtils)/latex_output.py
# requires: adler-example.sobj
# produces: adler-R0.sage.out.tex adler-R0.sobj
import sys
import os
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import boxmodel
#import adler_mixing

# pickling bug
lb = SR.symbol( 'lambda' )
[ dynamicalsystems.subscriptedsymbol( lb, i, j ) for i in (0,1) for j in (0,1) ]

load_session( 'adler-example' )

ltx = latex_output( "adler-R0.sage.out.tex" )

ODE2 = example.ode()

ltx.write( ODE2 )

#ltx.write( 'equilibria are:' )
#ltx.write_block( ODE2.equilibria() )
ltx.write( 'We are interested in the rate of infection near the boundary state' )

dfeq = dict( [
	( s, SR.symbol( str(s).replace('S','T') ) )
	for s in example._aggregate_variables[SR('S')]
    ] + [
	( i, SR(0) )
	for i in example._aggregate_variables[SR('I')]
    ] )
print dfeq

ltx.write_equality( vector( ODE2._vars ), vector( [ dfeq[v] for v in ODE2._vars ] ) )

dfjac = ODE2.jacobian_matrix( at=dfeq )

ltx.write( 'The Jacobian there is' )
ltx.write_block( dfjac )

dfepss = dict( [
	( s, - SR.symbol( str(s).replace('S','\epsilon') ) )
	for s in example._aggregate_variables[SR('S')]
    ] + [
	( i, SR.symbol( str(i).replace('I','\epsilon') ) )
	for i in example._aggregate_variables[SR('I')]
    ] )
dfeps = vector( [ dfepss[v] for v in ODE2._vars ] )

ltx.write( 'In the linearization there, the growth rate in the direction' )
ltx.write_block( dfeps )

ltx.write( 'is' )

growth_vector = (dfjac * dfeps).simplify()
ltx.write_block( growth_vector )

gr_dict = { v:gv for v,gv in zip(ODE2._vars, growth_vector) }
gr_I = reduce( lambda x,y: x+y, (gr_dict[i] for i in example._aggregate_variables[SR('I')]) )
ltx.write( 'so that the growth rate of $I = I_0+I_1$ is $', gr_I, '$.' )

ltx.write( '\n\nMeanwhile, the eigenvalues of the Jacobian there are' )
ltx.write_block( dfjac.eigenvalues() )

ltx.close()

save_session( 'adler-R0' )
</source-file>


## BoxModel class

Here's a class to represent a box model, and a class to implement the cross
product. The BoxModel class constructs itself from a directed graph whose
vertices and arrows are symbolic expressions (state variables and flow rates),
and can draw itself as a directed graph and translate itself to an ODE.

<source-file filename=boxmodel.py.step lang=python>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageAdaptiveDynamics)/adaptivedynamics.py
from sage.all import *
import os
import sys
 
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import latex_output

from sage.misc.latex import _latex_file_
#from sage.symbolic.relation import solve
from sage.symbolic.function_factory import function

# constant 'enum' values for use with indexing
class deps:
    index, sumover = range(0,2)

class BoxModel(SageObject):
    """Parent class for all kinds of box models.
    Note that since this gets its variables from a graph's vertices,
    rather than from indexers, it can't be used in adaptive dynamics.
    Subclasses that generate their boxes, maybe can.
    """
    def __init__(self, graph,
	vars=None,
	parameters=None,
	parameter_dependencies={},
	flow_graph=None,
        bindings=dynamicalsystems.Bindings()):
	# we are given a directed graph whose vertex labels are state
	# variables, representing fractions of total population,
	# and whose edge labels are flow rates.
	self._graph = graph
	self._graph.set_latex_options( edge_labels=True )
	self._graph.set_latex_options( vertex_shape='rectangle' )
	if vars is None:
	    vars = graph.vertices()
	self._vars = vars
	if parameters is None:
	    parameters = set( reduce( union, (r.variables() for f,t,r in graph.edges()), Set([]) ) ).difference( self._vars )
	self._parameters = parameters
	#print 'parameters:', parameters
	self._parameter_dependencies = parameter_dependencies
	for p in self._parameters:
	    if p not in self._parameter_dependencies:
		# infer connections between parameters and compartmentalization
		# for now, simple rule:
		# just connect it to the source variable of its arrow
		# TODO: inference including defined quantities like N
		#print 'infer dependencies for parameter', p
		for v,w,e in self._graph.edges():
		    if p in e.variables():
			pd = [ v ]
			#print 'found', p, 'in arrow', e
			#print 'infer dependency on', v
			if p in self._parameter_dependencies and self._parameter_dependencies[p] != pd:
			    #print 'but already inferred', self._parameter_dependencies[p]
			    #print 'dependencies of parameter', p, 'are unclear, inferring no dependencies'
			    pd = []
			self._parameter_dependencies[p] = pd
	for p, pd in self._parameter_dependencies.items():
	    try: [ d[0] for d in pd ]
	    except: self._parameter_dependencies[p] = [ (d,deps.index) for d in pd ]
	#print 'parameter dependencies:', self._parameter_dependencies
	self._bindings = bindings
	if self._graph.get_pos() is None:
	    self._graph.set_pos( { v:(i,0) for i,v in enumerate(self._vars) } )
	self._flow_graph = self._graph
    def bind(self, bindings):
	bindings = dynamicalsystems.Bindings( bindings )
	# TODO: this will not bind cross product correctly
	return BoxModel(
	    DiGraph( {
	        bindings(v): {
		    bindings(w):bindings(e) for _,w,e in self._flow_graph.outgoing_edge_iterator(v)
	        } for v in self._graph.vertex_iterator()
	    } ),
	    vars = [ bindings(v) for v in self._vars ],
	    parameters = [ bindings(p) for p in self._parameters ],
	    parameter_dependencies = {
		bindings(p):[(bindings(d),t) for d,t in pd] for p,pd in self._parameter_dependencies.items()
	    },
	    flow_graph = DiGraph( {
		bindings(v): {
		    bindings(w):bindings(e) for _,w,e in self._flow_graph.outgoing_edge_iterator(v)
		} for v in self._flow_graph.vertex_iterator()
	    } ),
	    bindings = self._bindings + bindings
	)
    def add_transitions( self, trs ):
	# We take BoxModel to be an immutable object, so this operation
	# returns a new BoxModel.  trs is a list of (source,target,rate)
	# tuples suitable for adding to self._graph (rather than _flow_graph).
	nbm = deepcopy(self)
	nbm._graph.add_edges( trs )
	nbm._flow_graph.add_edges( trs )
	return nbm
    def ode_flow(self):
	flow = { v:0 for v in self._vars }
	#print flow
	for source,target,rate in self._flow_graph.edges():
	    #print source, '-$%s$->'%latex(rate), target
	    flow[source] -= rate
	    flow[target] += rate
	return flow
    def ode(self, time_variable=SR.symbol('t'), bindings=dynamicalsystems.Bindings()):
	return dynamicalsystems.ODESystem(
	    self.ode_flow(),
            self._vars,
	    time_variable,
            bindings = bindings+self._bindings )
    def tikz_boxes( self, raw=False, inline=False ):
	if raw:
	    g = self._graph
	else:
	    g = self._flow_graph
	if inline:
	    g.set_latex_options( graphic_size=(6,6), margins=(0.5,0.5,0.5,0.5) )
	    return '\n\\vspace{24pt}\n' + latex( g ) + '\n\\vspace{24pt}\n'
	return _latex_file_( g, title='' )
    def plot_boxes( self, filename=None, raw=False, inline=False, **options ):
	# new Tikz/SVG code
	#print 'plot to', filename
        LF = open( filename, 'w' )
	LT = self.tikz_boxes( raw, inline )
	LF.write( LT )
        LF.close()
	return LT
    def plot( self, *args, **aargs ):
	def lx(s): return '$%s$'%latex(s)
	lfg = DiGraph( [[lx(s) for s in tup] for tup in self._flow_graph.edge_iterator() ] )
	vargs = {
	    'edge_labels' : True,
	    'pos' : { lx(v) : p for v,p in self._flow_graph.get_pos().items() },
	    'talk' : True
	}
	vargs.update( aargs )
	return lfg.plot( *args, **vargs )
    def micro_transitions( self ):
	# This could produce micro transitions but it isn't right so far
	ltx = latex_output.latex_output_base( latex_output.write_to_string() )
	lines = []
	for source, target, rate in self._flow_graph.edge_iterator():
	    mu = MakeMicro( self, source )
	    ut = mu( rate )
	    print str(ut); sys.stdout.flush()
	    lines += [ r'  & ' + latex(mu.sigma_fn(SR('x'))) + r'\to' + latex(target)
		+ r' \quad\text{ at rate } '
		+ latex( ut )
	    ]
	ltx.write_align( *lines )
	return ltx._output._str

# useful parent class: expression converter that doesn't
# do anything
from sage.symbolic.expression_conversions import SubstituteFunction
class IdentityConverter(SubstituteFunction):
    def __init__(self):
	pass
    def composition(self, ex, operator):
	# override the parent class's function replacing step
	return operator(*map(self, ex.operands()))

class MakeMicro(IdentityConverter):
    _mul = SR('a*b').operator()
    from sage.symbolic.function_factory import function
    delta_fn = function('delta', latex_name=r'\delta')
    sigma_fn = function('sigma', print_latex_func=lambda self, x:r'\sigma_{%s}' % latex(x))
    bm_sum = function( 'sum', print_latex_func=lambda self, x, s, ex:r'\sum_{%s\in %s}%s' %( latex(x), latex(s), latex(ex) ) )
    bm_indicator = function( 'indicator', print_latex_func=lambda self, ev:r'\mathbb{1}\left(%s\right)' % latex(ev) )
    bm_index_param = function( 'bm_index_param' )
    def __init__(self, model, source):
	self._model = model
	self._source = source
	self._working = False
	self._tags = { s : SR.symbol( 'text'+str(s), latex_name=r'\texttt{%s}'%str(s) ) for s in self._model._vars }
    def __call__(self, ex):
	if self._working:
	    return super(MakeMicro,self).__call__(ex)
	self._working = True
	tx = super(MakeMicro,self).__call__( ex / self._source )
	self._working = False
	return (
	   self.bm_indicator( self.sigma_fn( SR.symbol('x') ) == self._tags[self._source] ) *
	   tx.subs( { s : self.bm_sum( SR.symbol('y'), SR.symbol('X'), 1 / SR('N') * self.bm_indicator( self.sigma_fn( SR('y') ) == self._tags[s] ) ) for s in self._model._vars } )
	)
    def arithmetic(self, ex, operator):
	# do special handling to products of things, before processing the
	# things, to catch inner products
	if operator == self._mul:
	    return self.do_inner_product( *ex.operands() )
	else:
	    return reduce( operator, *map(self, ex.operands()) )
    def symbol(self, s):
	return self.do_inner_product( s ) # just in case
    def do_inner_product(self, *args):
	# leave multiplications as is, except in the case of a
	# parameter dependency marked "sumover": convert that from
	# a regular multiplication to an inner product.
	print 'processing product', args
	margs = list(args)
	sumover = []
	dummy_list = ['y', 'z', 'u', 'v', 'w', 's', 't', 'p', 'q', 'r']
	for p,pd in self._model._parameter_dependencies.items():
	    if p in margs:
		print 'found', p, 'in factors:', args
		if all( d in margs + [self._source] for d,x in pd ):
		    print 'found all of its deps', [d for d,x in pd], 'as well'
		    indices_for_p = []
		    p_times = SR(1)
		    for d,ss in pd:
			if ss == deps.sumover:
			    dummy_var = SR.symbol( dummy_list.pop(0) )
			    indices_for_p.append( dummy_var )
			    sumover.append( dummy_var )
			    print 'will sum over', dummy_var, 'in', d; sys.stdout.flush()
			    margs[margs.index(d)] = 1
			    p_times *= self.bm_indicator( self.sigma_fn( dummy_var ) == self._tags[d] )
			    print 'made it through equality'; sys.stdout.flush()
			elif d == self._source:
			    indices_for_p += [SR('x')]
			else:
			    raise ValueError, 'I am confused about dependence on ' + str(d)
		    index_of_p = margs.index(p)
		    margs[index_of_p] = self.bm_index_param( p, *indices_for_p ) * p_times
		    for dv in reversed(sumover):
			margs[index_of_p] = self.bm_sum( dv, SR.symbol('X'), 1 / SR('N') * margs[index_of_p] )
		    margs[index_of_p] = margs[index_of_p].substitute_function(
			self.bm_index_param,
			lambda *args: dynamicalsystems.subscriptedsymbol( *args )
		    )
		    print margs
		else:
		    raise RuntimeError, (
			"Missing parameter dependencies in expression " +
			str( reduce( self._mul, args ) )
		    )
	expr = reduce( self._mul, margs )
	print 'becomes', expr
	return expr
</source-file>

<source-file filename=boxmodelproduct.py.step lang=python>
# requires: boxmodel.py
from sage.all import *
import dynamicalsystems, boxmodel

def flatten( lst ):
    try:
	# nonempty list: flatten recursively
	return flatten( lst[0] ) + flatten( lst[1:] )
    except:
	try:
	    # empty list: return empty list
	    return lst[:]
	except:
	    # not a list: return list of it
	    return [ lst ]

# The general cross product represents its states as tuples of the
# original model's states.  This function can be replaced by another
# one to, for example, make some of these derived compartments synonyms
# for one another, or simply to give them different names.
# This is distinct from a compartment aggregation function, see below,
# which adds compartments together instead of declaring them equivalent.
def default_compartment_renaming(*args):
    return tuple(args)

# A mapping from composite compartment names (tuples) into aggregate
# quantities, for the purpose of summing compartments.  This is distinct
# from a compartment renaming function, above.
def default_compartment_aggregation(*args):
    return tuple(args)

# we make tuples of state variables into combined state variables by
# subscripting the first with the others
def default_vertex_namer( *vtuple ):
    ss = dynamicalsystems.subscriptedsymbol( *vtuple )
    return ss

# and make stratified transitions according to an appropriate rule
def default_edge_stratifier( source, target, rate, i, models, vertex_namer, param_namer, compartment_renaming ):
    """we are given (rate, i, (v, v, ...)) where rate is an expression
    describing a transition of models[i],
    and the vs are the Cartesian product of vertices at the arrow's
    source (not processed by the state combiner).
    This function assumes the rate is a product of parameters and
    state variables, and will do weird and wrong stuff if that's not true."""
    #print 'dealing with rate:', rate
    ## list all compartments involved in the transition rate
    rate_vars = rate.variables()
    import itertools
    ## list all the ways a compartment (of the relevant model) can be stratified
    raw_strats = [ list(vst) for vst in itertools.product( *(models[j]._vars for j in range(len(models)) if j != i) ) ]
    #print 'raw_strats:', raw_strats
    ## make list of all stratifications of all relevant variables
    all_strats = [ [] ]
    for x in models[i]._vars:
	if x in rate_vars or x is source:
	    all_strats = [ str + [ (x,xstr) ] for str in all_strats for xstr in raw_strats ]
    #print 'all_strats:', all_strats
    ## produce a stratified edge for each of those
    edges = []
    for str in all_strats:
	#stup = compartment_renaming( *[ tuple( sstr[:i] + [source] + sstr[i:] ) for x,sstr in str if x is source ][0] )
	stup = bm_state( *compartment_renaming( *[ tuple( sstr[:i] + [source] + sstr[i:] ) for x,sstr in str if x is source ][0] ) )
	#print 'stup, from', [ tuple( sstr[:i] + [source] + sstr[i:] ) for x,sstr in str if x is source ], 'to', stup
	#ttup = compartment_renaming( *[ tuple( sstr[:i] + [target] + sstr[i:] ) for x,sstr in str if x is source ][0] )
	ttup = bm_state( *compartment_renaming( *[ tuple( sstr[:i] + [target] + sstr[i:] ) for x,sstr in str if x is source ][0] ) )
	repl = { x: bm_state( *compartment_renaming( *(xstr[:i] + [x] + xstr[i:]) ) ) for x,xstr in str }
	psubs = reduce( lambda x,y:x+y, (xstr for x,xstr in str) )
        #repl.update( { p: param_namer( [ p ] + psubs ) for p in models[i]._parameters } )
        repl.update( { p: bm_param( *([ p ] + psubs) ) for p in models[i]._parameters } )
	#print 'repl:', repl
        edges += [ ( stup, ttup, rate.subs( repl ) ) ]
    #print 'edges:', edges
    return edges

# function names used by the edge stratifier: we can't put tuples into
# symbolic expressions directly so we represent them by instances like
# bm_state( S, a ), bm_param( beta, S, I ), etc.
from sage.symbolic.function_factory import function
bm_state = function( 'bm_state' )
bm_param = function( 'bm_param' )

def default_vertex_positioner( graph, models, compartment_renaming ):
    directions = [ 0, pi/2, pi/6, pi/3 ] # will add more as needed, I guess
    seq = { v:i for m in models for i,v in enumerate(m._vars) }
    positions = {
	t: [
	    sum(seq[v]*cos(d) for v,d in zip(t.operands(), directions)),
	    - sum(seq[v]*sin(d) for v,d in zip(t.operands(), directions))
        ] for t in graph.vertex_iterator()
    }
    print positions
    return positions
    import itertools
    positions = {
        tuple(a[1] for a in dtup): [
	    sum(a[0]*cos(d) for a,d in zip(dtup,self.directions)),
	    - sum(a[0]*sin(d) for a,d in zip(dtup,self.directions))
        ] for dtup in itertools.product(
	    *[ enumerate(m._vars) for m in models ]
        )
    }

# letter or whatever for making names of states of full cross product,
# when they're used as an intermediate step in a combined-state product
internal_vertex_name_base = None

class BoxModelProduct(boxmodel.BoxModel):
    def __init__(
	    self,
	    *models,
	    **kwargs
	):
	self._models = models
	compartment_renaming =  kwargs.pop( 'compartment_renaming',  default_compartment_renaming )
	vertex_namer =    kwargs.pop( 'vertex_namer',    default_vertex_namer )
	param_namer =     kwargs.pop( 'param_namer',     default_vertex_namer )
	edge_stratifier = kwargs.pop( 'edge_stratifier', default_edge_stratifier )
	vertex_positioner = kwargs.pop( 'vertex_positioner', default_vertex_positioner )
	if kwargs: raise TypeError, "Unknown named arguments to BoxModelProduct: %s" % str(kwargs)

	# TODO: it would be more efficient to iterate one model at a time,
	# and generate the vertex tuples, rate tuples, subscripted state
	# variables, subscripted parameters, and subscripted rates all in
	# the same loop.

	edges = reduce( lambda x,y:x+y, (
	    edge_stratifier( v, w, e, i, models, vertex_namer, param_namer, compartment_renaming )
	    for i in range(len(models)) for v,w,e in models[i]._flow_graph.edge_iterator()
	) )
	print 'edges:', edges
	self._graph = DiGraph( edges )
	print 'edges of graph:', self._graph.edges()

	self._aggregate_tuples = {}
	for vbm in self._graph.vertex_iterator():
	    vs = vbm.operands()
	    for v in vs:
	        self._aggregate_tuples.setdefault(v, []).append( vs )

	if False:
	    # do the cross product of graphs first
	    self._vars = []
	    self._aggregate_variables = {}
            graph_dict = {}
	    vars_combine = {}
            import itertools
            for vst in itertools.product( *(m._vars for m in models) ):
	        # each vst is a vertex of the product graph
	        vs = tuple( flatten( vst ) )
	        vs_combined = compartment_renaming( *vs )
	        vars_combine.setdefault( vs_combined, [] ).append(vs)
	        if vs_combined not in self._vars: self._vars.append(vs_combined)
	        graph_dict.setdefault(vs_combined, {})
	        for i in range(len(vs)):
		    # each vertex has outgoing edges from every graph
	            #mip = MarkInnerProducts( models[i]._parameter_dependencies )
	            for v,w,rate in models[i]._graph.outgoing_edges(vs[i]):
		        ws = list(vs)
		        ws[i] = w
		        #iprate = mip(rate) # this is being done redundantly
		        #print 'marked inner products:', rate, '-->', iprate
		        erate = [rate, i, vs]
		        ws_combined = compartment_renaming( *ws )
		        graph_dict[vs_combined].setdefault(tuple(ws_combined),[]).append(tuple(erate))
		    self._aggregate_variables.setdefault(vs[i], []).append( vs_combined )
	    print 'graph dict is', graph_dict
	    #bm_tmp_sum = sage.symbolic.function_factory.function( 'bm_tmp_sum' )
	    self._graph = DiGraph( { v:{w:tuple(el) for w,el in vd.items() } for v,vd in graph_dict.items() } )

	self._graph.set_latex_options( edge_labels=True, vertex_shape='rectangle' )
	#for v in self._graph.vertices():
	#    for _,w,el in self._graph.outgoing_edges(v):
	#	print v,w,el

	# graphical positions of graph vertices
	positions = vertex_positioner( self._graph, models, compartment_renaming )
	self._graph.set_pos( positions )

	# now for consumption by humans and math software, we map vertex
	# tuples to regular variable names with subscripts
	bm_to_vars = lambda e: e.substitute_function( bm_state, vertex_namer).substitute_function( bm_param, param_namer )
        flow_edges = [
	    [ bm_to_vars(v), bm_to_vars(w), bm_to_vars(e) ]
	    for v, w, e in edges
	]
	print 'flow edges:', flow_edges
	print self._aggregate_tuples
	self._aggregate_variables = {
	    k:[vertex_namer(*v) for v in vl]
	    for k,vl in self._aggregate_tuples.iteritems()
	}

	if False: # skip this for now
	    ## maintain inverse image of each aggregate compartment
	    print 'vars combine:', vars_combine
	    if not any( len(v) > 1 for v in vars_combine.values() ):
	        evn = vertex_namer
	        esc = compartment_renaming
	        vars_combine = None
	    else:
	        global internal_vertex_name_base
	        if internal_vertex_name_base is None:
	            #internal_vertex_name_base = SR.symbol()
	            internal_vertex_name_base = 'X'
	        print 'do internal state variables,', internal_vertex_name_base
	        evn = lambda args: dynamicalsystems.subscriptedsymbol(
		    internal_vertex_name_base,
		    *args
	        )
	        esc = default_compartment_renaming
	    flow_dict = {
	        vertex_namer(v):{
		    vertex_namer(w):sum(edge_renamer(e, models, evn, param_namer, esc ) for e in el)
		    for vv,w,el in self._graph.outgoing_edges(v)
	        } for v in self._graph.vertices()
	    }
            if vars_combine is not None:
	        # do substitutions to make the aggregate rates
	        vc_eqns, vc_symbols = [], []
	        vc_subs = dynamicalsystems.Bindings()
	        for v,c in vars_combine.items():
		    print 'will combine', sum( evn(zv) for zv in c ), '==', vertex_namer(v)
		    vc_symbols.append( evn(c[0]) )
		    vc_eqns.append( evn(c[0]) == vertex_namer(v) - sum( evn(zv) for zv in c[1:] ) )
	        nfd = {}
	        for v, ve in flow_dict.items():
		    nfd[v] = {}
		    for w, e in ve.items():
		        sym = SR.symbol()
		        print e,
		        solns = solve( [ sym == e ] + vc_eqns, sym, *vc_symbols, solution_dict=True )
		        #print 'solve', [ sym == e ] + vc_eqns, ',', [sym] + vc_symbols, '\n  ', solns
		        if len(solns) == 1:
		            #print '  ', maxima(sym), [str(k) == str(sym) for k in solns[0].keys()]
		            el = [ex for k,ex in solns[0].items() if str(k) == str(sym)]
		            print '==>', el[0]
			    nfd[v][w] = el[0]
		        else:
		            raise RuntimeError, 'Could not simplify expression ' + str(e) + ':' + str(solns)
	        flow_dict = nfd
	        self._vc_eqns = vc_eqns
	    self._flow_graph = DiGraph( flow_dict )

	self._flow_graph = DiGraph( flow_edges )
	self._flow_graph.set_latex_options( edge_labels=True, vertex_shape='rectangle' )
	self._flow_graph.set_pos( { bm_to_vars(v):pos for v,pos in positions.items() } )

	# make list of variables, in order, by taking product
        import itertools
	varset = set()
	self._vars = []
	for vs in itertools.product( *(m._vars for m in models) ):
	    v = vertex_namer( *compartment_renaming( *vs ) )
	    if v not in varset:
		varset.add(v)
		self._vars.append(v)

	# now generate all the crossed parameters
	# TODO: do this right
	self._parameters = set( reduce( union, (r.variables() for f,t,r in self._flow_graph.edges()) ) ).difference( self._vars )
	#print 'parameters:', self._parameters

	# TODO: inherit bindings in a smart way?
	self._bindings = dynamicalsystems.Bindings()

	#self._aggregate_variables = {
	#    k : [ vertex_namer(vs) for vs in v ]
	#    for k,v in self._aggregate_variables.items()
	#}
	self._vertex_namer = vertex_namer
	self._param_namer = param_namer
    def add_transitions( self, trs ):
	# it's an immutable object, so this operation
	# returns a new BoxModel.  trs is a list of (source,target,rate)
	# tuples suitable for adding to self._graph (rather than _flow_graph).
	fg = deepcopy(self._flow_graph)
	bm_to_vars = lambda e: e.substitute_function( bm_state, self._vertex_namer).substitute_function( bm_param, self._param_namer )
	fg.add_edges( [ (bm_to_vars(v), bm_to_vars(w), bm_to_vars(e)) for v,w,e in trs ] )
	return boxmodel.BoxModel(
	    fg,
	    vars = self._vars,
	    bindings = self._bindings
        )
    def bind(self, bindings):
	bindings = dynamicalsystems.Bindings( bindings )
	# TODO: this produces a regular BoxModel, destroys information
	# about the cross product
	return boxmodel.BoxModel(
	    self._flow_graph,
	    vars = [ bindings(v) for v in self._vars ],
	    parameters = [ bindings(p) for p in self._parameters ],
	    #parameter_dependencies = {
	    #	bindings(p):[(bindings(d),t) for d,t in pd] for p,pd in self._parameter_dependencies.items()
	    #},
	    flow_graph = DiGraph( {
		bindings(v): {
		    bindings(w):bindings(e) for _,w,e in self._flow_graph.outgoing_edge_iterator(v)
		} for v in self._flow_graph.vertex_iterator()
	    } ),
	    bindings = self._bindings + bindings
	)

def cross( *models ):
    return BoxModelProduct( *models )

def x_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'X', *ss )

def power_compartment_renaming( s, pos, *ss ): # e.g. transform (S, 2, I) to (I, S)
    cs = list( ss )
    print 'power, combine:', s, pos, ss
    cs.insert( int(pos)-1, s )
    #print 'combine', s, pos, ss, ':', tuple(cs)
    return tuple(cs)

def power_edge_stratifier( source, target, rate, i, models, vertex_namer, param_namer, compartment_renaming ):
    ## the power model has all the edges of the cross
    edges = default_edge_stratifier( source, target, rate, i, models, vertex_namer, param_namer, compartment_renaming )
    ## plus extra edges for within-group interactions.
    ## I don't even want to think about interactions of more than two
    ## classes, which could be partly within-group and partly between-groups.
    ## The case we handle is a transition from stratified source to
    ## similarly stratified target, due to interactions within the
    ## source compartment
    print 'within-pair interactions for', rate
    import itertools
    strats = [ list(vst) for vst in itertools.product( *(models[j]._vars for j in range(len(models)) if j is not i) ) ]
    for str in strats:
	print 'strat:', str
	stup = bm_state( *compartment_renaming( *(str[:i] + [source] + str[i:]) ) )
        ttup = bm_state( *compartment_renaming( *(str[:i] + [target] + str[i:]) ) )
	#repl = { source: vertex_namer( stup ) }
	repl = { source: stup }
	for x in models[i]._vars:
	    if x is not source:
		if x in str:
		    repl[x] = 1
		else:
		    repl[x] = 0
	## note params are stratified differently here than in the default
	## transitions - only one set of subscripts
	#repl.update( { p: param_namer( [p] + str ) for p in models[i]._parameters } )
	repl.update( { p: bm_param( *([p] + str) ) for p in models[i]._parameters } )
	rrate = rate.subs( repl )
	if rrate != 0:
	    edges += [ ( stup, ttup, rrate ) ]
    return edges

def power( model, i ):
    # require i=2 for now
    i_model = boxmodel.BoxModel( DiGraph( { j+1:[] for j in range(i) } ), [1,2] )
    empty_model = boxmodel.BoxModel( DiGraph( { v:[] for v in model._vars } ), model._vars )
    return BoxModelProduct( model, i_model, empty_model,
	vertex_namer = x_namer,
	compartment_renaming = power_compartment_renaming,
	edge_stratifier = power_edge_stratifier
    )
</source-file>

<source-file filename=upstream.mk>
# Makefile to connect the Sage code here with the code in SageDynamics

# the three upstream projects are all bundled into one git repo
export SageUtils            = $(realpath $(SageDynamicsRepo)/SageUtils)
export SageDynamics         = $(realpath $(SageDynamicsRepo)/SageDynamics)
export SageAdaptiveDynamics = $(realpath $(SageDynamicsRepo)/SageAdaptiveDynamics)

# When we need something from the upstream projects, make it there
$(SageDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageDynamics) $*

$(SageAdaptiveDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageAdaptiveDynamics) $*

# The good makefile stuff is upstream, just reuse it
-include $(SageUtils)/sage.mk
-include $(SageUtils)/step.mk
</source-file>

