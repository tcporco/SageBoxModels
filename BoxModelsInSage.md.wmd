---
layout: page
title: Box Models in Sage
wmd_project: Box_Models
wmd_prerequisite_projects:
  SageDynamicsRepo: SageDynamicsRepo
---

This is a preliminary stab at automating construction of compartment (box)
models in Sage.

The BoxModel and BoxModelProduct classes are at the end of this page.

## Test by making an SIR model

<source-file filename="SIR.sage.step">
# requires: boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIR.sage.out.tex SIR.boxes.tex SIR.trajectory.png SIR.sobj
import os
import sys
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from latex_output import *

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SIR = BoxModel( DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ), [S,I,R] )

save_session( 'SIR.sobj' )

ltx = latex_output( "SIR.sage.out.tex" )

SIRode = SIR.ode()

ltx.write( 'SIR model:\n', SIRode )

ltx.close()

SIR.plot_boxes( 'SIR.boxes.tex', figsize=(5,5) )

epsilon = 0.01 # initial infectious pop
trajectory = SIRode.bind( { mu:0.1, alpha:1 } ).solve( [1-epsilon,epsilon,0], end_time=80 )
#trajectory.plot( 't', [S,I,R], filename='SIR.trajectory.png', figsize=(5,5) )
P = ( trajectory.plot( 't', S, color='blue', legend_label='$S$' )
    + trajectory.plot( 't', I, color='red', legend_label='$I$' )
    + trajectory.plot( 't', R, color='green', legend_label='$R$' )
)
P.save( filename='SIR.trajectory.png', figsize=(5,4), legend_loc='upper right' )

sys.exit(0r)
</source-file>

<project-file filename="SIR.sage.out.html"/>

<project-file filename="SIR.boxes.crop.svg"/>

<project-file filename="SIR.trajectory.png"/>

## test the cross product

<source-file filename=cross.sage.step lang=sage>
# requires: boxmodel.py boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: cross.sage.out.tex classes.boxes.tex SIR2.boxes.tex
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from boxmodelproduct import *
from latex_output import *

#print 'make SIR model'
sys.stdout.flush()

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )
SIR = BoxModel( DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ), [S,I,R] )

#print 'make classes model'
sys.stdout.flush()

A, B, a, b = SR.var( 'A B a b' )
classes = BoxModel( DiGraph( { A:{ B:A*a }, B:{ A:B*b } } ), [A,B] )

#print 'write latex'
sys.stdout.flush()

ltx = latex_output( "cross.sage.out.tex" )

ltx.write( 'SIR model:\n', SIR.ode() )

ltx.write( 'classes:\n', classes.ode() ) 

SIR2 = BoxModelProduct( SIR, classes )

ltx.write( 'cross:\n', SIR2.ode() )

ltx.close()

#print 'write tikz boxes'
sys.stdout.flush()

#classes.plot_boxes( 'classes.boxes.tex', figsize=(5,5) )
classes.plot().save( filename='classes.boxes.crop.svg', figsize=(5,5) )

try:
    SIR2.plot_boxes( 'SIR2.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    SIR2.plot().save( filename='SIR2.boxes.crop.svg', figsize=(5,5) )
</source-file>

<project-file filename=cross.sage.out.html/>

<project-file filename=classes.boxes.crop.svg/>

<project-file filename=SIR2.boxes.crop.svg/>

## The $$\beta$$ problem

<source-file filename=beta.sage.step lang=sage>
# requires: boxmodel.py boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# produces: beta.sage.out.tex beta.boxes.tex SI.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
from boxmodel import *
from boxmodelproduct import *
from latex_output import *

#print 'make SI model'
sys.stdout.flush()

S, I, beta = SR.var( 'S I beta' )
SI = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I] )

save_session( 'SI.sobj' )

#print 'make classes model'
sys.stdout.flush()

a, b, rho, sigma = SR.var( 'a b rho sigma' )
classes = BoxModel( DiGraph( { a:{ b:rho }, b:{ a:sigma } } ), [a,b] )

#print 'write latex'
sys.stdout.flush()

ltx = latex_output( "beta.sage.out.tex" )

ltx.write( 'SI model:\n', SI.ode() )

ltx.write( 'classes:\n', classes.ode() ) 

SIcross = BoxModelProduct( SI, classes )

ltx.write( 'cross:\n', SIcross.ode() )

SI2 = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[S,I] } )
SI2cross = BoxModelProduct( SI2, classes )

ltx.write( 'cross with double-indexing:', SI2cross.ode() )

SIx = BoxModel( DiGraph( { S:{ I:beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[(S,deps.index),(I,deps.sumover)] } )
SIxcross = BoxModelProduct( SIx, classes )

ltx.write( 'and the cross with correct double-indexing:', SIxcross.ode() )

ltx.close()

#print 'write tikz boxes'
sys.stdout.flush()

try:
    SIxcross.plot_boxes( 'beta.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    SIxcross.plot().save( filename='beta.boxes.crop.svg', figsize=(5,5) )
</source-file>

<project-file filename=beta.sage.out.html/>

<project-file filename=beta.boxes.crop.svg/>

## The Adler averaging result

Fred Adler ([1992](http://www.sciencedirect.com/science/article/pii/002555649290080G)) has studied an SI model:

$$\frac{dI_i}{dt} = (\beta\sum_{j=1}^n \lambda_{ij}I_j) S_i$$

$$S_i = T_i - I_i$$

(which is in fact the Rushton-Mautner model, seen in the $$\beta$$ section above).

Adler's result is that removing structure by averaging classes $$i$$ together
can only decrease or preserve the reproduction ration $$R_0$$, that is, that
$$R_0$$ is nondecreasing with diversity of the box model.  I'd like to
reproduce that result in our cross-product framework.

So we begin with a basic SI model, as the horizontal structure for our crosses:

<source-file filename=adler-SI.sage.step display=adler-SI.boxes.crop.svg>
# requires: boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# produces: adler-SI.boxes.tex adler-SI.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
import boxmodel

S, I, beta = SR.var( 'S I beta' )
lb = SR.symbol( 'lmbda', latex_name='lambda' )
SI = boxmodel.BoxModel( DiGraph( { S:{ I:lb*beta*S*I } } ), [S,I],
	parameter_dependencies={ beta:[], lb:[(S,boxmodel.deps.index), (I,boxmodel.deps.sumover)] } )

SI.plot_boxes( 'adler-SI.boxes.tex', figsize=(5,5) )

save_session( 'adler-SI' )
</source-file>

and cross with a given mixing matrix $$\Lambda$$:

<source-file filename=adler_mixing.py.step lang=py>
# requires: boxmodel.py $(SageDynamics)/dynamicalsystems.py
# produces:
import sys, os
#sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
from sage.all import *
import dynamicalsystems
import boxmodel

def mixing_model( Lambda ):
    # Lambda must be a square matrix;
    # or a number of states, in case we want to provide the mixing rates later
    try:
	dim = Lambda.ncols()
	if not Lambda.is_square():
	    # note is_square() actually succeeds if Lambda is a number
	    # but ncols() doesn't
	    raise ValueError( "matrix in mixing_model() must be square" )
        l_in = dynamicalsystems.indexer_2d( 'lambda' )
	bindings = dynamicalsystems.Bindings( {
	    l_in[i][j] : Lambda[i, j] for i in range(dim) for j in range(dim)
	} )
    except AttributeError: # not a matrix
	dim = Lambda
	bindings = dynamicalsystems.Bindings()
    # create disconnected graph of that many vertices
    # and bind the lambda values
    return boxmodel.BoxModel(
	DiGraph( { i:[] for i in range(dim) } ),
	bindings = bindings
    )
</source-file>

For example:

<source-file filename=adler-example.sage.step display=adler-example.boxes.crop.svg>
# requires: boxmodel.py boxmodelproduct.py $(SageDynamics)/dynamicalsystems.py
# requires: adler_mixing.py
# requires: adler-SI.sobj
# produces: adler-example.boxes.tex adler-example.sobj
import sys
#print 'init'; sys.stdout.flush()
import os
#sys.path.append( os.environ['SageUtils'] )
#from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import boxmodel, boxmodelproduct
import adler_mixing

load_session( 'adler-SI' )

L2 = adler_mixing.mixing_model( 2 )

example = boxmodelproduct.BoxModelProduct( SI, L2 )

try:
    example.plot_boxes( 'adler-example.boxes.tex', figsize=(5,5) )
except NotImplementedError:
    example.plot().save( filename='adler-example.boxes.crop.svg', figsize=(5,5) )
save_session( 'adler-example' )
</source-file>

In this class of models, the total size of each mixing class
$$T_i=S_i+I_i$$ is conserved.

An average over mixing classes $$i$$ is defined by replacing the groups of
the vertical model, $$G_i$$, by some smaller set of groups with

$$\bar{G}_s = \cup_{i\in\sigma_s}G_i$$,

where $$\{\sigma_s\}$$ is a partition of the non-averaged groups
$$\{1,\ldots,i,\ldots,n\}$$.

In the averaged model, the mixing rates $$\lambda_{ij}$$ are replaced by

$$b_{st} = \frac{\sum_{i\in\sigma_s}\sum_{j\in\sigma_t}T_i\lambda_{ij}T_j}{\bar{T}_s\bar{T}_t}$$.

The result is that

* _If the mixing matrix is symmetric and primitive, then the leading eigenvalue
of the Jacobian matrix associated with the combined system is less than or
equal to that associated with the full system._

This eigenvalue is closely related to the value of $$R_0$$, so it defines
the direction of change of the initial rate of infection.

We should be able to study the infection rate more or less directly...

<source-file filename=adler-R0.sage.step display=adler-R0.sage.out.html>
# requires: boxmodel.py $(SageDynamics)/dynamicalsystems.py
# requires: $(SageUtils)/latex_output.py
# requires: adler-example.sobj
# produces: adler-R0.sage.out.tex adler-R0.sobj
import sys
import os
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import boxmodel
#import adler_mixing

# pickling bug
lb = SR.symbol( 'lmbda', latex_name=r'\lambda' )
[ dynamicalsystems.subscriptedsymbol( lb, i, j ) for i in (0,1) for j in (0,1) ]

load_session( 'adler-example' )

ltx = latex_output( "adler-R0.sage.out.tex" )

ODE2 = example.ode()

ltx.write( ODE2 )

#ltx.write( 'equilibria are:' )
#ltx.write_block( ODE2.equilibria() )
ltx.write( 'We are interested in the rate of infection near the boundary state' )

dfeq = dict( [
	( s, SR.symbol( str(s).replace('S','T') ) )
	for s in example._aggregate_variables[SR('S')]
    ] + [
	( i, SR(0) )
	for i in example._aggregate_variables[SR('I')]
    ] )
print dfeq

ltx.write_equality( vector( ODE2._vars ), vector( [ dfeq[v] for v in ODE2._vars ] ) )

dfjac = ODE2.jacobian_matrix( at=dfeq )

ltx.write( 'The Jacobian there is' )
ltx.write_block( dfjac )

dfepss = dict( [
	( s, - SR.symbol( str(s).replace('S','\epsilon') ) )
	for s in example._aggregate_variables[SR('S')]
    ] + [
	( i, SR.symbol( str(i).replace('I','\epsilon') ) )
	for i in example._aggregate_variables[SR('I')]
    ] )
dfeps = vector( [ dfepss[v] for v in ODE2._vars ] )

ltx.write( 'In the linearization there, the growth rate in the direction' )
ltx.write_block( dfeps )

ltx.write( 'is' )

growth_vector = (dfjac * dfeps).simplify()
ltx.write_block( growth_vector )

gr_dict = { v:gv for v,gv in zip(ODE2._vars, growth_vector) }
gr_I = reduce( lambda x,y: x+y, (gr_dict[i] for i in example._aggregate_variables[SR('I')]) )
ltx.write( 'so that the growth rate of $I = I_0+I_1$ is $', gr_I, '$.' )

ltx.write( '\n\nMeanwhile, the eigenvalues of the Jacobian there are' )
ltx.write_block( dfjac.eigenvalues() )

ltx.close()

save_session( 'adler-R0' )
</source-file>


## BoxModel class

Here's a class to represent a box model, and a class to implement the cross
product. The BoxModel class constructs itself from a directed graph whose
vertices and arrows are symbolic expressions (state variables and flow rates),
and can draw itself as a directed graph and translate itself to an ODE.

<source-file filename=boxmodel.py.step lang=python>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageAdaptiveDynamics)/adaptivedynamics.py
from sage.all import *
import os
import sys
 
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
import dynamicalsystems
import latex_output

from sage.misc.latex import _latex_file_
#from sage.symbolic.relation import solve
from sage.symbolic.function_factory import function

# constant 'enum' values for use with indexing
class deps:
    index, sumover = range(0,2)

class BoxModel(SageObject):
    """Parent class for all kinds of box models.
    Note that since this gets its variables from a graph's vertices,
    rather than from indexers, it can't be used in adaptive dynamics.
    Subclasses that generate their boxes, maybe can.
    """
    def __init__(self, graph,
	vars=None,
	parameters=None,
	parameter_dependencies={},
	flow_graph=None,
        bindings=dynamicalsystems.Bindings()):
	# we are given a directed graph whose vertex labels are state
	# variables, representing fractions of total population,
	# and whose edge labels are flow rates.
	try:
	    graph.edge_iterator()
	except AttributeError:
	    graph = DiGraph(graph)
	self._graph = graph
	self._graph.set_latex_options( edge_labels=True )
	self._graph.set_latex_options( vertex_shape='rectangle' )
	if vars is None:
	    vars = graph.vertices()
	self._vars = vars
	if parameters is None:
	    # avoid namespace confusion with boxmodelproduct.union
	    parameters = reduce( lambda x,y: x.union(y), (r.variables() for f,t,r in graph.edges()), set([]) ).difference( self._vars )
	self._parameters = parameters
	#print 'parameters:', parameters
	self._parameter_dependencies = parameter_dependencies
	for p in self._parameters:
	    if p not in self._parameter_dependencies:
		# infer connections between parameters and compartmentalization
		# for now, simple rule:
		# just connect it to the source variable of its arrow
		# TODO: inference including defined quantities like N
		#print 'infer dependencies for parameter', p
		for v,w,e in self._graph.edges():
		    if p in e.variables():
			pd = [ v ]
			#print 'found', p, 'in arrow', e
			#print 'infer dependency on', v
			if p in self._parameter_dependencies and self._parameter_dependencies[p] != pd:
			    #print 'but already inferred', self._parameter_dependencies[p]
			    #print 'dependencies of parameter', p, 'are unclear, inferring no dependencies'
			    pd = []
			self._parameter_dependencies[p] = pd
	for p, pd in self._parameter_dependencies.items():
	    try: [ d[0] for d in pd ]
	    except: self._parameter_dependencies[p] = [ (d,deps.index) for d in pd ]
	#print 'parameter dependencies:', self._parameter_dependencies
	self._bindings = bindings
	if self._graph.get_pos() is None:
	    self._graph.set_pos( { v:(i,0) for i,v in enumerate(self._vars) } )
	if flow_graph is None:
	    flow_graph = self._graph
	self._flow_graph = flow_graph
    def bind(self, *args, **vargs):
	bindings = dynamicalsystems.Bindings( *args, **vargs )
	# TODO: this will not bind cross product correctly
	bound_flow_graph = DiGraph( [
	        (bindings(v),bindings(w),bindings(e)) for v,w,e in self._flow_graph.edge_iterator()
	    ],
	    multiedges=True,
	    pos = { bindings(v):p for v,p in self._flow_graph.get_pos().items() } if self._flow_graph.get_pos() is not None else None
	)
	return BoxModel(
	    bound_flow_graph,
	    vars = [ bindings(v) for v in self._vars ],
	    parameters = [ bindings(p) for p in self._parameters ],
	    parameter_dependencies = {
		bindings(p):[(bindings(d),t) for d,t in pd] for p,pd in self._parameter_dependencies.items()
	    },
	    flow_graph = bound_flow_graph,
	    bindings = self._bindings + bindings
	)
    def add_transitions( self, trs ):
	# We take BoxModel to be an immutable object, so this operation
	# returns a new BoxModel.  trs is a list of (source,target,rate)
	# tuples suitable for adding to self._graph (rather than _flow_graph).
	nbm = deepcopy(self)
	nbm._graph.add_edges( trs )
	if self._flow_graph is not self._graph:
	    nbm._flow_graph.add_edges( trs )
	return nbm
    def ode_flow(self):
	flow = { v:0 for v in self._vars }
	#print flow
	for source,target,rate in self._flow_graph.edges():
	    #print source, '-$%s$->'%latex(rate), target
	    flow[source] -= rate
	    flow[target] += rate
	return flow
    def ode(self, time_variable=SR.symbol('t'), bindings=dynamicalsystems.Bindings()):
	return dynamicalsystems.ODESystem(
	    self.ode_flow(),
            self._vars,
	    time_variable,
            bindings = bindings+self._bindings )
    def tikz_boxes( self, raw=False, inline=False, figsize=(6,6), **options ):
	if raw:
	    g = self._graph
	else:
	    g = self._flow_graph
	lopts = {
	    'graphic_size': figsize,
	    'edge_thickness': 0.02,
	    'edge_labels': True
	}
	if inline:
	    lopts['margins'] = (0.5,0.5,0.5,0.5)
	lopts.update( options )
	g.set_latex_options( **lopts )
	if inline:
	    return '\n\\vspace{24pt}\n' + latex( g ) + '\n\\vspace{24pt}\n'
	return _latex_file_( g, title='' )
    def plot_boxes( self, filename=None, raw=False, inline=False, **options ):
	# new Tikz/SVG code
	#print 'plot to', filename
        LF = open( filename, 'w' )
	LT = self.tikz_boxes( raw, inline, **options )
	LF.write( LT )
        LF.close()
	return LT
    def plot( self, *args, **aargs ):
	def lx(s): return '$%s$'%latex(s)
	lfg = DiGraph(
	    [[lx(s) for s in tup] for tup in self._flow_graph.edge_iterator() ],
	    multiedges=True
	)
	vargs = {
	    'edge_labels' : True,
	    'talk' : True
	}
	print 'flow_graph pos:', self._flow_graph.get_pos()
	if 'pos' not in aargs and self._flow_graph.get_pos() is not None:
	    vargs['pos'] = { lx(v) : p for v,p in self._flow_graph.get_pos().items() }
	vargs.update( aargs )
	print 'plot vargs:', vargs
	return lfg.plot( *args, **vargs )
    def transpose_graph_in_place( self ):
	self._graph.set_pos( { v:(-y,-x) for v,(x,y) in self._graph.get_pos().iteritems() } )
	if self._flow_graph is not self._graph:
	    self._flow_graph.set_pos( { v:(-y,-x) for v,(x,y) in self._flow_graph.get_pos().iteritems() } )
    def transpose_graph( self ):
	nm = deepcopy( self )
        nm.transpose_graph_in_place()
	return nm
    def micro_transitions( self ):
	# This could produce micro transitions but it isn't right so far
	ltx = latex_output.latex_output_base( latex_output.write_to_string() )
	lines = []
	for source, target, rate in self._flow_graph.edge_iterator():
	    mu = MakeMicro( self, source )
	    ut = mu( rate )
	    print str(ut); sys.stdout.flush()
	    lines += [ r'  & ' + latex(mu.sigma_fn(SR('x'))) + r'\to' + latex(target)
		+ r' \quad\text{ at rate } '
		+ latex( ut )
	    ]
	ltx.write_align( *lines )
	return ltx._output._str

# useful parent class: expression converter that doesn't
# do anything
from sage.symbolic.expression_conversions import SubstituteFunction
class IdentityConverter(SubstituteFunction):
    def __init__(self):
	pass
    def composition(self, ex, operator):
	# override the parent class's function replacing step
	return operator(*map(self, ex.operands()))

class MakeMicro(IdentityConverter):
    _mul = SR('a*b').operator()
    from sage.symbolic.function_factory import function
    delta_fn = function('delta', latex_name=r'\delta')
    sigma_fn = function('sigma', print_latex_func=lambda self, x:r'\sigma_{%s}' % latex(x))
    bm_sum = function( 'sum', print_latex_func=lambda self, x, s, ex:r'\sum_{%s\in %s}%s' %( latex(x), latex(s), latex(ex) ) )
    bm_indicator = function( 'indicator', print_latex_func=lambda self, ev:r'\mathbb{1}\left(%s\right)' % latex(ev) )
    bm_index_param = function( 'bm_index_param' )
    def __init__(self, model, source):
	self._model = model
	self._source = source
	self._working = False
	self._tags = { s : SR.symbol( 'text'+str(s), latex_name=r'\texttt{%s}'%str(s) ) for s in self._model._vars }
    def __call__(self, ex):
	if self._working:
	    return super(MakeMicro,self).__call__(ex)
	self._working = True
	tx = super(MakeMicro,self).__call__( ex / self._source )
	self._working = False
	return (
	   self.bm_indicator( self.sigma_fn( SR.symbol('x') ) == self._tags[self._source] ) *
	   tx.subs( { s : self.bm_sum( SR.symbol('y'), SR.symbol('X'), 1 / SR('N') * self.bm_indicator( self.sigma_fn( SR('y') ) == self._tags[s] ) ) for s in self._model._vars } )
	)
    def arithmetic(self, ex, operator):
	# do special handling to products of things, before processing the
	# things, to catch inner products
	if operator == self._mul:
	    return self.do_inner_product( *ex.operands() )
	else:
	    return reduce( operator, *map(self, ex.operands()) )
    def symbol(self, s):
	return self.do_inner_product( s ) # just in case
    def do_inner_product(self, *args):
	# leave multiplications as is, except in the case of a
	# parameter dependency marked "sumover": convert that from
	# a regular multiplication to an inner product.
	print 'processing product', args
	margs = list(args)
	sumover = []
	dummy_list = ['y', 'z', 'u', 'v', 'w', 's', 't', 'p', 'q', 'r']
	for p,pd in self._model._parameter_dependencies.items():
	    if p in margs:
		print 'found', p, 'in factors:', args
		if all( d in margs + [self._source] for d,x in pd ):
		    print 'found all of its deps', [d for d,x in pd], 'as well'
		    indices_for_p = []
		    p_times = SR(1)
		    for d,ss in pd:
			if ss == deps.sumover:
			    dummy_var = SR.symbol( dummy_list.pop(0) )
			    indices_for_p.append( dummy_var )
			    sumover.append( dummy_var )
			    print 'will sum over', dummy_var, 'in', d; sys.stdout.flush()
			    margs[margs.index(d)] = 1
			    p_times *= self.bm_indicator( self.sigma_fn( dummy_var ) == self._tags[d] )
			    print 'made it through equality'; sys.stdout.flush()
			elif d == self._source:
			    indices_for_p += [SR('x')]
			else:
			    raise ValueError, 'I am confused about dependence on ' + str(d)
		    index_of_p = margs.index(p)
		    margs[index_of_p] = self.bm_index_param( p, *indices_for_p ) * p_times
		    for dv in reversed(sumover):
			margs[index_of_p] = self.bm_sum( dv, SR.symbol('X'), 1 / SR('N') * margs[index_of_p] )
		    margs[index_of_p] = margs[index_of_p].substitute_function(
			self.bm_index_param,
			lambda *args: dynamicalsystems.subscriptedsymbol( *args )
		    )
		    print margs
		else:
		    raise RuntimeError, (
			"Missing parameter dependencies in expression " +
			str( reduce( self._mul, args ) )
		    )
	expr = reduce( self._mul, margs )
	print 'becomes', expr
	return expr
</source-file>

<source-file filename=boxmodelproduct.py.step lang=python>
# requires: boxmodel.py
from sage.all import *
import dynamicalsystems, boxmodel

# function names used by the edge generator: we can't put tuples into
# symbolic expressions directly so we represent them by instances like
# bm_state( S, a ), bm_param( beta, S, I ), etc.
from sage.symbolic.function_factory import function
bm_state = function( 'bm_state', latex_name='X' )
bm_param = function( 'bm_param', print_latex_func=lambda bmp, p, *xs:'{0}({1})'.format(latex(p),','.join( latex(x) for x in xs )) )

# The general cross product represents its states as tuples of the
# original model's states.  This function can be replaced by another
# one to, for example, make some of these derived compartments synonyms
# for one another, or simply to give them different names.
# This is distinct from a compartment aggregation function, see below,
# which adds compartments together instead of declaring them equivalent.
def default_compartment_renaming(*args):
    return tuple(args)

# A mapping from composite compartment names (tuples) into aggregate
# quantities, for the purpose of summing compartments.  This is distinct
# from a compartment renaming function, above.
def default_compartment_aggregation(*args):
    return tuple(args)

# by default, make tuples of state variables into combined state variables by
# subscripting the first with the others
default_vertex_namer = dynamicalsystems.subscriptedsymbol

# sometimes we want to use this instead.  Rather than
# (S,a) -> 'S_a', gives (S,a) -> 'X_{Sa}'.
def x_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'X', *ss )

# We are given an original parameter plus a list of tuples and indices into
# them.  For example, (beta, (S,I), 0, (I,I), 0, (I,I)),
# for the beta parameter for the transition in the first S of (S,I) to
# I as a result of contact with the first I in (I,I).
# We return a bm_param expression that can be used in SR
# (i.e. no tuples in the arguments) and ready to be made into a subscripted
# variable.
# In the simple case, we call this bm_param( beta, S, I ) because
# that's enough to uniquely identify it.  This will become beta_{SI}.
# If there are cross interactions
# between for instance the S class from the first model and the I class
# from the second model, we need more detailed subscripting, see below.
def default_param_relabeling( *vtuple ):
    print 'simple param relabeling', vtuple
    pairwise = iter(vtuple[1:-1])
    return bm_param( *( (vtuple[0],) + reduce( lambda l,m:l+m, (t[:i] + t[i+1:] for t,i in zip(pairwise,pairwise) ) ) ) )

# Fuller parameter subscripting.  For example for
# (beta, (S,I), 1, (I,I), 2, (I,I))
# we return bm_param( beta, S, I, 1, I, I, 2 ).
def full_param_relabeling( *vtuple ):
    print 'full_param_relabeling', vtuple
    from matplotlib.cbook import flatten
    return bm_param( *(flatten(vtuple[:-1])) )

def default_vertex_positioner( graph, models ):
    """default_vertex_positioner:
    construct an X-Y position for each vertex of the product graph.
    assumes the vertices of the graph are tuples of vertices of the
    models' graphs, in order."""
    directions = [ 0, pi/2, pi/6, pi/3 ] # will add more as needed, I guess
    rotations = [ matrix( [[cos(th),sin(th)],[-sin(th),cos(th)]] ) for th in directions ]
    seq = { v:i for m in models for i,v in enumerate(m._vars) }
    original_positions = [
	m._flow_graph.get_pos() if m._flow_graph.get_pos() is not None else { v:(i,0) for i,v in enumerate(m._vars) }
	for m in models
    ]
    print 'original_positions:',original_positions
    positions = {
	t : sum( r*vector(p[v]) for r,p,v in zip(rotations, original_positions, t.operands()) )
	for t in graph.vertex_iterator()
    }
    #positions = {
	#t: [
	#    sum(seq[v]*cos(d) for v,d in zip(t.operands(), directions)),
	#    - sum(seq[v]*sin(d) for v,d in zip(t.operands(), directions))
        #] for t in graph.vertex_iterator()
    #}
    print 'positions:', positions
    return positions
    import itertools
    positions = {
        tuple(a[1] for a in dtup): [
	    sum(a[0]*cos(d) for a,d in zip(dtup,self.directions)),
	    - sum(a[0]*sin(d) for a,d in zip(dtup,self.directions))
        ] for dtup in itertools.product(
	    *[ enumerate(m._vars) for m in models ]
        )
    }

def default_sop( s_tuple, i, s, t, r ):
    #print 'sop', s_tuple, i, s, t, r
    # return set of t_tuples
    return Set( [ s_tuple[:i] + (t,) + s_tuple[i+1:] ] )
def default_bop( s_tuple, i, c_tuple, i_, s, t, r ):
    # return set of t_tuples
    return Set( [ s_tuple[:i] + (t,) + s_tuple[i+1:] ] )

def tuple_inclusions( c, tup ):
    return [ iota for iota,x in enumerate(tup) if x == c ]

class BoxModelProductException(Exception): pass

# 'single edge stratifier' is called once for each edge of each
# component model, given a set of product vertices.  It loops
# over those vertices and generates all the product edges involving
# those vertices that are versions of that one component edge.
def default_single_edge_stratifier(
	source, target, rate, i, models,
	seed_set, vertex_namer, param_relabeling, compartment_renaming,
	old_set=Set(), cross_interactions=True,
	unary_operation=default_sop, binary_operation=default_bop,
	inclusions=tuple_inclusions
    ):
    print 'old set', old_set, '/ seed set', seed_set
    # produce all product edges made from this component edge
    # list the compartments involved in the transition
    rate_comps = [ x for x in rate.variables() if x in models[i]._vars ]
    rate_params = set( rate.variables() ) - set( rate_comps )
    # we can handle constant, linear or bilinear transitions
    if rate_comps == [] or rate_comps == [source]:
	for V in seed_set:
	    s_inclusions = inclusions( source, V )
	    for iota in s_inclusions:
		repl = { source: bm_state( *compartment_renaming( *V ) ) }
	        for W in unary_operation( V, iota, source, target, rate ):
		    print W
		    # TODO: param_namer
		    repl.update( { p: param_relabeling( p, V, iota, W ) for p in rate_params } )
		    yield ( V, W, rate.subs( repl ) )
    elif len(rate_comps) == 2 and source in rate_comps:
	catalyst, = set(rate_comps) - set([source])
        import itertools
	for V,C in itertools.chain( itertools.product(seed_set, old_set), itertools.product(old_set + seed_set, seed_set) ):
	    print 'consider', V, '+', C, 'at', i
	    # do only the one source inclusion here to avoid duplication
	    #s_inclusions = [ iota for iota,x in enumerate(V) if x == source and iota == i ]
	    s_inclusions = Set( inclusions( source, V ) ).intersection( Set( [i] ) )
	    print source, 'in V:', s_inclusions
	    for iota in s_inclusions:
		if cross_interactions:
		    c_inclusions = inclusions( catalyst, C )
		else:
		    c_inclusions = Set( inclusions( catalyst, C ) ).intersection( Set( [i] ) )
		print catalyst, 'in C:', c_inclusions
		for iota_ in c_inclusions:
	            print 'do edges for', V, iota, C, iota_
		    repl = {
			source: bm_state( *compartment_renaming( *V ) ),
			catalyst: bm_state( *compartment_renaming( *C ) )
		    }
		    for W in binary_operation( V, iota, C, iota_, source, target, rate ):
		        repl.update( { p: param_relabeling( p, V, iota, C, iota_, W ) for p in rate_params } )
		        print V, iota, C, iota_, ':', compartment_renaming( *W ), rate.subs( repl )
		        yield ( V, W, rate.subs( repl ) )
		        if V == C:
			    # TODO: is this within-class case right in general?
			    # A: no, needs iota_ somewhere
		            repl.update( { p: param_relabeling( p, V, iota, iota_, W ) for p in rate_params } )
		            print V, iota, iota_, ':', W, rate.subs( repl ) / bm_state(*C)
		            yield( V, W, rate.subs( repl ) / bm_state(*compartment_renaming(*C)) )
    else: # wrong variables in rate
	raise BoxModelProductException, "Don't understand rate {0}".format(rate)

def simple_edge_stratifier( *args, **kwargs ):
    kwargs['cross_interactions'] = False
    return default_single_edge_stratifier( *args, **kwargs )

# This edge generator is called to generate a set of product edges
# given a set of product compartments and the component models.
# It calls its single_edge_generator once for each edge of each
# component model, to generate all the product edges made from
# that original edge.
def default_edge_generator(
	models,
	vertex_namer, param_relabeling, compartment_renaming,
	single_edge_generator=None,
	seed_set=None, cross_interactions=True,
	unary_operation=default_sop, binary_operation=default_bop,
	inclusions=tuple_inclusions
    ):
    if single_edge_generator is None:
	single_edge_generator = default_single_edge_stratifier
    # TODO: hacky, fix
    # should be if param_relabeling is none then deduce labeling
    if (
	(param_relabeling is default_param_relabeling) and
	cross_interactions and
	any( not Set(m1._vars).intersection( Set(m2._vars) ).is_empty() for m1 in models for m2 in models if m2 is not m1 )
    ):
	param_relabeling = full_param_relabeling
    import itertools
    if seed_set is None:
	seed_set = Set( itertools.product( *(m._vars for m in models) ) )
    edges = []
    old_vertices = Set()
    while not seed_set.is_empty():
        # for each edge of each model, we generate a set of derived edges
        # in the product model
        new_edges = list( itertools.chain( *(
	    single_edge_generator(
	        v, w, r, i, models, seed_set,
	        vertex_namer, param_relabeling, compartment_renaming,
		old_set=old_vertices,
	        unary_operation=unary_operation,
		binary_operation=binary_operation,
		cross_interactions=cross_interactions,
		inclusions=inclusions
	    )
	    for i in range(len(models))
	    for v,w,r in models[i]._graph.edge_iterator()
        ) ) )
	edges += new_edges
	# the edges returned may involve vertices we didn't anticipate
	# so we expand our set of vertices dynamically
	# in which case, we have to do the generation again to include
	# transitions involving the new vertices
        old_vertices += seed_set
        seed_set = Set( v for v,w,r in new_edges ).union( Set( w for v,w,r in new_edges ) ) - old_vertices
	if len(old_vertices) + len(seed_set) > 100:
	    raise RuntimeError, 'Recursion produces too many compartments'
    return [ ( bm_state( *compartment_renaming( *V ) ), bm_state( *compartment_renaming( *W ) ), r ) for V,W,r in edges ]

class CompositeBoxModel(boxmodel.BoxModel):
    """CompositeBoxModel is a boxmodel structure in which compartment names,
    and maybe some parameters, have structure.  Unlike the base BoxModel,
    here we maintain two representations of the graph: one with structure --
    in which each compartment is represented by a 'bm_state' function of
    multiple arguments, and all or some parameters are represented by a
    'bm_param' function of multiple arguments.  Those argument lists are
    transformed to simple SR variable names by the vertex_namer and
    param_namer functions."""
    def __init__(
	    self,
	    graph,
	    var_tuples,
	    vertex_namer=x_namer,
	    param_namer=dynamicalsystems.subscriptedsymbol,
	    bindings=dynamicalsystems.Bindings()
	):

	self._graph = graph
	self._graph.set_latex_options( edge_labels=True, vertex_shape='rectangle' )

	# now for consumption by humans and math software, we map vertex
	# tuples to regular variable names with subscripts
	bm_to_vars = lambda e: e.substitute_function( bm_param, param_namer ).substitute_function( bm_state, vertex_namer )
	self._flow_graph = DiGraph( [
	        ( bm_to_vars(v), bm_to_vars(w), bindings(bm_to_vars(e)) )
	        for v, w, e in self._graph.edge_iterator()
	    ],
	    multiedges=True
	)
	self._flow_graph.set_latex_options( edge_labels=True, vertex_shape='rectangle' )
	positions = self._graph.get_pos()
	if positions is not None:
	    self._flow_graph.set_pos( { bm_to_vars(v):pos for v,pos in positions.items() } )

	self._var_tuples = var_tuples
	self._vars = [ bm_to_vars(v) for v in var_tuples ]
	self._vertex_namer = vertex_namer
	self._param_namer = param_namer
	self._bindings = bindings
    def bind(self, *args, **vargs):
	return CompositeBoxModel(
	    self._graph,
	    self._tuple_vars,
	    self._vertex_namer,
	    self._param_namer,
	    self._bindings + dynamicalsystems.Bindings( *args, **vargs )
	)
    def aggregate_compartments( self, compartment_aggregation,
	    param_namer_after=lambda *x:x,
	    vertex_namer_after=lambda *x:x ):
        aggregate = {}
        for vt in self._graph.vertex_iterator():
            aggregate.setdefault( compartment_aggregation( vt.operands() ), [] ).append( vt.operands() )
        ## aggregate is { new_tuple: [old tuples], ... }
        print 'aggregate:', aggregate
        flow_sums = {}
        for v in self._graph.vertex_iterator():
	    av = bm_state( *compartment_aggregation( v.operands() ) )
	    if av not in flow_sums: flow_sums[av] = {}
	    for _,w,e in self._graph.outgoing_edge_iterator(v):
		aw = bm_state( *compartment_aggregation( w.operands() ) )
	        flow_sums[av].setdefault( aw, SR(0) )
		es = e.substitute_function( bm_param, param_namer_after ).substitute_function( bm_state, self._vertex_namer )
		print 'substitute:', e, '|||', es
	        flow_sums[av][aw] += es
	## flow_sums[av][aw] is sum of all transitions from
	## (aggregated tuple) av to aw
	## transitions are in terms of old vertex names and new param names

        ## now do substitutions to transform the transition sums
        agg_eqns, agg_symbols = [], []
        agg_subs = dynamicalsystems.Bindings()
        for newt,oldts in aggregate.items():
            print 'will combine', sum( self._vertex_namer(*oldt) for oldt in oldts ), '==', vertex_namer_after(*newt)
            agg_symbols.append( self._vertex_namer(*oldts[0]) )
            agg_eqns.append( self._vertex_namer(*oldts[0]) == vertex_namer_after(*newt) - sum( self._vertex_namer(*oldt) for oldt in oldts[1:] ) )
        agg_graph_dict = {}
        for av, ve in flow_sums.iteritems():
	    vn = av.substitute_function( bm_state, vertex_namer_after )
            agg_graph_dict[vn] = {}
            for aw, e in ve.iteritems():
		wn = aw.substitute_function( bm_state, vertex_namer_after )
    	        sym = SR.symbol()
    	        print e,
    	        solns = solve( [ sym == e ] + agg_eqns, sym, *agg_symbols, solution_dict=True )
    	        #print 'solve', [ sym == e ] + agg_eqns, ',', [sym] + agg_symbols, '\n  ', solns
    	        if len(solns) == 1:
    	            #print '  ', maxima(sym), [str(k) == str(sym) for k in solns[0].keys()]
    	            el = [ex for k,ex in solns[0].items() if str(k) == str(sym)]
    	            print '==>', el[0]
    	            agg_graph_dict[vn][wn] = el[0]
		    # TODO: separate transformed sum into multiple arrows
    	        else:
    	            raise RuntimeError, 'Could not simplify expression ' + str(e) + ':' + str(solns)
	print 'agg_graph_dict', agg_graph_dict
        #self._vc_eqns = vc_eqns
	## make list of transformed variables
	## they are in those dicts, but we want the order
        agg_vars = []
	def xform_state( *t ):
	    s = compartment_aggregation( t )
	    return vertex_namer_after( *s )
        for v in self._var_tuples:
	    av = v.substitute_function( bm_state, xform_state )
	    if av not in agg_vars: agg_vars.append(av)
	print 'agg_vars', agg_vars
        ## position the aggregates by matching them to a subset of original
	## compartments
	apos = {}
	for t,p in self._graph.get_pos().iteritems():
	    at = t.substitute_function( bm_state, xform_state )
	    if at not in apos: apos[at] = p
	print 'apos', apos
	## The transformation produces a flow_graph only, not a structured
	## representation
        return boxmodel.BoxModel( DiGraph( agg_graph_dict, pos=apos ), agg_vars )
    def add_transitions( self, trs ):
	# it's an immutable object, so this operation
	# returns a new BoxModel.  trs is a list of (source,target,rate)
	# tuples suitable for adding to self._graph (rather than _flow_graph).
	fg = deepcopy(self._flow_graph)
	bm_to_vars = lambda e: e.substitute_function( bm_state, self._vertex_namer).substitute_function( bm_param, self._param_namer )
	fg.add_edges( [ (bm_to_vars(v), bm_to_vars(w), bm_to_vars(e)) for v,w,e in trs ] )
	return boxmodel.BoxModel(
	    fg,
	    vars = self._vars,
	    bindings = self._bindings
        )

class BoxModelProduct(CompositeBoxModel):
    def __init__(
	    self,
	    *models,
	    **kwargs
	):
	self._models = models
	compartment_renaming =  kwargs.pop( 'compartment_renaming', default_compartment_renaming )
	vertex_namer =          kwargs.pop( 'vertex_namer', default_vertex_namer )
	param_relabeling =      kwargs.pop( 'param_relabeling', default_param_relabeling )
	edge_generator =        kwargs.pop( 'edge_generator', default_edge_generator )
	single_edge_generator = kwargs.pop( 'single_edge_generator', None )
	compartment_aggregation = kwargs.pop( 'compartment_aggregation',
	    lambda x:x )
	vertex_positioner =     kwargs.pop( 'vertex_positioner', default_vertex_positioner )
	unary_operation =       kwargs.pop( 'unary_operation', default_sop )
	binary_operation =      kwargs.pop( 'binary_operation', default_bop )
	inclusions =            kwargs.pop( 'inclusions', tuple_inclusions )
	seed_set =              kwargs.pop( 'seed_set', None )
	if kwargs: raise TypeError, "Unknown named arguments to BoxModelProduct: %s" % str(kwargs)

	edges = list( edge_generator(
	    models,
	    vertex_namer,
	    param_relabeling,
	    compartment_renaming,
	    single_edge_generator=single_edge_generator,
	    unary_operation=unary_operation,
	    binary_operation=binary_operation,
	    inclusions=inclusions,
	    seed_set=seed_set
	) )
	print 'edges for product graph:', edges
	graph = DiGraph( edges, multiedges=True )

	# graphical positions of graph vertices
	graph.set_pos( vertex_positioner( graph, models ) )

	from collections import OrderedDict
	vars_d = OrderedDict( (v,None) for v,w,e in edges )
	vars_d.update( (w,None) for v,w,e in edges )
	super(BoxModelProduct,self).__init__(
	    graph, vars_d.keys(), vertex_namer
	)

	self._inclusion_tuples = {}
	for vbm in self._graph.vertex_iterator():
	    vs = vbm.operands()
	    for v in vs:
	        self._inclusion_tuples.setdefault(v, []).append( vs )

	#print self._inclusion_tuples
	self._inclusion_variables = {
	    k:[vertex_namer(*v) for v in vl]
	    for k,vl in self._inclusion_tuples.iteritems()
	}
	for k,vl in self._inclusion_variables.iteritems():
	    self._bindings[k] = sum( vl )

	# make list of variables, in order, by taking product
        import itertools
	varset = set()
	self._vars = []
	self._tuples = []
	for vs in itertools.product( *(m._vars for m in models) ):
	    t = compartment_renaming( *vs )
	    v = vertex_namer( *t )
	    if v not in varset:
		varset.add(v)
		self._vars.append(v)
		self._tuples.append( bm_state( *t ) )
	print 'made tuples:', self._tuples

	# now generate all the crossed parameters
	# TODO: do this right
	self._parameters = reduce( lambda x,y: set(x).union(y), (r.variables() for f,t,r in self._flow_graph.edges()), set() ).difference( self._vars )
	#print 'parameters:', self._parameters

	self._vertex_namer = vertex_namer
	self._param_relabeling = param_relabeling

def default_sop_strong( s_tuple, iset, eis ):
    # return set of t_tuples
    print 'sop', s_tuple, eis
    tl = list(s_tuple)
    for (v,w,r),i in eis: tl[i] = w
    return Set( [ tuple(tl) ] )
def default_bop_strong( s_tuple, iset, c_tuple, i_set, eis ):
    # return set of t_tuples
    tl = list(s_tuple)
    for (v,w,r),i in eis: tl[i] = w
    return Set( [ tuple(tl) ] )

# this thing is called once for each set of
# component edges, given a set of product vertices.  It loops
# over those vertices and generates all the product edges involving
# those vertices that are versions of that combination of component
# edges.
# TODO: much duplication with the regular single_edge_generator.
# maybe merge
def default_strong_edge_bundle_generator(
	eis, models,
	seed_set, vertex_namer, param_relabeling, compartment_renaming,
	old_set=Set(), cross_interactions=True,
	unary_operation=default_sop_strong, binary_operation=default_bop_strong,
	inclusions=tuple_inclusions
    ):
    if len(eis) == 0: return
    print 'old set', old_set, '/ seed set', seed_set
    # produce all product edges made from these component edges
    # what is the rate of a transition that combines some set of
    # component transitions?
    # who cares? we assume this will only be used to combine
    # instances of the same transition, in a power of a single
    # model.
    if len( Set( (r for ((w,v,r),i) in eis) ) ) != 1:
        raise RuntimeError, 'overwhelming rate construction problem involving transitions '+str(eis)
    # else: do the replacement in the one rate
    (source,target,rate),i = eis[0]
    # list the compartments involved in the transition
    rate_comps = [ x for x in rate.variables() if x in models[i]._vars ]
    rate_params = set( rate.variables() ) - set( rate_comps )
    # we can handle linear or bilinear transitions
    if rate_comps == [source]:
	for V in seed_set:
	    if all( i in inclusions( v, V ) for (v,w,r),i in eis ):
		repl = { v: bm_state( *compartment_renaming( *V ) ) }
	        for W in unary_operation( V, [i for e,i in eis], eis ):
		    print W
		    # TODO: param_namer
		    repl.update( { p: param_relabeling( p, V, iota, W ) for p in rate_params } )
		    yield ( V, W, r.subs( repl ) )
    elif len(rate_comps) == 2 and source in rate_comps:
	catalyst, = set(rate_comps) - set([source])
        import itertools
	for V,C in itertools.chain( itertools.product(seed_set, old_set), itertools.product(old_set + seed_set, seed_set) ):
	    #print 'consider', V, '+', C, 'at', eis
	    # does V have the relevant compartments?
	    # only consider the one inclusion in V, the one given by eis
	    if not all( i in inclusions( v, V ) for (v,w,r),i in eis ):
		#print V, 'does not have the inclusions in', eis
	        continue
	    iota = [ i for e,i in eis ]
	    # in general case, it's all the ways to include the 
	    # rate's catalyst compartment in C
	    # in simple case, those are the inclusions for C as well
	    if cross_interactions:
		c_inclusions = Arrangements( inclusions( catalyst, C ), len(eis) )
		#print 'inclusions of', eis, 'in', C, ':', list( c_inclusions )
	    else:
	        c_inclusions = Set( tuple( i for e,i in eis ) ) if all( i in inclusions( catalyst, C ) for e,i in eis ) else Set()
	        #print catalyst, 'in C:', list( c_inclusions )
	    for iota_ in c_inclusions:
                #print 'do edges for', V, iota, C, iota_
    	        repl = {
    		    source: bm_state( *compartment_renaming( *V ) ),
    		    catalyst: bm_state( *compartment_renaming( *C ) )
    	        }
    	        ts = binary_operation( V, list( iota ), C, list( iota_ ), eis )
		print 'bop returns', ts
		# TODO: check if in-compartment interaction is right
    	        for W in ts:
    	            repl.update( { p: param_relabeling( p, V, iota, C, iota_, W ) for p in rate_params } )
    	            #print V, iota, C, iota_, ':', compartment_renaming( *W ), rate.subs( repl )
    	            yield ( V, W, rate.subs( repl ) )
    	            if V == C:
    		        # TODO: is this within-class case right in general?
    	                repl.update( { p: param_relabeling( p, V, iota, iota_, W ) for p in rate_params } )
    	                #print V, iota, iota_, ':', W, rate.subs( repl ) / bm_state(*C)
    	                yield( V, W, rate.subs( repl ) / bm_state(*compartment_renaming(*C)) )
    else: # wrong variables in rate
	raise BoxModelProductException, "Don't understand rate {0}".format(rate)

def strong_edge_generator(
	models,
	vertex_namer, param_relabeling, compartment_renaming,
	single_edge_generator=None,
	seed_set=None, cross_interactions=True,
	unary_operation=default_sop, binary_operation=default_bop,
	inclusions=tuple_inclusions
    ):
    if single_edge_generator is None:
	single_edge_generator = default_strong_edge_bundle_generator
    # TODO: hacky, fix
    if (
	(param_relabeling is default_param_relabeling) and
	cross_interactions and
	any( not Set(m1._vars).intersection( Set(m2._vars) ).is_empty() for m1 in models for m2 in models if m2 is not m1 )
    ):
	param_relabeling = full_param_relabeling
    import itertools
    if seed_set is None:
	seed_set = Set( itertools.product( *(m._vars for m in models) ) )
    edges = []
    old_vertices = Set()
    while not seed_set.is_empty():
        # for each edge of each model, we generate a set of derived edges
        # in the product model
        new_edges = list( itertools.chain( *[
	    # call this thing once for each edge in each model, and
	    # in fact more generally once for each tuple ( (e1,i1), (ex,ix), ... )
	    # where ei is an edge in model i for some set of the models
	    single_edge_generator(
	        eis, models, seed_set,
	        vertex_namer, param_relabeling, compartment_renaming,
		old_set=old_vertices,
	        unary_operation=unary_operation,
		binary_operation=binary_operation,
		cross_interactions=cross_interactions,
		inclusions=inclusions
	    )
	    for iset in Subsets( Set( range(len(models)) ) )
	    for eis in itertools.product( *([(e,i) for e in models[i]._graph.edge_iterator()] for i in iset) )
        ] ) )
	edges += new_edges
	# the edges returned may involve vertices we didn't anticipate
	# so we expand our set of vertices dynamically
	# in which case, we have to do the generation again to include
	# transitions involving the new vertices
        old_vertices += seed_set
        seed_set = Set( v for v,w,r in new_edges ).union( Set( w for v,w,r in new_edges ) ) - old_vertices
	if len(old_vertices) + len(seed_set) > 100:
	    raise RuntimeError, 'Recursion produces too many compartments'
    return [ ( bm_state( *compartment_renaming( *V ) ), bm_state( *compartment_renaming( *W ) ), r ) for V,W,r in edges ]

def cross( *models ):
    return BoxModelProduct( *models )

def union_edge_generator( models, vertex_namer, param_namer, compartment_renaming ):
    import itertools
    return itertools.chain( *(m._graph.edge_iterator() for m in models) )

def union_positioner( graph, models, compartment_renaming ):
    return {
	v:(x,-i)
	for i,pos in enumerate( m._graph.get_pos() for m in models )
	for v,(x,y) in pos.iteritems()
    }

## union is not a product, but it's easy to implement as one
## it just combines the graphs "side by side"
## (except if they share vertices and possibly edges, they'll be combined)
## note if we didn't combine those it would be direct sum rather than union
def union( *models ):
    """union of the models' vertex and edge sets"""
    return BoxModelProduct( *models,
	vertex_namer = boxmodelproduct.x_namer,
	edge_generator = union_edge_generator,
	vertex_positioner = union_positioner
    )

## TODO: rewrite using new strong_edge_generator with bop
def strong_product( *models, **kwargs ):
    compartment_renaming =  kwargs.pop( 'compartment_renaming',  default_compartment_renaming )
    vertex_namer =    kwargs.pop( 'vertex_namer',    default_vertex_namer )
    param_namer =     kwargs.pop( 'param_namer',     default_vertex_namer )
    vertex_positioner = kwargs.pop( 'vertex_positioner', default_vertex_positioner )
    if kwargs: raise TypeError, "Unknown named arguments to BoxModelProduct: %s" % str(kwargs)
    return BoxModelProduct( *models,
	edge_generator = strong_edge_generator,
	vertex_namer = vertex_namer,
	compartment_renaming = compartment_renaming,
	param_namer = param_namer,
	vertex_positioner = vertex_positioner
    )

def power( model, i, compartment_renaming=lambda *x:x, param_relabeling=default_param_relabeling ):
    return BoxModelProduct(
	*([model] * i),
	vertex_namer = x_namer,
	compartment_renaming=compartment_renaming,
	param_relabeling=param_relabeling
    )

def write_product_formula( M1, M2, M12, tfnm, op=r'\times', size1=(3,1), size2=(1,4), size12=(4,4) ):
    # do I need to do this before opening the file, to get preamble right?
    Mtz = M1.tikz_boxes( figsize=size1, inline=True )
    import latex_output
    ltx = latex_output.latex_output( tfnm )
    ltx.write( '$\\raisebox{-0.5\\height}{\\hbox{', Mtz, '}}', op, '\\raisebox{-0.5\\height}{\\hbox{', M2.transpose_graph().tikz_boxes( figsize=size2, inline=True ), '}} = \\raisebox{-0.5\\height}{\\hbox{', M12.tikz_boxes( figsize=size12, inline=True ), '}}$' )
    ltx.close()

</source-file>

<source-file filename=upstream.mk>
# Makefile to connect the Sage code here with the code in SageDynamics

# the three upstream projects are all bundled into one git repo
export SageUtils            = $(realpath $(SageDynamicsRepo)/SageUtils)
export SageDynamics         = $(realpath $(SageDynamicsRepo)/SageDynamics)
export SageAdaptiveDynamics = $(realpath $(SageDynamicsRepo)/SageAdaptiveDynamics)

# When we need something from the upstream projects, make it there
$(SageDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageDynamics) $*

$(SageAdaptiveDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageAdaptiveDynamics) $*

# The good makefile stuff is upstream, just reuse it
-include $(SageUtils)/sage.mk
-include $(SageUtils)/step.mk
</source-file>

