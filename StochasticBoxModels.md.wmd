---
layout: page
title: Stochastic Box Models
wmd_project: Box_Models
---

<source-file filename=kolmogorov.py.step texdisplay=none>
"""Forward, backward Kolmogorov equations for things"""
import dynamicalsystems

class km_indexer_nd:
    km_symb_counter = 0
    km_cache = {}
    def __init__(self, n, f, args=[]):
	self._f = f
	self._n = n
	self._args = args
    def __getitem__(self, i):
	if self._n == 1:
	    args = self._args + [i]
	    c_args = tuple([self._f] + args)
	    if c_args in km_indexer_nd.km_cache: return km_indexer_nd.km_cache[c_args]
	    sstmp = dynamicalsystems.subscriptedsymbol( self._f, *args )
	    from sage.symbolic.ring import SR
	    from sage.misc.latex import latex
	    symb = SR.symbol( str(km_indexer_nd.km_symb_counter).replace( '/', '_' ), latex_name=latex(sstmp) )
	    km_indexer_nd.km_symb_counter += 1
	    km_indexer_nd.km_cache[c_args] = symb
	    return symb
	return km_indexer_nd(self._n-1, self._f, self._args + [i])

from sage.symbolic.function_factory import function
km_p = function('kolmogorov_p', latex_name='p')

class KolmogorovForwardODE( dynamicalsystems.ODESystem ):
    def __init__(self, flow, states, state_indexer=None, state_namer=None):
	"""Unlike ODE_system, the 'states' here are instances of the
	"Kolmogorov p" function, and the flow is also written in terms
	of this function.  States are shorthanded as vectors.

	For example, the states might be
	[vector(0,0),vector(0,1),vector(1,0),vector(1,1)],
	in which case the flow would be a dictionary of the form
	{ vector(0,0) : (alpha + 1) * km_p(1,0) - alpha * km_p(0,0), ... }."""
	self._km_flow = flow
	self._km_states = states
	if state_indexer is None:
	    state_indexer = km_indexer_nd( len( states[0] ), 'p' )
	if state_namer is None:
	    from sage.symbolic.expression_conversions import SubstituteFunction
	    state_namer = SubstituteFunction( None, km_p,
		lambda *args: reduce( lambda x,y:x[y], args, state_indexer )
	    )
	super( KolmogorovForwardODE, self ).__init__(
	    { state_namer(km_p(*t)) : state_namer(rhs) for t,rhs in flow.items() },
	    [ state_namer(km_p(*t)) for t in states ]
	)
</source-file>

<source-file filename=boxkolmogorov.py.step texdisplay=none>
# requires: boxmodel.py kolmogorov.py
from sage.all import *
import boxmodel, kolmogorov
from itertools import product
from dynamicalsystems import Bindings, ODESystem

def bm_kolmogorov_eqns( self, N, callback ):
    # to convert states' names to integers for indexing
    state_index = { s:i for i,s in enumerate(self._vars) }
    # before beginning, test for conserved total mass
    if sum( self.ode_flow().values() ) != 0:
        # discretize the state space
        km_states = [ vector(l) for l in product( *((i/N for i in range(N+1)) for s in self._vars) ) if sum(l) <= 1 ]
    else:
	print 'Reducing dimension to', tuple(self._vars[:-1])
        km_states = [ vector(l + (1 - sum(l),)) for l in product( *((i/N for i in range(N+1)) for s in self._vars[:-1]) ) if sum(l) <= 1 ]
    # to bind state variables to their values in a given state s
    bind_state = lambda s: Bindings( { sn:sv for sn,sv in zip( self._vars, s ) } )
    # standard basis vectors
    B = list(km_states[0].parent().basis())
    # do the forward or backward construction
    return callback( self, N, km_states, bind_state, state_index, B )

def km_var( x, *args ):
    return SR.symbol( x+'_'+ '_'.join( str(a).replace('/','_') for a in args ),
	latex_name = x+'_{%s}' % (''.join(latex(a) for a in args)) )

def p_var( *args ):
    return km_var( 'p', *args )

def km_pos( states, x ):
    try:
        return { km_var(x,*s) : (s[0],-s[1]) for s in states }
    except:
	return { km_var(x,*s) : (s[0],s[0]) for s in states }

def forward_callback( self, N, km_states, bind_state, state_index, B ):
    # construct the forward equations, as a box model, from the state grid
    # and transitions of the original box model.
    km_graph_dict = {
	# for every s in the discretized grid, and every transition e from v to w,
	# a flow of probability mass from s to s - 1/N v + 1/N w
        # at rate e p(s)
	p_var( *s ) : {
	    p_var( *(s - B[ state_index[v] ] / N + B[ state_index[w] ] / N) ) :
		p_var( *s ) * bind_state(s)(e)
		for v,w,e in self._flow_graph.edge_iterator()
		if bind_state(s)(e) != 0
	} for s in km_states
    }
    return boxmodel.BoxModel( DiGraph( km_graph_dict, pos=km_pos( km_states, 'p' ) ),
	[ p_var( *s ) for s in km_states ] )

boxmodel.BoxModel.forward_boxmodel = lambda self, N: bm_kolmogorov_eqns( self, N, forward_callback )

def q_var( *args ):
    return km_var( 'q', *args )

def backward_callback( self, N, km_states, bind_state, state_index, B ):
    # construct the forward equations, from the state grid
    # and transitions of the original box model.
    km_flow = { q_var( *s ) :
	sum( bind_state( s )(e) *
	    ( q_var( *(s - B[state_index[v]]/N + B[state_index[w]]/N) ) - q_var(*s) )
	    for v,w,e in self._flow_graph.edge_iterator()
	    if bind_state(s)(e) != 0 )
	for s in km_states
    }
    return ODESystem(
	km_flow,
	[ q_var( *s ) for s in km_states ]
    )

boxmodel.BoxModel.backward_equations = lambda self, N: bm_kolmogorov_eqns( self, N, backward_callback )

</source-file>

Here we construct Kolmogorov forward equations for an SI model,
assuming the granularity of $$S$$ and $$I$$ is $$\frac13$$.

The Sage code automatically reduces the state space from $$(S,I)$$
to just $$(S)$$ before building the forward equations, 
after verifying that $$S+I\equiv1$$.  Thus the
variable $$p_{\frac13}$$ is the probability that $$S=\frac13$$ and
$$I=\frac23$$ at time $$t$$, etc.

<source-file filename=SI-forward.sage.step>
# requires: boxmodel.py boxkolmogorov.py kolmogorov.py SI.sobj
# produces: SI-forward.tex SI-backward.tex SI-forward.svg
from sage.all import *
import boxmodel, boxkolmogorov
load_session( 'SI.sobj' )

SIf = SI.forward_boxmodel(3)
SIf.ode().write_latex( 'SI-forward.tex' )

fsol = SIf.ode().bind( { beta:1 } ).solve( [0,0,1,0] )
colors= rainbow(4)
P = Graphics()
for v in SIf._vars:
    P += fsol.plot( 't', v, color=colors.pop(), legend_label='$%s$'%latex(v) )
P.save( 'SI-forward.svg', figsize=(4,3) )

SI.backward_equations(3).write_latex( 'SI-backward.tex' )
</source-file>

Here are the SI forward equations:

<project-file filename=SI-forward.tex/>

Evolution of forward equations:

<project-file filename=SI-forward.svg/>

And backward equations for SI:

<project-file filename=SI-backward.tex/>

Here are forward equations for SIR (with the state space reduced
to $$(S,I)$$).

<source-file filename=SIR-forward.sage.step>
# requires: boxmodel.py boxkolmogorov.py kolmogorov.py SIR.sobj
# produces: SIR-forward.tex SIR-forward-boxes.tex SIR-backward-boxes.tex
# produces: SIR-forward.sobj
from sage.all import *
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output, boxmodel, boxkolmogorov
load_session( 'SIR.sobj' )

SIRf = SIR.forward_boxmodel(4)
ltx = latex_output.latex_output( 'SIR-forward.tex' )
ltx.write( SIRf.ode() )
ltx.close()
SIRf._flow_graph.set_latex_options( edge_labels=False )
SIRf.plot_boxes( 'SIR-forward-boxes.tex' )

N = 10
SIRN = SIR.forward_boxmodel(N)

sb = SIRN.ode().bind( { alpha:1, mu:0.2 } )
init_cond = { v:0 for v in sb._vars }
init_cond[ boxkolmogorov.km_var( 'p', 1-1/N, 1/N, 0 ) ] = 1
init_vect = [ init_cond[v] for v in sb._vars ]
print init_cond
print init_vect
fsol = sb.solve_gsl( init_vect, end_time=200 )
sb._gsl_system = None # can't pickle
save_session( 'SIR-forward' )
</source-file>

<source-file filename=SIR-forward-plot.sage.step>
# requires: boxmodel.py boxkolmogorov.py kolmogorov.py SIR.sobj
# requires: SIR-forward.sobj
# produces: SIR-forward.svg
from sage.all import *
import boxmodel, boxkolmogorov
load_session( 'SIR-forward.sobj' )

colors= rainbow(len(sb._vars))
P = Graphics()
for v in sb._vars:
    P += fsol.plot( 't', v, color=colors.pop() )
P.save( 'SIR-forward.svg', figsize=(4,3) )
</source-file>

<source-file filename=SIR-forward-heat.sage.step>
# requires: boxmodel.py boxkolmogorov.py kolmogorov.py SIR.sobj
# requires: SIR-forward.sobj
# produces: SIR-forward-heat.pdf
from sage.all import *
import boxmodel, boxkolmogorov
from boxkolmogorov import p_var
from dynamicalsystems import Bindings

load_session( 'SIR-forward.sobj' )

il = [ i/N for i in range(N+1) ]
marginals = Bindings( {
    p_var( 'S', i ) :
	sum( p_var( i, j, k ) for j in il for k in il if i + j + k == 1 )
	for i in il
} ) + Bindings( {
    p_var( 'I', j ) :
	sum( p_var( i, j, k ) for i in il for k in il if i + j + k == 1 )
	for j in il
} ) + Bindings( {
    p_var( 'R', k ) :
	sum( p_var( i, j, k ) for i in il for j in il if i + j + k == 1 )
	for k in il
} )

f = lambda c: sqrt(float(c))

im_arr = [ [ [
	    f( pp( marginals( p_var('S', i) ) ) ),
	    f( pp( marginals( p_var('I', i) ) ) ),
	    f( pp( marginals( p_var('R', i) ) ) )
	] for pp in fsol._timeseries
    ] for i in il
]

from matplotlib import pyplot, patches
fig, ax1 = pyplot.subplots(nrows=1, figsize=(5.5,3))
tmax = float(fsol._timeseries[-1]('t'))
ax1.imshow( im_arr, origin='lower', extent=(0,tmax,0,1), aspect=0.75*tmax )
handles = (
    patches.Patch( color=(1r,0r,0r), label='S' ),
    patches.Patch( color=(0r,1r,0r), label='I' ),
    patches.Patch( color=(0r,0r,1r), label='R' )
)
pyplot.legend( handles, ('S','I','R'), bbox_to_anchor=(1.05,1), loc=2, borderaxespad=0. )
pyplot.savefig( 'SIR-forward-heat.pdf' )
pyplot.savefig( 'SIR-forward-heat.png' )
</source-file>

<project-file filename=SIR-forward.tex/>

<project-file filename=SIR-forward-boxes.crop.svg/>

<project-file filename=SIR-forward-heat.pdf/>

Partial to do list:

* Backward equations, extinction time, etc.

* Of course, we would like to produce and run forward (or backward?) 
equations for $$(SIR)^{100}$$.  First we have to figure out what
$$(SIR)^{100}$$ is though...

* Also, we could take the PDE limit of these as the granularity goes to zero
(i.e. population size $$\to\infty$$), but I don't think that's a priority right now.

## Links

Keeling, M. J. and J. V. Ross, 2008. [On methods for studying stochastic disease dynamics](http://dx.doi.org/10.1098%2Frsif.2007.1106), J. Royal Society Interface 5(19):171--181.
