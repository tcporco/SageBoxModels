---
layout: page
title: Definitions of Box Model operations
wmd_project: Notes
wmd_prerequisite_projects:
  BoxModels: Box_Models
---

## Introduction

Compartmental models are widely used in mathematical
ecology and epidemiology.  
<!-- example Jacquez book, also Matis and Kiffe, Stochastic Population
Models: a compartmental perspective, also Hethcote, also Anderson and May. -->

In epidemiology, the SIR model for instance represents an epidemic process
whereby susceptibles become infectious and then become removed.  In its simple
or classical form, this model assumes an exponential waiting time of
infectivity. Yet almost from the very beginning (Kermack and McKendrick) this
limitation was generalized, leading to more complex and realistic models.  Other
refinements have involved adding additional spatial, genetic, vaccination, 
age, household, or other forms of structure.  Cite Metz and Diekmann. 

Formalize the process of theory development... enable systematic exploration
of related models...formal structural sensitivity analysis

pharmacokinetic and biological model structures

## Box Model

A **box model** is a directed graph whose vertices are **compartments** and
edges are **transitions**.
Each compartment has a **name**, which is a mathematical variable such as $$X$$.
A transition is an ordered triple $$(s,t,r)$$, where $$s$$ and $$t$$ are the
**source** and **target** compartments of the transition, and $$r$$ is its
**rate**, which is a function of the compartments' names.
We will use the notation $$s\xrightarrow{r}t$$ as a synonym for the
above triple.
Any variable involved in a transition rate that is not the name of a
compartment is a **parameter** of the model.  $$V(M)=\{c_1,\ldots,c_n\}$$,
the vertex set of model $$M$$, is the set of its compartments, and
$$E(M)$$ is the set of its edges.  Let $$X(M)$$ be the set of
the names of the compartments of model $$M$$, 
and let $$P(M)=\{p_1,\ldots,p_m\}$$ be the set of all its
transitions' parameters; then each transition rate is a function
$$r(c_1,\ldots,c_n,p_1,\ldots,p_m)$$ taking values in $$\mathbb{R}$$.

A box model is associated with an **ODE**, whose state variables are the
compartments' names, and whose flow vector field is constructed from the
transition rates:

$$\frac{dX}{dt} = \sum_{\{e\in E(M)\mid\operatorname{source}(e)=X\}}\text{rate}(e) - \sum_{\{e\in E(M)\mid\operatorname{target}(e)=X\}}\text{rate}(e)$$

for each compartment $$X$$.

There are also an SDE, a diffusion equation, individual-based models, 
and possibly other models that can be automatically generated to describe
the behavior of this system.

**Example: SI model.**

<project-file filename=SI.boxes.crop.svg/>

This box model has two compartments, S and I.  There is one transition
from S to I, with rate $$\beta S I$$.  Its ODE is

$$\frac{dS}{dt} = -\beta S I$$

$$\frac{dI}{dt} = \beta S I$$.

## Products of box models

A **product** of box models, written $$M_1\times \cdots\times M_n$$, where
each $$M_i$$ is a box model, is a box model whose set of compartments is the
cross product, or
[Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product#Graph_theory),
of the component box models' sets of compartments (see Appendix for definitions
of graph product operations).  The transitions include
the edges of the Cartesian product of the components' graphs, but the product
may include more transitions as well.

[TODO: it may include added compartments as well?]

* The compartments of the cross product are tuples $$(c_1,\ldots,c_n)$$
where each $$c_i$$ is a compartment of $$M_i$$.  The name of
compartment $$(c,d,e,\ldots,w)$$ may be $$c_{de\ldots w}$$, or it may
be named $$X_{cde\ldots w}$$, or some other naming may be used.
* For each transition $$T$$ of component model $$M_i$$, with source $$s$$,
target $$t$$, and rate $$r$$, there is a transition from each compartment
$$(c_1,\ldots,c_{i-1},s,c_{i+1},\ldots,c_n)$$ of the product model to
$$(c_1,\ldots,c_{i-1},t,c_{i+1},\ldots,c_n)$$.
Its transition rate is derived from $$r$$.

I believe there are a few different products that are appropriate
depending on the biology of the model, differing in what transitions
are included and how their rates are constructed.

<!--
Before providing examples, here are some useful definitions:

* A **stratification** $$S(X)$$ of a variable $$X$$ in a product of models
$$M_1\times\cdots\times M_n$$, where $$X$$ is a compartment 
of model $$M_i$$, is a compartment
$$(c_1,\ldots,c_{i-1},X,c_{i+1},\ldots,c_n)$$,
where each $$c_j$$ is a compartment of $$M_j$$.  

* A stratification $$S(P)$$
of a parameter $$P$$ of model $$M_i$$, where $$S$$ is defined as above,
is the ordered pair $$(P,(c_1,\ldots,c_{i-1},c_{i+1},\ldots,c_n))$$.
The name given to that stratified parameter may be
$$P_{c_1\ldots c_{i-1}c_{i+1}\ldots c_n}$$,
or some other naming may be used.  As we will see, parameters may be
stratified multiple times, which corresponds to adding more subscripts.
-->

### Simple Cross Product

Sometime it's sufficient to construct a product model with one transition
for each edge of the graph Cartesian product.  For example, imagine a
simple infection model $$M_{i}$$, in which all compartments are stratified together
by some demographic variable.  Assume each component
transition rate involves no compartments other than its source compartment.
Then the stratified model is a simple product of the infection model
with the stratification.
The compartments of the product are labeled using subscripts,
and the infection transitions are replicated
in each stratum, with stratified compartment names substituted and
subscript added to all parameters.  For example, given a model with
transition from $$x$$ to $$y$$ at rate $$\lambda x$$, stratified by crossing with
a simple model providing two demographic states $$a$$ and $$b$$,
we would construct a product model

<source-file filename="XYab.sage.step" display="XYab-square.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: XYab.sage.out.tex XYab.tex
# produces: XYab-square.tex
import os
import sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
from boxmodel import *
from boxmodelproduct import *

lb = SR.symbol( 'lmbda', latex_name='\\lambda' )
X,Y,a,b,alpha = SR.var('x y a b alpha')
XY = BoxModel( DiGraph( [ (X, Y, lb*X) ] ), [X, Y] )
ab = BoxModel( DiGraph( [ (a, b, alpha) ] ), [a,b] )
XYab = BoxModelProduct( XY, ab )
write_product_formula( XY, ab, XYab, 'XYab.tex', op=r'\square', size2=(1,3), size12=(4,3) )
#XYab.plot_boxes( 'XYab.boxes.tex', figsize=(7,1) )
#XYab.plot_boxes( 'XYab.boxes.tex-inline', inline=True, figsize=(7,1) )

var( 'rho sigma' )
abrs = ab.add_transitions( [ (a,b,rho*a), (b,a,sigma*b) ] )
XYabrs = BoxModelProduct( XY, abrs )
write_product_formula( XY, abrs, XYabrs, 'XYab-square.tex', op=r'\square' )
</source-file>.

Thus by crossing with the $$a$$-$$b$$ model, the single row of the
$$x$$-$$y$$ model gets replicated once for each compartment of the
$$a$$-$$b$$ model.  Symmetrically, the full $$a$$-$$b$$ model is
replicated once for each compartment of the $$x$$-$$y$$ model.

This simple Cartesian product of models is defined by the following
formula.

**Definition.**  The **simple cross product** of models $$M_1,\ldots,M_n$$
is defined as follows:

* $$V(M_1\,\square\,\cdots\,\square\,M_n) = V(M_1)\times\cdots\times V(M_n)$$
(see Appendix for set product operations).
* $$E(M_1\,\square\,\cdots\,\square\,M_n) = \cup_{\{\,(v_1,\ldots,v_n)\in V(M_1)\times\cdots\times V(M_n)\,\}} \cup_{i\in\{1,\ldots,n\}} \cup_{\{\,w,r\mid v_i\xrightarrow{r}w\in E(M_i)\,\}}$$ $$\operatorname{stratify}((v_1,\ldots,v_n),w,r,(M_1,\ldots,M_n),i)$$

where

* $$\operatorname{stratify}((v_1,\ldots,v_n),w,r,(M_1,\ldots,M_n),i) =$$ $$(v_1,\ldots,v_n)\xrightarrow{r_s}(v_1,\ldots,v_{i-1},w,v_{1+i},\ldots,v_n)$$,

where $$r_s$$ is the rate $$r$$ with the name of $$v_i$$ replaced by the
name of the stratified vertex $$(v_1,\ldots,v_n)$$ and all parameters
subscripted by $$v_1,\ldots,v_{i-1},v_{i+1},\ldots,v_n$$.  

The name of a product compartment $$(v_1,\ldots,v_n)$$ can be constructed
in various ways.  It might be the name of $$v_1$$ subscripted by the names of
the other compartments $$v_2,\ldots,v_n$$, or it might be $$X$$ subscripted
by all the compartments' names, or some other rule might be used.

### Cross product with interactions

Unfortunately, the above definition of the cross product is not suitable
for even a simple SI example with
transition rate $$\beta S I$$, because this model violates the assumption that
the rate involves no compartments other than $$S$$.  In this model it's
reasonable to believe that either stratified $$S$$ class can be infected by
individuals of both stratified $$I$$ classes.  This requires the $$S$$ and
$$I$$ variables in that transition rate to be stratified separately, and a
transition to be constructed for every combination
of stratified compartments.  The correct product model is this one, with
the one edge replicated four times, not only twice (with a trivial
stratification model, for simplicity):

<source-file filename="SIab2.sage.step" display="SIab.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIab2.sage.out.tex SIab.tex
import os
import sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
from boxmodel import *
from boxmodelproduct import *

S, I, a, b, beta = SR.var( 'S I a b beta' )
SI = BoxModel( DiGraph( [ (S, I, beta*S*I) ] ), [S,I] )
ab = BoxModel( DiGraph( {a:{b:[]}} ), [a,b] )
SIab = BoxModelProduct( SI, ab )
#SIab.plot_boxes( 'SIab.boxes.tex', figsize=(7,2) )
write_product_formula( SI, ab, SIab, 'SIab.tex', op=r'\square', size1=(4,1), size2=(1,3), size12=(5,3) )
</source-file>.

If we used the simple cross product, we would not generate the correct
sum over $$\beta$$ and $$I$$ variables.

To implement this, we need an extended product operation that provides
stratification for the "catalyst" $$I$$ in the $$\beta S I$$ transition
as well as the source $$S$$.  The simple cross product operation can
be extended in this way to become a full cross product operation.

Along with that extension, at this point I will introduce a complete
definition of the cross product operation, including some details that
will only become relevant in later examples.

**Definition.**  A **cross product** $$M_1\,\square\,\cdots\,\square\,M_n$$
of models $$M_1,\ldots,M_n$$ is a box model $$M$$ such that

* $$E(M) = \cup_{i\in\{1,\ldots,n\}} \cup_{s\xrightarrow{r}t\in E(M_i)} \Xi(s\xrightarrow{r}t,i)$$

where

* <latex>$\Xi(s\xrightarrow{r}t,i) = \Xi_\square(s\xrightarrow{r}t,i) = \begin{cases}
  \{\,S\xrightarrow{\Phi_r(r,S,i_s,T)}T \mid S\in V_M, i_s\in \Sigma(s,S), \\
    \quad T\in\Omega_1( S, i_s, s, t, r, i )\,\} \\
    \quad\quad\text{if $r$ is linear in $s$} \\
  \{\,S\xrightarrow{\Phi_{2r}(r,S,i_s,C,i_c,T)}T \mid S\in V_M, i_s\in\Sigma(s,S), \\
    \quad C\in V_M, i_c\in\Sigma(c,C), T\in\Omega_2( S, i_s, C, i_c, s, c, t, r, i )\,\} \\
  \mbox{} \cup \{\,S\xrightarrow{\Phi_{1r}( S, i_s, i_c, s, t, r, i )}T \mid S\in V_M, i_s\in\Sigma(s,S), \\
    \quad i_c\in\Sigma(c,S), T\in\Omega_{2i}( S, i_s, i_c, s, c, t, r, i )\,\} \\
    \quad\quad\text{if $r$ is bilinear in $s$ and $c$} \end{cases}
$\\*</latex>
generates the set of all product edges derived from the
edge $$s\xrightarrow{r}t$$.
* $$V_M = V(M_1)\times\cdots\times V(M_n)$$.
* $$\Sigma(v,V)$$ is the set of **inclusions** of compartment $$v$$ in the
tuple $$V$$, which is a set of indices $$i$$ for which the $$i$$th entry in
the tuple is $$v$$.
In this stratification example, we only require simple inclusion in
the $$i$$th model,
$$\Sigma_1(v,(v_1,\ldots,v_n);i)=\{i\}$$ if $$v_i=v$$, else $$\{\}$$,
when stratifying a transition of that model.  In some cases, as we will
see, we will require a full inclusion function allowing "cross interactions",
as we need to allow
compartments from different component models to interact with each other:
$$\Sigma_c(v,(v_1,\ldots,v_n))=\{\,j \mid v_j=v\,\}$$.
* $$\Omega_1( S, i_s, s, t, r, i ) = \{\,(S_1,\ldots,S_{i_s-1},t,S_{i_s+1},\ldots,S_n)\,\}$$
is a **unary operation** defining the set of output (target) compartments
produced by a given transition
acting on source compartment $$S$$.  Here we provide a simple definition where
$$S$$ just goes to the corresponding compartment $$T$$ in the same
stratification of the model, but
we allow for variant products defined by a different unary operation.
* $$\Omega_2( S, i_s, C, i_c, s, c, t, r, i ) = \{\,(S_1,\ldots,S_{i_s-1},t,S_{i_s+1},\ldots,S_n)\,\}$$
is a **binary operation** defining the set of output (target) compartments
produced by a given transition
acting on source compartment $$V$$ when compartment $$C$$ is the catalyst.
Here as well, we simply transform $$S$$ into its stratified counterpart
$$T$$, but 
we allow for variant operations in which the same $$S$$ transitions to
different targets depending on $$C$$.
* $$\Omega_{2i}( S, i_s, i_c, s, c, t, r, i )$$ is a variant binary operation
providing additional transitions in the case that $$s$$ and $$c$$ are both
components of the same compartment $$S$$.  This allows for a 
within-compartment interaction that is distinct from an interaction
between two individuals of the same compartment.
* $$\Phi_r$$, $$\Phi_{2r}$$, and $$\Phi_{1r}$$ are **rewritings** of
transition rates.  We construct a rewritten rate for each edge of
the product model
based on its original rate $$r$$, by replacing the source $$s$$ by $$V$$, the
catalyst $$c$$ by $$C$$ (if present), and adding subscripts to all
parameters.  Parameters are subscripted by the compartment names indicating
the stratification of the source compartment, in the simple case.  When
a single transition is replicated to multiple output compartments, it's
necessary to add subscripts indicating the output compartments; when it's 
replicated using multiple catalyst compartments, we need subscripts naming
the catalyst, and when it's replicated multiple times using different
inclusions of compartments we need subscripts distinguishing the inclusions
as well.  The software tries to be smart about applying as few subscripts
as are necessary to provide unique parameters for each transition.
* The vertex set $$V(M)$$ is the set of compartments occurring as source or
target vertices in the above set of edges, which may or may not be equal
to the product set $$V_M$$.

This is a fairly general framework for defining products, at least in a
world of linear and bilinear reactions among compartments.  If transitions
arise whose rates
are arbitrary functions of compartment sizes, we'll need to allow users to
supply additional $$\Xi$$ and $$\Omega$$ functions to generate product
transitions and rewrite their rates.

This product operation generates the correctly stratified $$SI$$ model
shown above.  In this case it's not necessary to distinguish which inclusion
function $$\Sigma$$ it uses, because both produce the same result.  In the
next model it does make a difference.

## Example: Infectious dynamics of couples (ordered pairs)

Consider a system of pairs of individuals, where either can
be susceptible or infected at any time.  The above definition
with the simple inclusion function $$\Sigma_1$$ produces this
model:

<project-file filename=SI-pair-naive.boxes.crop.svg/>

This models pairs of individuals taken from two completely separate,
non-interacting populations.  The second individual of a pair can't
infect the first individual of any pair.  We want a model that allows
interactions across that division, where each S individual
in either position of any paired compartment can be infected by any I
individual in either position of any compartment: there are four such S types
and four such I types, so there will be 16 of these infection transitions.

In all we will have 18 transitions, including within-compartment
infection events in compartments SI and IS.
Using the full inclusion function $$\Sigma_c$$, which generates
the full set of 18 interactions, we construct this model:

<source-file filename="defpairs.sage.step" display=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: defpairs.sage.out.tex SI-pair.sobj
# produces: SI-pair.boxes.tex SI-pair-naive.boxes.tex
import os, sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
import boxmodel, boxmodelproduct
from dynamicalsystems import subscriptedsymbol

def SI_combiner( s, pos, *ss ): # transform e.g. (S, 2, I) to (I, S)
    cs = list( ss )
    cs.insert( int(pos)-1, s )
    #print 'combine', s, pos, ss, ':', tuple(cs)
    return tuple(cs)
S, I, beta = SR.var( 'S I beta' )
SI = boxmodel.BoxModel( DiGraph( [ (S, I, beta*S*I) ] ), [S, I] )

SI2_naive = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    single_edge_generator=boxmodelproduct.simple_edge_stratifier,
    vertex_namer=boxmodelproduct.x_namer,
    param_relabeling=boxmodelproduct.full_param_relabeling
)
SI2_naive.plot_boxes( 'SI-pair-naive.boxes.tex', figsize=(7,7) )

SI2 = boxmodelproduct.power( SI, 2,
    param_relabeling=boxmodelproduct.full_param_relabeling
)
SI2.plot_boxes( 'SI-pair.boxes.tex', figsize=(8,8) ) 

save_session( 'SI-pair' )

ltx = latex_output( 'defpairs.sage.out.tex' )
ltx.write( SI2.ode() )
ltx.close()
exit(0r)
</source-file>

<project-file filename="SI-pair.boxes.crop.svg"/>.

<latex>\vspace{24pt}</latex>

<project-file filename="defpairs.sage.out.tex"/>

[Note: It's more common to consider pair models together with pair-formation and
breakup events, with compartments for unpaired individuals.  We can add this
if needed.]

## Example: Infectious dynamics of couples (unordered pairs)

In some cases we don't want to track the order of the individuals
in a pair -- we don't care about the difference between $$(S,I)$$ and
$$(I,S)$$, and we just want to distinguish the number of
people infected in each pair.

This unordered pair dynamics must be consistent with the above,
ordered-pair model,
because they are different descriptions of the same events. So we should
be able to generate the unordered pair model from the ordered one, by
combining compartments.  We will define the unordered dynamics in that way,
even though we may end up generating them in a more direct way for
efficiency.

The formal construction of the unordered model, then, is

* construct the ordered pair model
* define unordered compartments by counting the number infected in each
of the ordered compartments, that is, construct
an **aggregation function** $$A:V(M)\to V_{\text{new}}$$ assigning
the contents of each compartment to a new, aggregate compartment.
* write equations defining the size of each aggregate compartment as the
sum of its preimages.  In our example, these equations are
$$Z_0 = X_{SS}$$; $$Z_1 = X_{SI} + X_{IS}$$; $$Z_2 = X_{II}$$.
* for each pair $$V,W$$ of aggregate compartments, sum together all the
transition rates from $$V$$ to $$W$$ in the ordered model,
and use the sum equations to
transform the sum into terms of the unordered compartment names.
* For graphical display, we separate the resulting sum into separate
arrows, as it was before we summed them together.
* This step requires us to change the names of the
parameters as well as the compartments, as some of them need to be
assumed equal for this to work.  Thus we have the following definition:

**Definition.** An **aggregation of compartments** of a compartment model is a
model $$A(M)$$, given by a transformation of compartments
$$A(V)$$ for $$V$$ in $$V(M)$$ and a transformation of parameters
$$A(P)$$ for the parameters $$P$$ of $$M$$, in which

* The vertex set of $$A(M)$$ is the set $$\{A(C) \mid C\in V(M)\}$$ of
aggregate compartments
* For each aggregate compartment $$C$$, there is an equality
$$C = \sum_{\{V\mid A(V)=C\}} A$$, equating the aggregate compartment with
the sum of its preimage compartments.
* The set of transitions of $$A(M)$$ is the set of edges
$$S\xrightarrow{\sum_{\{\,V\xrightarrow{r}W\in E(M) \mid A(V)=S, A(W)=T\,\}}A(r)} T$$, where
$$A(r)$$ is the transition rate expression $$r$$ with all 
parameter names $$P$$ replaced by $$A(P)$$, and with sums of
unaggregated compartment names replaced by their equivalent aggregated
compartment names.

This aggregation process doesn't work for general
box models -- the sum of transition rates doesn't necessarily reduce to
terms of the aggregate quantities -- so this can only be done in
particular cases, and the parameters have to be relabeled just right
so that the sums will come out right.

To construct our unordered-pair model, now, we define an aggregation
function for compartments: $$A(X_{pq})=Z_c$$, where $$c$$ is the number of
occurrences of $$I$$ in the labels $$p$$ and $$q$$.  Along with this
we use a congruent aggregation function for parameters,
$$A(\beta_{pqirsj})=\beta_{cd}$$, where $$c$$ is the number of $$I$$
in $$(p,q)$$ and $$d$$ is the number of $$I$$ in $$(r,s)$$.  For the
within-pair rate $$\beta_{pqi}$$
we put $$\beta_c$$, using the count in $$(p,q)$$.

This aggregation produces the following model, with three states instead
of four:

<source-file filename="SI-pair-unordered.sage.step" display=SI-pair-unordered.boxes.crop.svg>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: SI-pair.sobj
# produces: SI-pair-unordered.boxes.tex
import os, sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
import boxmodel, boxmodelproduct
from dynamicalsystems import subscriptedsymbol

#load_session( 'SI-pair' ) # having some trouble with the pickle

S, I, beta = SR.var( 'S I beta' )
SI = boxmodel.BoxModel( DiGraph( [ (S, I, beta*S*I) ] ), [S, I] )
SI2 = boxmodelproduct.power( SI, 2,
    param_relabeling=boxmodelproduct.full_param_relabeling
)

SI_count = lambda t: ( list(t).count(I), )
def param_transform( *t ):
    print 'bm_param',  t, ' ==>> ',
    if t[0] == beta:
	subs = t[1:]
	if len(subs) % 2 == 0 and all( v.is_numeric() if i % (len(subs)/2) == len(subs)/2-1 else v.is_symbol() for i,v in enumerate(subs) ):
	#if len(subs) == 6: # C, C, n, C, C, n
	    print subs[0:2], ':', SI_count(subs[0:2]), ',', subs[3:5], ':', SI_count(subs[3:5])
	    ss = subscriptedsymbol(*((beta,) + SI_count(subs[0:2]) + SI_count(subs[3:5])))
	elif all( x.is_symbol() for x in subs[:-2] ) and subs[-2].is_numeric() and subs[-1].is_numeric():
	#elif len(subs) == 4: # C, C, n, n
	    print subs[0:2], ':', SI_count(subs[0:2])
	    ss = subscriptedsymbol(*((beta,) + SI_count(subs[0:2])))
	else:
	    print; print subs, ':', [ (x.is_symbol(),x.is_numeric()) for x in subs ]
	    raise ValueError, 'how to transform params: {0}'.format(t)
    else:
        ss = subscriptedsymbol( *t )
    print ss
    return ss
z_namer = lambda *t: subscriptedsymbol( 'Z', *t )
uno = SI2.aggregate_compartments( SI_count, param_transform, z_namer ).separate_arrows()
uno.plot_boxes( 'SI-pair-unordered.boxes.tex', figsize=(7,7) )
</source-file>

We can verify that this is equivalent to the original 18 transitions
by noticing that 
$$Z_1$$ stands for two compartments of the unaggregated model.  Thus
each term involving a single $$Z_1$$ is two of the original transitions, and the
$$Z_1^2$$ term is four of them.  With that multiplication, the transitions
can be seen to sum up to the original 18.

## Combining infection models into a multi-infection model

Suppose there are two infectious agents, numbered 1 and 2.  Each is
involved in an SI process (and maybe other compartments downstream from
I). Let us call these models $$M_1$$ and $$M_2$$:

<source-file filename="M1M2.sage.step" display="M1M2.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: M1M2.boxes.tex M1M2.sobj
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct
S, I, beta = (dynamicalsystems.indexer(v) for v in ('S','I','beta'))
def make_M(i):
    return boxmodel.BoxModel( DiGraph(
	    [ (S[i], I[i], S[i]*I[i]*beta[i]) ]
        ), [ S[i], I[i] ]
    )
M1 = make_M(1)
M2 = make_M(2)
M1M2 = boxmodelproduct.union( M1, M2 )
M1M2.plot_boxes( 'M1M2.boxes.tex', figsize=(7,2) )
## save_session seems to be causing a memory-leak freakout here
#save_session( 'M1M2' )
</source-file>.

We wish to combine these infection processes into a single model
$$M_{12}$$, in
which a single susceptible population is infected by both agents, producing
not only the $$I_1$$ and $$I_2$$ classes, but also one or more superinfected
classes.  Order of infection events might matter, in diseases in which
an individual acquiring a second strain develops a weaker infection.

In this case, we need to use the simple inclusion function $$\Sigma_1$$,
because there is no interaction between an individual infected with one
strain and one susceptible to a different strain.  With that, the cross
product as defined gives us this product model:

<source-file filename="SII-simple.sage.step" display="SII-simple.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py 
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SII-simple.boxes.tex
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct

S, I, beta = var( 'S I beta' )
SI = boxmodel.BoxModel( DiGraph( [ (S,I,beta*S*I) ] ), [S,I] )

bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    single_edge_generator = boxmodelproduct.simple_edge_stratifier,
    param_relabeling=boxmodelproduct.full_param_relabeling,
    vertex_namer=boxmodelproduct.x_namer,
)
bopmodel.plot_boxes( 'SII-simple.boxes.tex', figsize=(9,9) )
</source-file>

We need to modify this to account for order of infection, and to allow
for the possibility that both strains can be transmitted in a single
contact event.

[Note: we might want to explain why we didn't worry about double transmission
events in the pair model]

To model partial superinfection, we need to introduce a "half-infected"
class $$H$$, and provide a modified binary operation:

<latex>$\Omega_H( S, i, C, i, S, I, I, r, i ) = \begin{cases}
  \{\, (S_1,\ldots,S_{i_s-1},H,S_{i_s+1},\ldots,S_n) \,\} &
    \text{if $S$ includes $I$} \\  
  \{\, (S_1,\ldots,S_{i_s-1},I,S_{i_s+1},\ldots,S_n) \,\} &
    \text{if not}
\end{cases}$\\*
$\Omega_H( S, i_s, C, i_c, s, c, t, r, i ) = \{\}\text{ otherwise}.$</latex>

[TODO: the vertex set is generated by the $$\Sigma$$ operation,
not by the Cartesian product of vertex sets as claimed in the definition]

<project-file filename=SIH.boxes.crop.svg/>

To account for simultaneous transmission of both strains, we need to
construct a
[strong product](https://en.wikipedia.org/wiki/Strong_product_of_graphs)
rather than the cross product we have been studying.  As described in
the appendix, a strong product contains all the edges of the cross product,
plus edges constructed from edges of multiple component graphs at once.
In this model, the edges of the cross product are transitions where $S$
changes to $I$ in one or the other of the component models, i.e. where an
individual acquires one of the disease strains.  Transitions in which an
individual acquires both strains in a single event are edges of the
strong product.

The strong product of box models can be defined using most of the formal
apparatus of the cross product, but with an edge generation
function that generates derived edges from each combination
of models' edges, rather than from each edge individually.

**Definition.** A **strong product** $$M_1\boxtimes\cdots\boxtimes M_n$$
of box models $$M_1,\ldots,M_n$$ is a box model $$M$$ such that

* $$E(M) = \cup_{\sigma\subseteq\{1,\ldots,n\}} \cup_{\varepsilon\in\prod_{i\in\sigma}E(M_i)} \Xi_\boxtimes( \sigma, \varepsilon )$$
* <latex>$\Xi_\boxtimes( \sigma, \varepsilon ) = \begin{cases}
    \{\,S\xrightarrow{\tilde{\Phi}_r(r,S,\sigma,T)} T \mid S\in V_M, S\times\sigma\subseteq\Sigma_1(s,\{S\}), \\
    \quad T\in \tilde{\Omega}_1(S, \sigma, \varepsilon)\,\} \\
    \qquad\text{if $e=s\xrightarrow{r}t\ \forall e\in\varepsilon$ and $r$ is linear in $s$} \\
    \{\,S \xrightarrow{\tilde{\Phi}_{2r}(r,S,C,\sigma,C)} T \mid S\in V_M, \{S\}\times\sigma\subseteq\Sigma_1(s,\{S\})\\
    \quad C\in V_M, \{C\}\times\sigma\subseteq\Sigma_1(c,\{C\}), \\
    \quad T\in\tilde{\Omega}_2(S, C, \sigma, \varepsilon)\,\} \\
    \qquad\text{if $e=s\xrightarrow{r}t\ \forall e\in\varepsilon$ and $r$ is bilinear in $s$ and $c$.}
\end{cases}$</latex>
* $$V_M=V(M_1)\times\cdots\times V(M_n)$$.
* $$\tilde{\Omega}_1$$ and $$\tilde{\Omega}_2$$ generate the destination
compartment for each transition given the transitions it's constructed from,
and the source and catalyst compartments, and $$\tilde{\Phi}_r$$ and
$$\tilde{\Phi}_{2r}$$ provide rewritten rate expressions.
* The vertex set $$V(M)$$ is the set of compartments occurring as source or
target vertices in the above set of edges, which may or may not be equal
to the product set $$V_M$$.

This definition is surely opaque 
but the upshot is that, in our example,
for every way of locating one or more $S$ labels in a compartment, and for
every way of locating one or more $I$ labels in a compartment, it uses the
$$\tilde{\Omega}_2$$ function to generate a set of transitions resulting
from the interactions of those pairs.  [This is the strong product *without*
cross interactions: there is also a strong product with cross interactions,
but it's more complex and we don't need it for these applications.]
In this model, we want the $$S$$
and $$I$$ labels to match up in the same positions (no cross interactions),
so we provide an
$$\tilde{\Omega}_2$$ function that yields outputs only in those cases.

Using a strong product allows us to produce this model:

<source-file filename="binary-ops.sage.step" display=SIH-strong.boxes.crop.svg>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py 
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIH.boxes.tex SIH-strong.boxes.tex
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct

# In this model we don't distinguish S positions, only I positions,
# being susceptible to strain i means you don't have I (or H) in the
# ith position.
# There is no interaction between e.g. S_j and I_i if j!=i, only between
# S_i (meaning absence of I_i) and I_i.  The i-i interaction generates
# all transition in which infection i is gained.  The interaction iset-iset
# generates all transitions in which exactly that set of infections is
# gained.
H = SR.var('H')
# eis is a tuple of ((s,t,r),i) pairs
def single_dominance_bop( source, iotas, catalyst, iota_s, eis ):
    print 'bop', source, iotas, catalyst, iota_s, eis
    if iotas != iota_s: print 'wrong iota_s'; return Set()
    # do where transitions, source compartments, and catalyst compartments
    # match
    if [ i for e,i in eis ] != list(iotas): print 'wrong iotas'; return Set()
    # do we need this?  check if all source compartments are S
    if any( source[i] is not S for i in iotas ):
	print 'skipping', source, iotas, 'because not all S'
	return Set()
    if I in source:
	return Set( [ tuple( (H if i in iotas else source[i]) for i in range(len(source)) ) ] )
    else:
	return Set( [ tuple( (I if i == ii else H if i in iotas else source[i]) for i in range(len(source)) ) for ii in iotas  ] )

def strong_to_cross_shim( bop ):
    return lambda S, i, C, i_, s, t, r: bop( S, Set([i]), C, Set([i_]), (((s,t,r),i),) )

def single_dominance_with_replacement_bop( source, iotas, catalyst, iota_s, eis ):
    print 'bop', source, catalyst, iotas, iota_s, eis
    if iotas != iota_s: print 'wrong iota_s'; return Set()
    # do where transitions, source compartments, and catalyst compartments
    # match
    if [ i for e,i in eis ] != iotas: print 'wrong iotas'; return Set()
    # do we need this?  check if all source compartments are S
    if any( source[i] is not S for i in iotas ):
	print 'skipping', source, iotas, 'because not all S'
	return Set()
    def gen_set( source, iotas ):
        if I in source:
	    return Set( [ tuple( (H if i in iotas else source[i]) for i in range(len(source)) ) ] )
        else:
	    return Set( [ tuple( (I if i == ii else H if i in iotas else source[i]) for i in range(len(source)) ) for ii in iotas  ] )
    ts = gen_set( source, iotas )
    print 'from', ts
    for knockouts in Subsets( Set( [i for i,s in enumerate(source) if s!=S] ) - Set( iotas ) ):
	ts += gen_set( tuple((S if i in knockouts else s) for i,s in enumerate(source)), iotas )
    print 'with replacement we get', ts
    return ts

def codominance_bop( source, iotas, catalyst, iota_s, eis ):
    print 'codominance bop', source, catalyst, iotas, iota_s, eis
    if iotas != iota_s: print 'wrong iota_s'; return Set()
    # do where transitions, source compartments, and catalyst compartments
    # match
    if [ i for e,i in eis ] != iotas: print 'wrong iotas'; return Set()
    # do we need this?  check if all source compartments are S
    if any( source[i] is not S for i in iotas ):
	print 'skipping', source, iotas, 'because not all S'
	return Set()
    ts = Set( [ tuple( (I if i in iis else H if i in iotas else s) for i,s in enumerate(source) ) for iis in Subsets( Set( iotas ) ) ] )
    ts -= Set( [ t for t in ts if H in t and not I in t ] )
    return ts

def with_dominance_renaming( *args ):
    def unpack( tup ):
	try: return tuple( tup[0] ) + tuple( tup[1] )
	except TypeError: return tup
    if args[1] == (S,S): return args[0]
    import itertools
    #print 'rename', args,
    r = unpack(args)
    #print ':', r 
    return r

S, I, beta = var( 'S I beta' )
def with_dominance_inclusions( c, C ):
    if c is S: return Set( range(len(C)) ) - with_dominance_inclusions( I, C )
    return boxmodelproduct.tuple_inclusions( I, C ) + boxmodelproduct.tuple_inclusions( H, C )

print 'single dominance cross product'
SI = boxmodel.BoxModel( DiGraph( [ (S,I,beta*S*I) ] ), [S,I] )
bpos = { (S,S):(0,0), (I,S):(1,0), (S,I):(0,-1), (I,H):(1,-0.6), (H,I):(0.6,-1), (I,I):(1,-1) }
gpos = { boxmodelproduct.bm_state( *with_dominance_renaming( *x ) ):p for x,p in bpos.iteritems() }
print 'gpos', gpos
bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    binary_operation=strong_to_cross_shim( single_dominance_bop ),
    inclusions=with_dominance_inclusions,
    seed_set = Set( [ (S,S), (S,I), (I,S) ] ),
    param_relabeling=boxmodelproduct.full_param_relabeling,
    compartment_renaming=with_dominance_renaming,
    vertex_namer=boxmodelproduct.x_namer,
    vertex_positioner=lambda *a:gpos
)
bopmodel.plot_boxes( 'SIH.boxes.tex', figsize=(9,9) )

print 'single dominance strong product'
bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    edge_generator=boxmodelproduct.strong_edge_generator,
    binary_operation=single_dominance_bop,
    inclusions=with_dominance_inclusions,
    seed_set = Set( [ (S,S), (S,I), (I,S) ] ),
    param_relabeling=boxmodelproduct.full_param_relabeling,
    compartment_renaming=with_dominance_renaming,
    vertex_namer=boxmodelproduct.x_namer,
    vertex_positioner=lambda *a:gpos
)
bopmodel.plot_boxes( 'SIH-strong.boxes.tex', figsize=(9,9) )

print 'single dominance model with replacement'
bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    edge_generator=boxmodelproduct.strong_edge_generator,
    binary_operation=single_dominance_with_replacement_bop,
    inclusions=with_dominance_inclusions,
    seed_set = Set( [ (S,S), (S,I), (I,S) ] ),
    param_relabeling=boxmodelproduct.full_param_relabeling,
    compartment_renaming=with_dominance_renaming,
    vertex_namer=boxmodelproduct.x_namer,
    vertex_positioner=lambda *a:gpos
)
bopmodel.plot_boxes( 'SIH-across.boxes.tex', figsize=(9,9) )

print 'codominance model'
pos = { 'S':(0,0), 'I_1':(1,0), 'I_2':(0,-1), 'I_1_2':(1,-0.5), 'I_2_1':(0.5,-1), 'I_12':(0.8,-0.8) }
pos = { SR.symbol(x):p for x,p in pos.iteritems() }
#bopmodel = generate_boxmodel_from_binary_operation( codominance_op, seed_set, pos)
bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    edge_generator=boxmodelproduct.strong_edge_generator,
    binary_operation=codominance_bop,
    inclusions=with_dominance_inclusions,
    param_relabeling=boxmodelproduct.full_param_relabeling,
    compartment_renaming=with_dominance_renaming,
    vertex_namer=boxmodelproduct.x_namer,
    vertex_positioner=lambda *a:gpos
)
bopmodel.plot_boxes( 'SIH-II.boxes.tex', figsize=(9,9) )
</source-file>

We can construct products based on different assumptions by writing
slightly different $$\tilde{\Omega}_2$$ functions.
Here is a variant in which an encounter with an infected individual can
knock out one or more strains, as well as infecting the contact with
new ones:

<project-file filename=SIH-across.boxes.crop.svg/>

Here's a variant in which it's also possible to get infected with both strains
equally, in addition to having one infection weaker than the other:

<project-file filename=SIH-II.boxes.crop.svg/>

## Forward equations for a box model

Given a box model, rather than ODE as defined above, we can generate
Kolmogorov forward and backward equations for the model.  Both are
ODEs, but the forward equations are the
ODE of a box model, so we define that system as a box model.

Given an integer
number $$N$$ of total individuals, the compartments, that is the state
variables, for the forward
equations are $$p_{({i_1}/{N},\ldots,{i_n}/{N})}$$ for each
$$(i_1,\ldots,i_n)\in\{0,1,\ldots,N\}^n$$, where $$n$$ is the number of
compartments.  If total mass is conserved, as it often is in box models,
we reduce the dimension by eliminating the last of the model's
compartments, and assume that the sum of all compartments is 1.

For each compartment $$X$$ let $$\mathbf{e}_X$$ be the vector
$$(0,\ldots,0,1,0,\ldots,0)$$ with 1 in the place corresponding to 
compartment $$X$$.

The transitions are
$$p_S \xrightarrow{r(S)p_S} p_{S-{\mathbf{e}_s}/{N}+{\mathbf{e}_t}/{N}}$$
for each transition with source, target, and rate $$s,t,r$$ of the original
box model, and for every state $$S$$,
where $$r(S)$$ is the rate $$r$$ evaluated at the state $$S$$.

The forward equations themselves are the ODE of this box model, as defined
above.

For example, for a simple SI model with transition $$\beta S I$$, the
forward equations for $$N=3$$ are

<source-file filename=SI-forward.sage.step display=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxkolmogorov.py $(BoxModels)/kolmogorov.py
# produces: SI-forward-3.tex
from sage.all import *
import os,sys
sys.path.append( os.environ['BoxModels'] )
import boxmodel, boxkolmogorov
load_session( 'SI.sobj' )

S, I, beta = var('S I beta')
SI = boxmodel.BoxModel( DiGraph( [ (S,I,beta*I*S) ] ), [S,I] )
SIf = SI.forward_boxmodel(3)
SIf.ode().write_latex( 'SI-forward-3.tex' )
SIf.plot_boxes( 'SI-forward-3.boxes.tex', figsize=(5,5) )
</source-file>

<project-file filename=SI-forward-3.tex/>
<!--
Here is the box model that has the forward equations as its ODE:

<project-file filename=SI-forward-3.boxes.crop.svg/>.
-->

## To do: forward equations of large power of infection model

In this section, we will document the Sage code (yet to be written)
that implements large powers of a single model efficiently (as in the
$$SI\times SI$$ pair model presented above), binds its transition rate
parameters to something sane, and constructs its forward equations in
a way that collapses to something usable.

With an ordered-$$n$$tuple model, where there are $$N_i$$ instances of
$$I$$ appearing in all the compartments, there are $$N_i$$ infection
transitions
from each $$S$$ entry in every composite compartment of the model to
its infected counterpart compartment.

In the $$n$$th power of a $$k$$-state model, $$N_i$$ is $$1/k$$ of the
total number of entries in compartments, which is $$k^n/k$$ or $$k^{n-1}$$.
There are the same number of $$S$$ entries.
So in all, $$k^{2(n-1)}$$ infection transitions!!

Plus within-group events - in a compartment with $$c$$ $$S$$s and $$d$$
$$I$$s, there are $$cd$$ of these transitions, to the $$c$$ different
post-infection compartments.

Maybe I can generate these directly?  I'm sure, if we let $$\pi_i(C)$$
be the $$i$$th entry of the tuple $$C$$ (the $$i$$th projection function).

* $$E(M^n) = \cup_{i=1,\ldots,k} \cup_{j=1,\ldots,k} \left[\,\{\,V\xrightarrow{\beta V^2}I_i(V) \mid V\in V(M)^n, \pi_i(V)=S, \pi_j(V)=S\,\}\,\right.$$
$$\quad\left. \cup\;\{\,V\xrightarrow{\beta V W}I_i(V) \mid V\in V(M)^n, \pi_i(V)=S, W\in V(M)^n, \pi_j(W)=I\,\}\,\right]$$

where $$I_i(V)$$ is the compartment equal to $$V$$ with the $$i$$th entry
changed to $$I$$.

So in $$SI^n$$, the compartments are $$\{S,I\}^n$$.  The transitions from
a compartment $$V$$ that has $$c$$ $$S$$s (and $$n-c$$ $$I$$s) are:

* $$c(n-c)$$ within-compartment transmissions
* $$c2^{n-1}$$ between-compartment transmissions

Let $$i(V)$$ be the number of $$I$$ entries in $$V$$.

Every compartment is subject to the same force of infection, which is
one piece for every $$I$$ entry in every compartment:

$$F_I = \sum_W i(W) W$$.

We can aggregate
transmission due to interaction between $$V$$ and $$W$$:
the rate is $$(n-i(V)) i(W) \beta V W$$.  Let's aggregate all $$\beta$$
parameters into a single value $$\beta$$ for this, without subscripts.

The combined transitions are

* $$V\xrightarrow{\beta V F_I + i(V) \beta V} I_j(V)$$ for each $$V,j$$, $$\pi_j(V)=S$$.

When we aggregate compartments into $$Z_i = \cup_{i(V)=i} V$$, the
transitions become

* $$Z_i\xrightarrow{r}Z_{i-1}$$
* $$r = \sum_{i(V)=i} (n-i) (\beta V F_I + i \beta V)$$
* $$F_I = \sum_j j Z_j$$
* $$r = (n-i) \beta Z_i F_I + i (n-i) \beta Z_i$$
* $$Z_i \xrightarrow{(n-i)\beta Z_i(i + \sum_j jZ_j)} Z_{i-1}$$.

So I think there isn't much percentage in generating the ordered-$$n$$tuple
powers for high $$n$$ (too many compartments), but we can definitely
produce these aggregated models efficiently.  We don't have to back our
parameter set all the way off to just $$\beta$$, we can use $$\beta_i$$
and $$\beta_{ij}$$ for the terms of that transition rate.

The above is the rule for any binary transition $$V+C\mapsto W$$, I guess.
For a unary transition $$V\xrightarrow{\alpha V} W$$, I suppose it's just

* $$Z_i\xrightarrow{\alpha i Z_i} Z_{i-1}$$ for a certain value of $$i$$.

In a general $$k$$-state model, rather than just one counting subscript
we have $$Z_{\mathbf{c}}$$ where $$\mathbf{c}=(c_1,\ldots,c_k)$$ is the
count of each of the $$k$$ compartments in a tuple of compartments.
Since $$\sum c_i = n$$, one could be omitted, but it's probably simpler
to keep them all, at least for formal definitions.

So for an $$n$$th power of an SIR model:

<source-file filename="SIR-power.sage.step" display=SIR-4.boxes.crop.svg>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# produces: SIR-4.boxes.tex SIR-forward-4.boxes.tex
# produces: SIR-forward-equations-4.tex-inline SIR-4-equations-within.tex-inline
import os, sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
import boxmodel, boxmodelproduct
import dynamicalsystems

S, I, R, beta, gamma = SR.var( 'S I R beta gamma' )
SIR = boxmodel.BoxModel( DiGraph( [ (S, I, beta*S*I), (I,R, gamma*I) ] ), [S, I, R] )

# is this used here?
def agg_power_renaming( model ):
    def apr_m( *t ):
	from collections import Counter
	c = Counter(t)
	counted = tuple( [ c[v] for v in model._vars ] )
	print 'count', t, ':', counted
	return counted
    return apr_m

def agg_param_relabeling( *stuff ):
    if len(stuff) == 5 or str(stuff[0]) == 'gamma':
	return boxmodelproduct.bm_param( stuff[0], *stuff[1] )
    else:
	return boxmodelproduct.bm_param( stuff[0], *(stuff[1] + stuff[3]) )

def agg_power_edge_generator( i ):
    def apeg_i_gen( models, vertex_namer, param_relabeling, compartment_renaming, **other_stuff ):
	# assume models = [ model ]
	# and that's all we use here
        model, = models
	# z classes: ways of having i things assigned to k compartments
	ztuples = list( IntegerVectors( i, length=len(model._vars) ) ) # i, k
	print 'ztuples:', ztuples
	state_index = { v:i for i,v in enumerate(model._vars) }
	bm_state = boxmodelproduct.bm_state
	for source,target,rate in model._graph.edge_iterator():
	    rate_comps = [ x for x in rate.variables() if x in model._vars ]
	    rate_params = set( rate.variables() ) - set( rate_comps )
	    if rate_comps == [] or rate_comps == [source]:
		# unary interaction
	        for t in ztuples:
		    if t[state_index[source]] > 0:
			u = list(t)
			u[state_index[source]] -= 1
			u[state_index[target]] += 1
			sub = { p: param_relabeling( p, t, [], u ) for p in rate_params }
			sub[source] = bm_state( *t )
			yield (bm_state(*t), bm_state(*u), t[state_index[source]] * dynamicalsystems.Bindings( sub )(rate) )
	    elif len(rate_comps) == 2 and source in rate_comps:
		# binary interaction
		catalyst, = set(rate_comps) - set( [source] )
		for t in ztuples:
		    if t[state_index[source]] > 0:
			for y in ztuples:
			    if y[state_index[catalyst]] > 0:
				u = list(t)
				u[state_index[source]] -= 1
				u[state_index[target]] += 1
				sub = { p: param_relabeling( p, t, [], y, [], u ) for p in rate_params }
				sub[source] = bm_state( *t )
				sub[catalyst] = bm_state( *y )
				yield (bm_state(*t), bm_state(*u), t[state_index[source]] * y[state_index[catalyst]] * dynamicalsystems.Bindings( sub )(rate))
				if y == t:
				    sub.update( { p: param_relabeling( p, t, [], [], u ) for p in rate_params } )
				    yield (bm_state(*t), bm_state(*u), t[state_index[source]] * t[state_index[catalyst]] * dynamicalsystems.Bindings( sub )(rate))
	    else:
		raise BoxModelProductException, "Weird rate, " + str(rate)
    return apeg_i_gen

def agg_pos( graph, _ ):
    directions = [ 0 ] + [ pi/(n+2) for n in range(len(graph.vertex_iterator().next().operands())) ]
    rotations = [ matrix( [[cos(th),sin(th)],[-sin(th),cos(th)]] ) for th in directions ]
    positions = {
	t: sum( (r*vector((i,0)) for r,i in zip(rotations,t.operands()[:-1])) )
	for t in graph.vertex_iterator()
    }
    return positions

z_namer = lambda *t: dynamicalsystems.subscriptedsymbol( 'Z', *t )

SIR4 = boxmodelproduct.BoxModelProduct( SIR,
    edge_generator=agg_power_edge_generator(4),
    param_relabeling=agg_param_relabeling,
    compartment_renaming=agg_power_renaming(SIR),
    vertex_namer=lambda *ss: dynamicalsystems.subscriptedsymbol( 'Z', *ss ),
    vertex_positioner=agg_pos
)
SIR4.combine_arrows().plot_boxes( 'SIR-4.boxes.tex', figsize=(7,7), edge_labels=False )

import boxkolmogorov
SIR4f = SIR.forward_boxmodel( 4 )
SIR4f.plot_boxes( 'SIR-forward-4.boxes.tex', figsize=(7,7), edge_labels=False )
SIR4f.ode().write_latex( 'SIR-forward-equations-4.tex-inline', inline=True )

# set all between-compartment infection rates to zero
psubs = {}
def xparam( *stuff ):
    print 'test:', stuff
    if len( stuff ) != 4:
	global psubs
	psubs[ SIR4._param_namer( *stuff ) ] = 0
	print 'psubs:', stuff
    return boxmodelproduct.bm_param( *stuff )
for v,w,e in SIR4._graph.edge_iterator():
    print 'edge:', e
    e.substitute_function( boxmodelproduct.bm_param, xparam )
print 'psubs', psubs
SIR4_within = SIR4.bind( dynamicalsystems.Bindings( psubs ) )
SIRwo = SIR4_within.ode()
#SIRwo._flow = { k:v.expand() for k,v in SIRwo._flow.iteritems() }
SIRwo.write_latex( 'SIR-4-equations-within.tex-inline', inline=True )
</source-file>

That's interesting - this is very similar to the box model representation
of the SIR model's master (forward) equations:

<project-file filename=SIR-forward-4.boxes.tex/>

The transition rates are different though.  In the forward equations, one
box doesn't contribute force of infection to the other boxes (this is why
the power model has transitions that the forward equations don't have).
The forward equations are similar but not isomorphic to the power model's
equations restricted to only within-group interactions.

Here are the forward equations:

<project-file filename=SIR-forward-equations-4.tex-inline/>

And here are the within-group interactions of the power model:

<project-file filename=SIR-4-equations-within.tex-inline/>

# Appendix: graph products

There are several standard product operations on directed graphs.
All are ways of assigning arrows to the same set of vertices,
which is the Cartesian product (cross product) of the component
graphs' vertex sets.  We use several of them in our definitions
of products of box models.

The **Cartesian product of sets** $$S_1$$, $$S_2$$, $$\ldots$$, $$S_n$$
is the set
$$S_1\times S_2\times\ldots\times S_n = \{\,(s_1,s_2,\ldots,s_n)\mid s_1\in S_1, s_2\in S_2,\ldots, s_n\in S_n\,\}$$.
The elements of $$S_1\times S_2\times\ldots\times S_n$$ are referred to
as **tuples** of elements
of the component sets $$S_1$$, $$S_2$$, $$\ldots$$, $$S_n$$.

We define a **directed graph** (and we are not concerned with undirected
graphs) as a set $$\{\,(v,w,e)\,\}\subseteq V\times V\times E$$, where
$$V$$ is the **vertex set** of the graph and $$E$$ is its set of edge
labels.  Each of these tuples is visualized as an arrow from $$v$$ to
$$w$$ with label $$e$$.  For easy reading, we sometimes represent these
arrows as $$\{\,v\xrightarrow{e} w\,\}$$.
[In our definition of box models, the edge labels $$e$$ are
transition rates.] Note
that this definition allows multiple edges between the same vertices
$$v,w$$, so we are properly discussing directed multigraphs.

## The cross product of graphs

The **cross product**
$$G_1\:\square\:G_2\:\square\:\cdots\:\square\:G_n$$
**of directed graphs**
$$G_1$$, $$G_2$$, $$\ldots$$, $$G_n$$ is a graph whose vertex
set is the Cartesian product $$V_1\times V_2\times\ldots\times V_n$$
of the vertex sets $$V_i$$ of each graph $$G_i$$, and whose edges
are of the form
$$(v_1,v_2,\ldots,v_i,\ldots,v_n)\xrightarrow{e} (v_1,v_2,\ldots,w_i,\ldots,v_n)$$,
where the two tuples are identical in all but the $$i$$'th position,
and where there is an edge connecting $$v_i$$ to $$w_i$$ in $$G_i$$.

Most definitions of this product do not provide labels for the edges
of the product graph.  In the body of this paper we construct these
labels (transition rates) in a variety of ways.

The square symbol is chosen to suggest the shape of the cross product
graph.

## The tensor product

The **tensor product** of directed graphs $$G_1$$, $$\ldots$$, $$G_n$$
is a graph $$G_1\times \cdots\times G_n$$  whose vertex set
is the Cartesian product of the graphs' vertex sets, and which has
an edge from $$(v_1,v_2,\ldots,v_n)$$ to $$(w_1,w_1,\ldots,w_n)$$
if and only if there is an edge from $$v_i$$ to $$w_i$$ in *every*
graph $$G_i$$.

The tensor product is the natural product in the category of graphs
(with graph homomorphisms as the category's morphisms), because the
tensor product of graphs is the graph that has a homomorphism to
each of the component graphs, and such that any other graph that has
a homomorphism to each component also has a homomorphism to the
tensor product graph that commutes.

In some sense, it might make sense to think of this product as
embodying an "and" or "all" operation, where the Cartesian product embodies
an "exactly one of" operation.

## The strong product

The **strong product** $$G_1\,\boxtimes\,G_2$$ of two graphs
$$G_1$$, $$G_2$$ is
the union of the Cartesian product and tensor product of the
graphs.  That is, it contains all the edges of those two
product graphs.

If we extend that definition verbatim to $$n$$ graphs, we get an
"all or exactly one" product. In modeling infectious dynamics
we are probably more interested in a "one or more" product.
Therefore I prefer the following definition:

The **strong product** of graphs $$G_1$$, $$\ldots$$, $$G_n$$, written
$$G_1\,\boxtimes\,G_2\,\boxtimes\,\cdots\,\boxtimes\,G_n$$, is
the graph whose vertex set is the Cartesian product of the graphs'
vertex sets, and which has an edge from
$$(v_1,\ldots,v_n)$$ to $$(w_1,\ldots,w_n)$$ if and only if, for
every $$i$$, either there is an edge from $$v_i$$ to $$w_i$$, or
$$v_i=w_i$$.

This graph is a subgraph of the transitive closure of
the Cartesian product graph, but it is not the transitive closure,
because it's limited to transitive combinations of at most
one edge from each component graph.
