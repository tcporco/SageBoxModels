---
layout: page
title: Definitions of Box Model objects
wmd_project: Notes
wmd_prerequisite_projects:
  BoxModels: Box_Models
---

## Box Model

A **box model** is a directed graph whose vertices are **compartments** and
edges are **transitions**.
Each compartment has a **name**, which is a mathematical variable such as $$X$$.
A transition is an ordered triple $$(s,t,r)$$, where $$s$$ and $$t$$ are the
**source** and **target** compartments of the transition, and $$r$$ is its
**rate**, which is a function of the compartments' names.
Any variable involved in a transition rate that is not the name of a
compartment is a **parameter** of the model.  Let $$C_M=\{c_1,\ldots,c_n\}$$
be the set
of compartments of model $$M$$ and let $$P_M=\{p_1,\ldots,p_m\}$$ be the set of all its
transitions' parameters; then each transition rate is a function
$$r(c_1,\ldots,c_n,p_1,\ldots,p_m)\in\mathbb{R}$$.

A box model is associated with an **ODE**, whose state variables are the
compartments' names, and whose flow vector field is constructed from the
transition rates:

$$\frac{dX}{dt} = \sum_{\text{edges }e\text{ entering }X}\text{rate}(e) - \sum_{\text{edges }e\text{ leaving }X}\text{rate}(e)\quad$$ for each compartment $$X$$.

There are also an SDE, a diffusion equation, individual-based models, 
and possibly other models that can be automatically generated to describe
the behavior of this system.

**Example: SI model.**

<project-file filename=SI.boxes.crop.svg/>

This box model has two compartments, S and I.  There is one transition
from S to I, with rate $$\beta S I$$.  Its ODE is

$$\frac{dS}{dt} = -\beta S I$$

$$\frac{dI}{dt} = \beta S I$$.

## Products of box models

A **product** of box models, written $$M_1\times \cdots\times M_n$$, where
each $$M_i$$ is a box model, is a box model whose set of compartments is the
cross product, or
[Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product#Graph_theory),
of the component box models' sets of compartments.  The transitions include
the edges of the Cartesian product of the components' graphs, but the product
may include more transitions as well.

* The compartments of the cross product are tuples $$(c_1,\ldots,c_n)$$
where each $$c_i$$ is a compartment of $$M_i$$.  The name of
compartment $$(c,d,e,\ldots,w)$$ may be $$c_{de\ldots w}$$, or it may
be named $$X_{cde\ldots w}$$, or some other naming may be used.
* For each transition $$T$$ of component model $$M_i$$, with source $$s$$,
target $$t$$, and rate $$r$$, there is a transition from each compartment
$$(c_1,\ldots,c_{i-1},s,c_{i+1},\ldots,c_n)$$ of the product model to
$$(c_1,\ldots,c_{i-1},t,c_{i+1},\ldots,c_n)$$.
Its transition rate is derived from $$r$$.  The product may include other
transitions derived from $$T$$ as well.

I believe there are a few different products that are appropriate
depending on the biology of the model, differing in what transitions
are included and how their rates are constructed.

Before providing examples, here are some useful definitions:

* A **stratification** $$S(X)$$ of a variable $$X$$ in a product of models
$$M_1\times\cdots\times M_n$$, where $$X$$ is a compartment 
of model $$M_i$$, is a compartment
$$(c_1,\ldots,c_{i-1},X,c_{i+1},\ldots,c_n)$$,
where each $$c_j$$ is a compartment of $$M_j$$.  

* A stratification $$S(P)$$
of a parameter $$P$$ of model $$M_i$$, where $$S$$ is defined as above,
is the ordered pair $$(P,(c_1,\ldots,c_{i-1},c_{i+1},\ldots,c_n))$$.
The name given to that stratified parameter may be
$$P_{c_1\ldots c_{i-1}c_{i+1}\ldots c_n}$$,
or some other naming may be used.  As we will see, parameters may be
stratified multiple times, which corresponds to adding more subscripts.

**Example: Simple Cartesian Product**

In many cases each model provides strata for the other(s), in some sense. 
Sometime it's sufficient to construct a product model with one transition
for each edge of the graph Cartesian product.  Assume each component
transition rate involves no compartments other than its source compartment.
The compartments are labeled using subscripts, and transitions are copied
to each stratum, by substituting the subscripted name of the source compartment
and subscripting all parameters.  For example, given a model with
transition from X to Y at rate $$\lambda X$$, stratified by crossing with
a model of two states $$a$$ and $$b$$, we would construct a model

<source-file filename="XYab.sage.step" display="XYab.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: XYab.sage.out.tex XYab.boxes.tex
# produces: XYab-bop.boxes.tex
import os
import sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
from boxmodel import *
from boxmodelproduct import *

lb = SR.symbol( 'lmbda', latex_name='\\lambda' )
X,Y,a,b = SR.var('X Y a b')
XY = BoxModel( DiGraph( [ (X, Y, lb*X) ] ), [X, Y] )
ab = BoxModel( DiGraph( {a:{b:[]}} ), [a,b] )
XYab = BoxModelProduct( XY, ab )
XYab.plot_boxes( 'XYab.boxes.tex', figsize=(7,1) )
XYab.plot_boxes( 'XYab.boxes.tex-inline', inline=True, figsize=(7,1) )
</source-file>.

In the simple Cartesian product of models, we construct transitions by
the following rule:

* for each component model $$B_i$$
    * for each transition of $$B_i$$, from $$s$$ to $$t$$ with rate $$r$$
        * for each stratification $$S(s)$$ of $$s$$
            * include a transition from $$S(s)$$ to $$S(t)$$,
whose transition rate
is constructed from $$r$$ by replacing $$s$$ by $$S(s)$$ and replacing all
parameters $$P$$ by $$S(P)$$.

**Example: Stratifying multiple interacting compartments**

The above stratification is not suitable for even a simple SI example with
transition rate $$\beta S I$$, because this model violates the assumption that
the rate involves no compartments other than $$S$$.  In this model it's
reasonable to believe that either stratified $$S$$ class can be infected by
individuals of both stratified $$I$$ classes.  This requires the $$S$$ and
$$I$$ variables in that transition rate to be stratified separately, and a
transition to be constructed for every combination
of stratified compartments.  The correct product model is this one:

<source-file filename="SIab2.sage.step" display="SIab2.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIab2.sage.out.tex SIab2.boxes.tex
import os
import sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
from boxmodel import *
from boxmodelproduct import *

S, I, a, b, beta = SR.var( 'S I a b beta' )
SI = BoxModel( DiGraph( [ (S, I, beta*S*I) ] ), [S,I] )
ab = BoxModel( DiGraph( {a:{b:[]}} ), [a,b] )
SIab = BoxModelProduct( SI, ab )
SIab.plot_boxes( 'SIab.boxes.tex', figsize=(7,2) )
</source-file>.

If we used the simple Cartesian product, we would not generate the correct
sum over $$\beta$$ and $$I$$ variables.

To get this right, we may need to construct transitions as follows:

* for each component model $$B_i$$
    * for each transition of $$B_i$$, from $$s$$ to $$t$$ with rate $$r$$
        * for every tuple of stratifications $$(S(s),S_1(X_1),\ldots,S_k(X_k))$$,
where $$X_1,\ldots,X_k$$ are all the compartments other than $$s$$ whose
names appear in $$r$$
            * include a transition from $$S(s)$$ to $$S(t)$$
whose rate is constructed from $$r$$ by replacing $$s$$ by $$S(s)$$,
each $$X_j$$ by $$S_j(X_j)$$, and each parameter
$$P$$ by $$S_n(\cdots S_1(S(P))\cdots)$$.

That would suffice for the above example.  Still, transitions whose rates
are arbitrary functions of compartment sizes will probably not be handled
adequately by this rule, and we'll need to allow users to supply their
own rules for creation of transitions in the product model.

Can I redefine this and the previous case using a binary relation of the
form $$\text{source}+\text{catalyst}\to(\text{destination}, \text{rate})$$?

I think so: it will require a concept of **inclusion** of a compartment
in another.  The compartments
of a compartment model are a partition of the population, and
a product model's compartments are set-theoretical intersections of the
component model's compartments.  For example, compartment $$S_b$$ in the
above example is the intersection of the sets $$S$$ and $$b$$.  Thus $$S_b$$
is a subset of $$S$$ and of $$b$$.  For precision, we'll say there is an
**inclusion** of $$V$$ in $$v$$ when $$V$$ is a subset of $$v$$.
But note there may be multiple such inclusions, for example when $$V$$ is
$$(v,v)$$.  The "for every" clauses in the definition below must be applied
once to each such inclusion, not once to each supercompartment $$v$$.
We make the possible different inclusions $$\iota$$ explicit by writing
$$V\xrightarrow[\iota]{}v$$.

Given that, here is a definition of the cross product:

The vertex set of the cross product of box models is the Cartesian product
of their vertex sets.  Its edges are defined by the following relation:

* For every edge $$(v,w,r)$$ of each component model
    * if the rate is a constant multiple of the source $$v$$
        * for every inclusion of every compartment $$V$$ in $$v$$
            * produce a transition from $$V$$ to the corresponding $$W$$
with stratified rate
    * if the rate $$r$$ is a product of the source $$v$$ and a second
compartment $$c$$, which we will call a **catalyst**
        * for every inclusion of every compartment $$V$$ in $$v$$, for every inclusion of every compartment $$C$$ in $$c$$
            * produce a transition from $$V$$ to corresponding $$W$$
with appropriately stratified rate

or $$M = M_1\times\cdots\times M_n$$ if

$$E(M) = \cup_{M_i}\cup_{(v,w,r)\in E(M_i)}\operatorname{strat}(v,w,r)$$

where

<latex>$\operatorname{strat}(v,w,r) = \begin{cases}
  \{ (V,\operatorname{dest}(w,V),\operatorname{rel}(r,\iota)) \mid v\xrightarrow[\iota]{}V \} & \operatorname{comp}(r) = \{v\} \\
  \{ (V,\operatorname{dest}(w,V),\operatorname{rel}(r,\iota,\iota')) \mid v\xrightarrow[\iota]{}V, c\xrightarrow[\iota']{}C \} & \operatorname{comp}(r) = \{v,c\}
\end{cases}$</latex>

## Example: Infectious dynamics of couples (ordered pairs)

Also, that multiple stratification isn't right for a model of
pairs (or larger groupings) of people.  Here is what we get if we
use that definition as is:

<project-file filename=SI-pair-naive.boxes.crop.svg/>

This models pairs of individuals taken from two completely separate,
non-interacting populations.  The second individual of a pair can't
infect the first individual of any pair.  We want a model that allows
interactions across that division, where each S individual
in either position of any paired compartment can be infected by any I
individual in either position of any compartment: there are four such S types
and four such I types, so we need to generate 16 infection transitions.

Actually we need to generate two more in addition to those, for within-pair
infection events in compartments SI and IS.
In total, we'll generate this model:

<source-file filename="defpairs.sage.step" display=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: defpairs.sage.out.tex SI-pair.sobj
# produces: SI-pair.boxes.tex SI-pair-naive.boxes.tex
import os, sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
import boxmodel, boxmodelproduct
from dynamicalsystems import subscriptedsymbol

def SI_combiner( s, pos, *ss ): # transform e.g. (S, 2, I) to (I, S)
    cs = list( ss )
    cs.insert( int(pos)-1, s )
    #print 'combine', s, pos, ss, ':', tuple(cs)
    return tuple(cs)
S, I, beta = SR.var( 'S I beta' )
SI = boxmodel.BoxModel( DiGraph( [ (S, I, beta*S*I) ] ), [S, I] )

SI2_naive = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    edge_generator=lambda *xs: boxmodelproduct.default_edge_generator( *xs, cross_interactions=False ),
    vertex_namer=boxmodelproduct.x_namer
)
SI2_naive.plot_boxes( 'SI-pair-naive.boxes.tex', figsize=(7,7) )

SI2 = boxmodelproduct.power( SI, 2 )
SI2.plot_boxes( 'SI-pair.boxes.tex', figsize=(7,7) ) 

save_session( 'SI-pair' )

ltx = latex_output( 'defpairs.sage.out.tex' )
ltx.write( SI2.ode() )
ltx.close()
exit(0r)
</source-file>

<project-file filename="SI-pair.boxes.crop.svg"/>.

<latex>\vspace{24pt}</latex>

<project-file filename="defpairs.sage.out.tex"/>

[Note: It's more common to consider pair models together with pair-formation and
breakup events, with compartments for unpaired individuals.  We can add this
if needed.]

We can do the above product in three steps:

* Stratify the SI model doubly, by position in the pair (first or second), and
by partner's infectious class.  This gives us stratified compartments 
of the form $$(S,1,I)$$ (susceptible first
partner, with an infectious counterpart), $$(I,2,S)$$ (infectious second
partner, with a susceptible counterpart), etc.
There are 8 of these compartments -- four S
compartments and four I compartments -- and 16 transitions, one for each
possible contact from an I compartment to an S compartment.

* Merge equivalent classes, relabeling $$(S,1,I)$$ and $$(I,2,S)$$ as
$$(S,I)$$, etc.  This reduces the 8 compartments to 4, giving us the
square we want, with 16 transitions.

* Add the two within-pair infection events, from $$(S,I)$$ and $$(I,S)$$
to $$(I,I)$$.

The first of these is the Cartesian product operation with multiple
stratification that we defined above.  The others are other operations that
are probably also worth defining formally:

### Relabeling compartments

A **relabeling** of compartment model $$M$$ by
a state-relabeling function $$R:C_M\to C_R$$ which maps compartments into
a set of relabeled
compartments $$C_R$$, and a similarly defined parameter-relabeling function
$$R:P_M\to P_R$$, is a compartment model $$R(M)$$ in which

* the compartments of $$R(M)$$ are the set $$\{R(C) | C\in C_M\}$$
* the transitions of $$R(M)$$ are $$(R(s),R(t),R(r))$$ for every transition
$$(s,t,r)$$ of $$M$$, where
$$R(r)(c'_1,\ldots,c'_{n'},p'_1,\ldots,p'_{m'})=r(R(c_1),\ldots,R(c_n),R(p_1),\ldots,R(p_m))$$, given $$C_R=\{c'_1,\ldots,c'_{n'}\}$$, and $$P_R=\{p_1,\ldots,p'_{m'}\}$$.

Here is the above square, relabeled so that order within each pair
isn't distinguished.  [TO DO: no it isn't]

<source-file filename="SI-pair-unordered.sage.step" display=SI-pair-unordered.boxes.crop.svg>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: SI-pair.sobj
# produces: SI-pair-unordered.boxes.tex
import os, sys
sys.path.append( os.environ['BoxModels'] )
sys.path.append( os.environ['SageUtils'] )
from latex_output import *
import boxmodel, boxmodelproduct
from dynamicalsystems import subscriptedsymbol

load_session( 'SI-pair' )

uno = boxmodelproduct.power( SI, 2 )
uno.plot_boxes( 'SI-pair-unordered.boxes.tex', figsize=(7,7) )
</source-file>

### Constructing within-pair events and adding to a box model

These two operations also need to be formalized.  Once that's done
we'll be able to say

$$ M^2 = R(M\times M_{12}\times M_{SI}) + \text{within-pair\,transitions}(R(M\times M_{12}\times M_{SI})) $$

with suitably defined objects $$M_{12}$$, $$M_{SI}$$, $$R$$.

## Example: Infectious dynamics of couples (unordered pairs)

If we want to consider pairs without distinguishing the two individuals by
gender or otherwise differentiating the first from second individual, we
reduce the model to fewer compartments -- for instance, in our example, we
will have one $$(S,I)$$ class standing for both $$(S,I)$$ and $$(I,S)$$.

The unordered pair dynamics must be consistent with the ordered pair model
because they are different descriptions of the same events. So we should
be able to generate the unordered pair model from the ordered one, by
combining compartments.  We will define the unordered dynamics in that way,
even though we're likely to end up generating them in a more direct way for
efficiency.

The formal construction of the unordered model, then, is

* construct the ordered pair model
* collect the compartments of that model into equivalence classes: in the
SI case, $$\{\{(S,S)\}, \{(S,I),(I,S)\}, \{(I,I)\}\}$$.  Sum over those
classes to generate the reduced compartments: in this case
$$Z_{SI} = X_{SI} + X_{IS}$$ where we use the letter $$Z$$ for reduced
(unordered) compartment variables and $$X$$ for the compartments of
the ordered-pair model $$M^2$$.
* Construct reduced transition rates by transforming all $$X$$ variables to
$$Z$$ variables, and assign their source and target vertices to the
appropriate $$Z$$ variables.

Note that this is a different way of combining compartments than the
combining we did when constructing the ordered pair model.  There we
simply defined one compartment to be a synonym of the other and
merged them by moving
the arrows from one to the other; here we define a new compartment to be
the sum of the old compartments and transform the transition rate
expressions as well as relocating their arrows.  Here is a definition
for this operation:

An **aggregation of compartments** of a compartment model is a
transformation $$A(M)$$ of that model by a pair of mappings
$$A:C_M\to C_A$$ and
$$A:P_M\to P_A$$, defined as for a relabeling, such that

* The compartments of $$A(M)$$ are the set $$\{A(C)|C\in C_M\}$$
* There is an equation $$C'_i = \sum C_j$$ for each
compartment $$C'_i$$ of $$A(M)$$, where the sum is over all the compartments
$$C_j$$ such that $$A(C_j)=C'_i$$.
* The set of transitions of $$A(M)$$ is the set of triples
$$(A(s),A(t),(C'_1,\ldots,C'_{n'},P'_1,\ldots,P'_{m'})\mapsto\sum_{\{(s',t',r')|A(s')=A(s), A(t')=A(t)\}}r'(C_1,\ldots,C_n,P_1,\ldots,P_m))$$
generated by all transitions $$(s,t,r)$$ of $$M$$.  The sum is simplified
to a function of the $$C'_i$$ variables using the above sum equations.

That is, the transitions of the model $$M$$ are summed together where their
sources and targets are mapped to the same places by the aggregation, and
sums of compartments of $$M$$ are simplified in terms of the compartments 
of $$A(M)$$. This reduction doesn't work for general
box models, so this can only be done in particular cases.  Also, it's
probably necessary to relabel the parameters just so using $$A(P_i)$$,
so that the sums will come out right.

Given that definition, we define a **sorting operation** $$Z$$ such that
$$Z((S,I))=Z((I,S))=(S,I)$$ (we sort the compartments in the order
$$S, I, R$$).  Using that as an aggregation function, the definition above
gives us $$Z_{SI}=X_{SI}+X_{IS}$$, and we define the unordered pair model as

$$M_U = Z(M^2)$$

where $$M^2$$ is the ordered-pair model defined above.  (Note: To make the
transitions reduce to $$Z$$ expressions we'll have to construct the right
renaming for the indexed $$\beta$$ parameters.)

## Combining infection models into a multi-infection model

Suppose there are two infectious agents, numbered 1 and 2.  Each is
involved in an SI process (and maybe other compartments downstream from
I). Let us call these models $$M_1$$ and $$M_2$$:

<source-file filename="M1M2.sage.step" display="M1M2.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: M1M2.boxes.tex M1M2.sobj
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct
S, I, beta = (dynamicalsystems.indexer(v) for v in ('S','I','beta'))
def make_M(i):
    return boxmodel.BoxModel( DiGraph(
	    [ (S[i], I[i], S[i]*I[i]*beta[i]) ]
        ), [ S[i], I[i] ]
    )
M1 = make_M(1)
M2 = make_M(2)
M1M2 = boxmodelproduct.union( M1, M2 )
M1M2.plot_boxes( 'M1M2.boxes.tex', figsize=(7,2) )
save_session( 'M1M2' )
</source-file>.

We wish to combine these infection processes into a single model
$$M_1\boxtimes M_2$$, in
which a single susceptible class is infected by both agents, producing
not only the $$I_1$$ and $$I_2$$ classes, but also an $$I_{12}$$
class which is infected by both, and potentially an $$I_{21}$$ class as
well, if the order of infection events is important.  This has some
characteristics of the
[strong product](https://en.wikipedia.org/wiki/Strong_product_of_graphs)
of the models' graphs, because it includes at least one diagonal arrow,
representing multiple infection from a single contact,
as well as the horizontal and vertical arrows representing simple infection
events:

<source-file filename="SIII-sketch.sage.step" display="SIII-sketch.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIII-sketch.sage.out.tex SIII-sketch.boxes.tex
import os
import sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct
S = SR.var('S')
I, beta = (dynamicalsystems.indexer(v) for v in ('I','beta'))
SIII = boxmodel.BoxModel(
    DiGraph(
	[ (S, I[i], S*beta[i]*I[i]) for i in (1,2,12,21) ] +
	 [ (I[1],I[12],I[1]*beta[112]*I[12]) ] +
	 [ (I[2],I[21],I[2]*beta[221]*I[21]) ],
	pos = { S:(0,1), I[1]:(1,1), I[2]:(0,0), I[21]:(0.9,0), I[12]:(1,0.1) }
    ), [ S, I[1], I[2], I[12], I[21] ]
)
SIII.plot_boxes( 'SIII-sketch.boxes.tex', figsize=(7,7) )
#SIII.plot().save( filename='SIII-sketch.png', figsize=(3,3), fig_tight=False )
</source-file>.

There may also be cases in which one infection excludes the other:

<source-file filename="SIII-sketch-2.sage.step" display="SIII-sketch-2.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SIII-sketch-2.sage.out.tex SIII-sketch-2.boxes.tex
import os
import sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel
S = SR.symbol('S')
I = dynamicalsystems.indexer('I')
def beta(n): return SR.symbol( 'beta_'+n, latex_name='\\beta_{'+n+'}' )
SIII = boxmodel.BoxModel(
    DiGraph(
	[ (S, I[i], S*beta('0\\to'+str(i))*I[i]) for i in (1,2,12,21) ] +
	 [ (I[1],I[12],I[1]*beta('1\\to12')*I[12]) ] +
	 [ (I[2],I[21],I[2]*beta('2\\to21')*I[21]) ] +
	 [ (I[1],I[2], I[1]*beta('1\\to2') *I[2]) ] +
	 [ (I[2],I[1], I[2]*beta('2\\to1') *I[1]) ],
	pos = { S:(0,1), I[1]:(1,1), I[2]:(0,0), I[21]:(0.9,0), I[12]:(1,0.1) }
    ), [ S, I[1], I[2], I[12], I[21] ]
)
SIII.plot_boxes( 'SIII-sketch-2.boxes.tex', figsize=(7,7) )
#SIII.plot().save( filename='SIII-sketch-2.png', figsize=(3,3), fig_tight=False )
</source-file>.

How are we to define this product of simple SI models? Each of the two
original infection arrows becomes four: the simple infection event from $$S$$,
the superinfection event from the other model's $$I$$ class, an
replacement event in which it replaces the other model's infection, and
one of the two double-infection events.

We can probably use that list to define the "multiple-infection product".
But how does this product generalize to $$n$$ generic compartment models
with some quadratic transition rates and some other rates?

This product is distinguished from the ones above in three ways:

* The order of events makes a difference: infection by agent 1 and then 
agent 2 is different from infection by agent 2 and then agent 1.
* It's possible to "jump forward" over two transitions at once, from
$$S$$ to $$I_{12}$$ for example.
* There are "lateral" transitions, for instance from $$I_1$$ to $$I_2$$
by contact with an $$I_2$$ individual, rather than the more standard
transition to $$I_{12}$$ that would be triggered by that contact.

Let's take those in order.

### Distinguishing the order of events

In a simple, standard cross product of models, compartments $$I_{12}$$ and
$$I_{21}$$ would both be the same compartment $$(I_1,I_2)$$.  The difference
is whether an individual arrives from compartment $$I_1$$ or from $$I_2$$
(we'll consider the double-infection transition from a contact between
$$S$$ and $$I_{12}$$ separately, below).

We can formalize this by identifying the compartments of the product model
with, not the vertices of the Cartesian product of graphs, but directed
paths in the graph.  Instead of ordered pairs such as $$(S_1,I_2)$$, each
compartment of the product model would be a sequence of ordered pairs, such
as $$((S_1,S_2),(S_1,I_2),(I_1,I_2))$$.  Instead of producing a square
graph, this construction produces a branching tree:

<source-file filename="SII-tree.sage.step" display="SII-tree.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: SII-tree.sage.out.tex SII-tree.boxes.tex SII-tree-component.boxes.tex
# produces: SII-strong.boxes.tex
import os
import sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct
S = dynamicalsystems.indexer('S')
I = dynamicalsystems.indexer('I')
def beta(n): return SR.symbol( 'beta_'+n, latex_name='\\beta_{'+n+'}' )
def SI(i):
    return boxmodel.BoxModel(
	DiGraph( [ (S[i], I[i], beta(str(i))*S[i]*I[i]) ] ),
	[ S[i], I[i] ]
    )
SII = boxmodelproduct.BoxModelProduct( SI(1), SI(2),
    vertex_namer = boxmodelproduct.x_namer
)

def recur_edges( xprod, seq=None ):
    edges = []
    targets = set()
    iter = ( xprod._graph.edge_iterator() if seq is None else xprod._graph.outgoing_edge_iterator(seq[-1]) )
    for v,w,e1 in iter:
	sseq = ( ( v, ) if seq is None else seq )
	tseq = tuple( list( sseq ) + [ w ] )
	edges.append( (
	    tuple( [ tuple(s.operands()) for s in sseq ] ),
	    tuple( [ tuple(s.operands()) for s in tseq ] ),
	    e1 # todo: rate
	) )
	targets.add(tseq)
    for tseq in targets:
	edges = edges + recur_edges( xprod, tseq )
    #print 'recur_edges', seq, edges
    return edges

def seq_renaming( *seq ):
    # input: sequence of pairs such as ((S_1,S_2),(S_1,I_2))
    # output: summary sequence such as (2).  Used to construct name such as I_2
    import re
    indices = []
    for v in seq[0]: # un-count pre-existing conditions
	match = re.match( 'I_(.*)', str(v) )
	if match:
	    indices.append(-int(match.group(1r)))
    for s in seq[1:]:
	for v in s:
	    match = re.match( 'I_(.*)', str(v) )
	    if match:
		n = int(match.group(1r))
		if n not in indices and -n not in indices:
		    indices.append(n)
    #print 'seq', seq, indices
    return indices
 
def seq_namer( *indices ): # names of states, with history
    if len(indices):
	def withparens(x): return x if x >= 0 else SR.symbol('Paren_'+str(-x), latex_name='('+str(-x)+')')
	return dynamicalsystems.subscriptedsymbol('I',
	    *[ withparens(x) for x in indices ] )
    return SR.symbol('S')

def seq_pos( *indices ):
    pos = [ 0, 0 ]
    for i in range(len(indices)):
	scale = 1/(1+0.1*i)
	if indices[i] < 0:
	    pos[-indices[i]-1] += 2*scale
	else:
	    pos[indices[i]-1] += scale
    pos = ( pos[0], 1-pos[1] )
    return pos

def strong_recur_edges( xprod, seq=None ):
    edges = []
    targets = set()
    iter = ( xprod._graph.edge_iterator() if seq is None else xprod._graph.outgoing_edge_iterator(seq[-1]) )
    for v,w,e1 in iter:
	sseq = ( ( v, ) if seq is None else seq )
	tseq = tuple( list( sseq ) + [ w ] )
	edges.append( (
	    tuple( [ tuple(s.operands()) for s in sseq ] ),
	    tuple( [ tuple(s.operands()) for s in tseq ] ),
	    e1 # todo: rate
	) )
	targets.add(tseq)
    for tseq in targets:
	edges = edges + recur_edges( xprod, tseq )
    # add transitive edges
    #print 'recur_edges', seq, edges
    return edges

edges_0 = [ (tuple(seq_renaming(*v)),tuple(seq_renaming(*w)),e) for v,w,e in recur_edges(SII) ]
edges = [ (seq_namer(*v),seq_namer(*w),e) for v,w,e in edges_0 ]
vertices = dict( reduce( lambda x,y:x+y, ( [ (v,1), (w,1) ] for v,w,e in edges_0 ) ) )
pos = { seq_namer(*v):seq_pos(*v) for v in vertices }
SItree_graph = DiGraph( edges, pos=pos, multiedges=True )
SItree = boxmodel.BoxModel( SItree_graph )
SItree.plot_boxes( 'SII-tree.boxes.tex', edge_labels=False, figsize=(7,7) )

edges_0 = [ (tuple(seq_renaming(*v)),tuple(seq_renaming(*w)),e) for v,w,e in recur_edges(SII, (SII._tuples[0],)) ]
edges = [ (seq_namer(*v),seq_namer(*w),e) for v,w,e in edges_0 ]
vertices = dict( reduce( lambda x,y:x+y, ( [ (v,1), (w,1) ] for v,w,e in edges_0 ) ) )
pos = { seq_namer(*v):seq_pos(*v) for v in vertices }
SItree_graph = DiGraph( edges, pos=pos, multiedges=True )
SItree = boxmodel.BoxModel( SItree_graph )
SItree.plot_boxes( 'SII-tree-component.boxes.tex', edge_labels=False, figsize=(7,7) )

SII_strong = boxmodelproduct.strong_product( SI(1), SI(2),
    vertex_namer = boxmodelproduct.x_namer
)

edges_strong = [ (tuple(seq_renaming(*v)),tuple(seq_renaming(*w)),e) for v,w,e in recur_edges(SII_strong, (SII_strong._tuples[0],)) ]
edges = [ (seq_namer(*v),seq_namer(*w),e) for v,w,e in edges_strong ]
vertices = dict( reduce( lambda x,y:x+y, ( [ (v,1), (w,1) ] for v,w,e in edges_strong ) ) )
pos = { seq_namer(*v):seq_pos(*v) for v in vertices }
print 'strong edges:', edges_strong
SII_strong_graph = DiGraph( edges, pos=pos, multiedges=True )
SII_strong = boxmodel.BoxModel( SII_strong_graph )
SII_strong.plot_boxes( 'SII-strong.boxes.tex', edge_labels=False, figsize=(7,7) )

</source-file>.

It generates some extra edges, starting at places other than $$(S_1,S_2)$$.
We should think about whether those might ever be meaningful.

We can generate just the component we want by specifying a starting
compartment.  In this case the starting compartment is the pair $$(S_1,S_2)$$,
which is labelled $$S$$ in the diagram.

<project-file filename=SII-tree-component.boxes.crop.svg/>

This diagram also makes clear that the sketch above doesn't have enough
arrows.  There are multiple kinds of interactions driving transitions
across each pair of compartments.  There must be more than that as well:
nearly every possible encounter between two types needs at least one
transition, sometimes more.

I have an implementation of this product using a recursive binary relation.
I want to understand a little better what it has to do with the other
formulations in this paper, then I'll write it up.

Here is a hierarchical coinfection model generated by software:

<source-file filename="binary-ops.sage.step" display="bop2.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py 
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: bop.boxes.tex bop2.boxes.tex bop3.boxes.tex bop4.boxes.tex
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct

import operator
# Partial coinfection: I_{ab|cd} means someone has strains a and b fully,
# and c and d partially.
# Represent compartment by ({a,b},{c,d}). ({},{}) is called S, all others
# are called I_something.
# bop is a list of (source,catalyst,[target,...]) triples.
# source, catalyst, and targets are compartments, in the above form.
boplist = ( [ ([()],[x],[(x,),()]) for x in ((1,),(2,)) ]
+ [ ([()],xx,[[(1,)],[(2,)],[(1,),(2,)],[(2,),(1,)]]) for xx in ([(1,),(2,)],[(2,),(1,)]) ]
+ [ ([(x,)],[(y,)],[[(y,)],[(x,),(y,)]]) for x,y in ((1,2),(2,1)) ]
+ [ ([(x,)],y,[[(3-x,)],[(x,),(3-x,)]]) for x in (1,2) for y in ([(1,),(2,)],[(2,),(1,)]) ]
)
#print boplist
def si( tup ):
    #print 'si of', tup
    if len(tup) == 0 or union( *tup ) == []: return SR.symbol('S')
    cs = reduce( lambda s1,s2:s1+str(s2), tup[0], '' )
    csl = cs
    try:
	c2 = reduce( lambda s1,s2:s1+str(s2), tup[1], '' )
	if c2 is not '':
	    csl = csl + '|' + c2
	    cs = cs + '_' + c2
    except IndexError: pass
    #print 'I_' + cs
    return SR.symbol( 'I_' + cs, latex_name='I_{' + csl + '}' )
    #return dynamicalsystems.subscriptedsymbol( 'I', latex_output.wrap_latex(cs) )
pos = { 'S':(0,0), 'I_1':(1,0), 'I_2':(0,-1), 'I_1_2':(1,-0.7), 'I_2_1':(0.7,-1) }
def bsi( x, y, z ):
    return dynamicalsystems.subscriptedsymbol('beta', si(x), si(y), si(z))*si(x)*si(y)
bopgraph = DiGraph( # this isn't working right
    [ (si(s),si(t),bsi(s,c,t)) for s,c,ts in boplist for t in ts if si(t) != si(s) ],
    multiedges=True,
    pos = { SR.symbol(x):p for x,p in pos.iteritems() }
)
bopmodel = boxmodel.BoxModel( bopgraph )
bopmodel.plot_boxes( 'bop.boxes.tex', figsize=(9,9) )

# In this model we don't distinguish S positions, only I positions,
# being susceptible to strain i means you don't have I (or H) in the
# ith position.
# There is no interaction between e.g. S_j and I_i if j!=i, only between
# S_i (meaning absence of I_i) and I_i.  The i-i interaction generates
# all transition in which infection i is gained.  The interaction iset-iset
# generates all transitions in which exactly that set of infections is
# gained.
H = SR.var('H')
# eis is a tuple of ((s,t,r),i) pairs
def single_dominance_bop( source, catalyst, iotas, iota_s, eis ):
    print 'bop', source, catalyst, iotas, iota_s, eis
    if iotas != iota_s: print 'wrong iota_s'; return Set()
    # do where transitions, source compartments, and catalyst compartments
    # match
    if [ i for e,i in eis ] != iotas: print 'wrong iotas'; return Set()
    # do we need this?  check if all source compartments are S
    if any( source[i] is not S for i in iotas ):
	print 'skipping', source, iotas, 'because not all S'
	return Set()
    if I in source:
	return Set( [ tuple( (H if i in iotas else source[i]) for i in range(len(source)) ) ] )
    else:
	return Set( [ tuple( (I if i == ii else H if i in iotas else source[i]) for i in range(len(source)) ) for ii in iotas  ] )

def single_dominance_with_replacement_bop( source, catalyst, iotas, iota_s, eis ):
    print 'bop', source, catalyst, iotas, iota_s, eis
    if iotas != iota_s: print 'wrong iota_s'; return Set()
    # do where transitions, source compartments, and catalyst compartments
    # match
    if [ i for e,i in eis ] != iotas: print 'wrong iotas'; return Set()
    # do we need this?  check if all source compartments are S
    if any( source[i] is not S for i in iotas ):
	print 'skipping', source, iotas, 'because not all S'
	return Set()
    def gen_set( source, iotas ):
        if I in source:
	    return Set( [ tuple( (H if i in iotas else source[i]) for i in range(len(source)) ) ] )
        else:
	    return Set( [ tuple( (I if i == ii else H if i in iotas else source[i]) for i in range(len(source)) ) for ii in iotas  ] )
    ts = gen_set( source, iotas )
    print 'from', ts
    for knockouts in Subsets( Set( [i for i,s in enumerate(source) if s!=S] ) - Set( iotas ) ):
	ts += gen_set( tuple((S if i in knockouts else s) for i,s in enumerate(source)), iotas )
    print 'with replacement we get', ts
    return ts

def codominance_bop( source, catalyst, iotas, iota_s, eis ):
    print 'codominance bop', source, catalyst, iotas, iota_s, eis
    if iotas != iota_s: print 'wrong iota_s'; return Set()
    # do where transitions, source compartments, and catalyst compartments
    # match
    if [ i for e,i in eis ] != iotas: print 'wrong iotas'; return Set()
    # do we need this?  check if all source compartments are S
    if any( source[i] is not S for i in iotas ):
	print 'skipping', source, iotas, 'because not all S'
	return Set()
    ts = Set( [ tuple( (I if i in iis else H if i in iotas else s) for i,s in enumerate(source) ) for iis in Subsets( Set( iotas ) ) ] )
    ts -= Set( [ t for t in ts if H in t and not I in t ] )
    return ts

def with_dominance_renaming( *args ):
    def unpack( tup ):
	try: return tuple( tup[0] ) + tuple( tup[1] )
	except TypeError: return tup
    if args[1] == (S,S): return args[0]
    import itertools
    #print 'rename', args,
    r = unpack(args)
    #print ':', r 
    return r

S, I, beta = var( 'S I beta' )
def with_dominance_inclusions( c, C ):
    if c is S: return Set( range(len(C)) ) - with_dominance_inclusions( I, C )
    return boxmodelproduct.tuple_inclusions( I, C ) + boxmodelproduct.tuple_inclusions( H, C )

print 'single dominance model'
SI = boxmodel.BoxModel( DiGraph( [ (S,I,beta*S*I) ] ), [S,I] )
bpos = { (S,S):(0,0), (I,S):(1,0), (S,I):(0,-1), (I,H):(1,-0.7), (H,I):(0.7,-1), (I,I):(0.8,-0.8) }
gpos = { boxmodelproduct.bm_state( *with_dominance_renaming( *x ) ):p for x,p in bpos.iteritems() }
print 'gpos', gpos
bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    edge_generator=lambda *x: boxmodelproduct.strong_edge_generator( *x, seed_set=Set( [ (S,S), (S,I), (I,S) ] ), bop=single_dominance_bop, inclusions=with_dominance_inclusions ),
    param_relabeling=boxmodelproduct.full_param_relabeling,
    compartment_renaming=with_dominance_renaming,
    vertex_namer=boxmodelproduct.x_namer,
    vertex_positioner=lambda *a:gpos
)
bopmodel.plot_boxes( 'bop2.boxes.tex', figsize=(9,9) )

print 'single dominance model with replacement'
bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    edge_generator=lambda *x: boxmodelproduct.strong_edge_generator( *x, seed_set=Set( [ (S,S), (S,I), (I,S) ] ), bop=single_dominance_with_replacement_bop, inclusions=with_dominance_inclusions ),
    param_relabeling=boxmodelproduct.full_param_relabeling,
    compartment_renaming=with_dominance_renaming,
    vertex_namer=boxmodelproduct.x_namer,
    vertex_positioner=lambda *a:gpos
)
bopmodel.plot_boxes( 'bop4.boxes.tex', figsize=(9,9) )

print 'codominance model'
pos = { 'S':(0,0), 'I_1':(1,0), 'I_2':(0,-1), 'I_1_2':(1,-0.5), 'I_2_1':(0.5,-1), 'I_12':(0.8,-0.8) }
pos = { SR.symbol(x):p for x,p in pos.iteritems() }
#bopmodel = generate_boxmodel_from_binary_operation( codominance_op, seed_set, pos)
bopmodel = boxmodelproduct.BoxModelProduct(
    SI, SI, 
    edge_generator=lambda *x: boxmodelproduct.strong_edge_generator( *x, seed_set=Set( [ (S,S), (S,I), (I,S) ] ), bop=codominance_bop, inclusions=with_dominance_inclusions ),
    param_relabeling=boxmodelproduct.full_param_relabeling,
    compartment_renaming=with_dominance_renaming,
    vertex_namer=boxmodelproduct.x_namer,
    vertex_positioner=lambda *a:gpos
)
bopmodel.plot_boxes( 'bop3.boxes.tex', figsize=(9,9) )
</source-file>

Here is a variant in which an encounter with an infected individual can
knock out one or more of your strains, as well as giving you new ones:

<project-file filename=bop4.boxes.crop.svg/>

Here's a variant in which it's possible to get infected with both strains
equally:

<project-file filename=bop3.boxes.crop.svg/>

Here's a hand-drawn box model with hierarchical coinfection where
one strain can knock out the other.  If this is the model we want
I can look for a general rule that generates it.

<project-file filename=bop.boxes.crop.svg/>

<!---

To think about how to generalize to more than
two states per model, it might be worth thinking carefully through how we
would cross two SIR models with multiple infection.  How many $$R$$
classes would
the product have in the general case?  I think they too would have to be
enumerated in terms of the sequence of
events: $$(i_1,r_1,i_2,r_2)$$ for example.  That history might be considered 
different from $$(i_1,i_2,r_2,r_1)$$, etc.

This suggests a system for creating the compartments of the cross product:
one for each sequence of component transitions.  Given a SIS or SIRS model,
though, or any that contains a cycle of transitions, this system will
produce an infinite set of compartments unless some equivalence is defined
to identify all those sequences with a finite number of states.

Also, there needs to be
a bit more apparatus to produce all the transitions we want, because
there are more transitions in the product than there are sequences of
component transitions: for example, in the sketch above there are 
three transitions corresponding to the sequence $$(i_1,i_2)$$, and
likewise for $$(i_2,i_1)$$.

I guess with full generality there need to be transitions from $$S$$ to
all $$I$$ classes, and from every $$I$$ class to every other $$I$$ class.
How does that generalize to the SIR case? I think recovery events are much
more constrained -- there's probably no co-recovery.  But if there were?
One would recover from any subset of a given set of $$I$$ agents, I guess.
Presumably we wouldn't distinguish the order of recovery, e.g.
between $$r_{12}$$ and $$r_{21}$$,
though, even though we do have separate $$I$$ classes distinguishing
order of infection.  Let's say we did, and had full order of events, with
"jump-overs": [...]

--->

### Transitive transitions ("jump-overs")

The above implementation doesn't generate the diagonal arrows.
First let's consider the "forward" arrows from $$S$$ to the
co-infection compartments $$I_{12}$$ and $$I_{21}$$.  These
are the events that make this a "strong product", the ones
that combine two events of the cross product into one.
Semantically, these denote events in which two transitions
of the cross product happen in a single encounter: one
individual gives the subject two infections at the same time.

First of all, here is an unadorned strong product of $$M_1$$
and $$M_2$$:

<source-file filename="M1M2-strong.sage.step" display="M1M2-strong.boxes.crop.svg">
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxmodelproduct.py
# requires: $(SageDynamics)/dynamicalsystems.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# requires: M1M2.sobj
# produces: M1M2-strong.boxes.tex
import os, sys
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['BoxModels'] )
import dynamicalsystems, latex_output, boxmodel, boxmodelproduct

load_session( 'M1M2' )

SII = boxmodelproduct.strong_product( M1, M2, vertex_namer=boxmodelproduct.x_namer )
SII.plot_boxes( 'M1M2-strong.boxes.tex', edge_labels=False, figsize=(7,4) )
</source-file>

Clearly we need more structure than that.  Try this:

<project-file filename=SII-strong.boxes.crop.svg/>

### Lateral transitions

(to come)

## Forward equations for a box model

Given a box model, rather than ODE as defined above, we can generate
Kolmogorov forward and backward equations for the model.  Both are
ODEs, but the forward equations are the
ODE of a box model, so we define it as a box model.

Given an integer
number $$N$$ of total individuals, the compartments, that is the state
variables, for the forward
equations are $$p_{(\frac{i_1}{N},\ldots,\frac{i_n}{N})}$$ for each
$$(i_1,\ldots,i_n)\in\{0,1,\ldots,N\}^n$$, where $$n$$ is the number of
compartments.  If total mass is conserved, as it often is in box models,
we reduce the dimension by eliminating the last of the model's
compartments, under the assumption that the sum of all compartments is 1.

For each compartment $$X$$ let $$\mathbf{e}_X$$ be the vector
$$(0,\ldots,0,1,0,\ldots,0)$$ with 1 in the place corresponding to 
compartment $$X$$.

The transitions are

$$ (p_S,p_{S-\frac{\mathbf{e}_s}{N}+\frac{\mathbf{e}_t}{N}},r(S) p_S) $$

for each transition with source, target, and rate $$s,t,r$$ of the original
box model, and for every state $$S$$,
where $$r(S)$$ is the rate $$r$$ evaluated at the state $$S$$.

The forward equations themselves are the ODE of this box model, as defined
above.

For example, for a simple SI model with transition $$\beta S I$$, the
forward equations for $$N=3$$ are

<source-file filename=SI-forward.sage.step display=none>
# requires: $(BoxModels)/boxmodel.py $(BoxModels)/boxkolmogorov.py $(BoxModels)/kolmogorov.py
# produces: SI-forward-3.tex
from sage.all import *
import os,sys
sys.path.append( os.environ['BoxModels'] )
import boxmodel, boxkolmogorov
load_session( 'SI.sobj' )

S, I, beta = var('S I beta')
SI = boxmodel.BoxModel( DiGraph( [ (S,I,beta*I*S) ] ), [S,I] )
SIf = SI.forward_boxmodel(3)
SIf.ode().write_latex( 'SI-forward-3.tex' )
</source-file>

<project-file filename=SI-forward-3.tex/>

# Appendix: graph products

There are several standard product operations on directed graphs.
All are ways of assigning arrows to the same set of vertices,
which is the Cartesian product (cross product) of the component
graphs' vertex sets.  We use several of them in our definitions
of products of box models.

The **Cartesian product of sets** $$S_1$$, $$S_2$$, $$\ldots$$, $$S_n$$
is the set
$$S_1\times S_2\times\ldots\times S_n = \{(s_1,s_2,\ldots,s_n)\mid s_1\in S_1\and s_2\in S_2\and\ldots\and s_n\in S_n\}$$.
The elements of $$S_1\times S_2\times\ldots\times S_n$$ are referred to
as **tuples** of elements
of the component sets $$S_1$$, $$S_2$$, $$\ldots$$, $$S_n$$.

We define a **directed graph** (and we are not concerned with undirected
graphs) as a set $$\{(v,w,e)\}\subseteq V\times V\times E$$, where
$$V$$ is the **vertex set** of the graph and $$E$$ is its set of edge
labels.  Each of these tuples is visualized as an arrow from $$v$$ to
$$w$$ with label $$e$$. 
[In our definition of box models, the elements of $$e$$ are
transition rates.] Note
that this definition allows multiple edges between the same vertices
$$v,w$$, so we are properly discussing directed multigraphs.

## The Cartesian product of graphs

The **Cartesian product** (or cross product)
$$G_1\times G_2\times\ldots\times G_n$$ **of directed graphs**
$$G_1$$, $$G_2$$, $$\ldots$$, $$G_n$$ is a graph whose vertex
set is the Cartesian product $$V_1\times V_2\times\ldots\times V_n$$
of the vertex sets $$V_i$$ of each graph $$G_i$$, and whose edges
are of the form $$((v_1,v_2,\ldots,v_i,\ldots,v_n), (v_1,v_2,\ldots,w_i,\ldots,v_n), e)$$, where the two tuples are identical in all but the $$i$$'th position,
and where there is an edge connecting $$v_i$$ to $$w_i$$ in $$G_i$$.

Most definitions of this product do not provide labels for the edges
of the product graph.  In the body of this paper we construct these
labels (transition rates) in a variety of ways.

The Cartesian product of graphs is sometimes written
$$G_1\,\square\, G_2\,\square\cdots\square\,G_n$$, which is visually resonant
with the shape of the product graph.

## The tensor product

The **tensor product** of directed graphs $$G_1$$, $$\ldots$$, $$G_n$$
is a graph $$G_1\cdot G_2\cdot\ldots\cdot G_n$$ whose vertex set
is the Cartesian product of the graphs' vertex sets, and which has
an edge from $$(v_1,v_2,\ldots,v_n)$$ to $$(w_1,w_1,\ldots,w_n)$$
if and only if there is an edge from $$v_i$$ to $$w_i$$ in *every*
graph $$G_i$$.

This is often written $$G_1\times \cdots\times G_n$$ when the $$\square$$
operator is used for Cartesian products,
since this product produces X-shaped diagrams.

The tensor product is the natural product in the category of graphs
(with graph homomorphisms as the category's morphisms), because the
tensor product of graphs is the graph that has a homomorphism to
each of the component graphs, and such that any other graph that has
a homomorphism to each component also has a homomorphism to the
tensor product graph that commutes.

In some sense, it might make sense to think of this product as
embodying an "and" or "all" operation, where the Cartesian product embodies
an "exactly one of" operation.

## The strong product

The **strong product** of two graphs $$G_1$$, $$G_2$$, written
$$G_1\boxtimes G_2$$, is
the union of the Cartesian product and tensor product of the
graphs.  That is, it contains all the edges of the two product graphs.

If we extend that definition to $$n$$ graphs, we get an
"all or exactly one" product. In modeling infectious dynamics
we are probably more interested in a "one or more" product.
Therefore I propose the following definition:

The **strong product** of graphs $$G_1$$, $$\ldots$$, $$G_n$$, written
$$G_1\boxtimes G_2\boxtimes\cdots\boxtimes G_n$$, is
the graph whose vertex set is the Cartesian product of the graphs'
vertex sets, and which has an edge from
$$(v_1,\ldots,v_n)$$ to $$(w_1,\ldots,w_n)$$ if and only if, for
every $$i$$, either there is an edge from $$v_i$$ to $$w_i$$, or
$$v_i=w_i$$.

This graph contains edges belonging to the transitive closure of
the Cartesian product graph, but it is not the transitive closure,
because it's limited to transitive combinations of exactly zero or
one edge from each component graph.
