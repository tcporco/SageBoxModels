---
layout: page
title: The Quotient Problem
wmd_project: Box_Models
---

When order does/doesn't matter in pair model.

## First the plain cross, for when order does matter.

<source-file filename="ordered-pair.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py
# requires: $(SageUtils)/latex_output.py
# produces: ordered-pair.sage.out.tex ordered-pair.boxes.tex
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output
import boxmodel
import dynamicalsystems

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SIR = boxmodel.BoxModel( DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ), [S,I,R] )

def primevar( var ):
    return SR.symbol( str(var)+'prime', latex_name = "{%s}^{\'}" % latex(var) )

prime_rates = dynamicalsystems.Bindings( { mu:primevar(mu), alpha:primevar(alpha) } )

# alternative naming: instead of S_I, X_{SI}
def x_namer( ss ):
    return dynamicalsystems.subscriptedsymbol( 'X', *ss )

op = boxmodel.BoxModelCrossProduct( SIR, SIR.bind(prime_rates),
    vertex_namer=x_namer
)

pair_ode = op.ode()

ltx = latex_output.latex_output( "ordered-pair.sage.out.tex" )

ltx.write( 'SIR pair model:\n', pair_ode )

ltx.close()

op.plot_boxes( 'ordered-pair.boxes.tex', figsize=(5,5) )

sys.exit(0r)
</source-file>

<project-file filename="ordered-pair.sage.out.tex"/>

<project-file filename="ordered-pair.boxes.crop.svg"/>

## Quotient

Here we try to get BoxModelCrossProduct to give us a reduced model, by
combining pairs of states without regard to order.

<source-file filename="unordered-pair.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py
# requires: $(SageUtils)/latex_output.py
# produces: unordered-pair.sage.out.tex unordered-pair.boxes.tex
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output
import boxmodel
import dynamicalsystems

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SIR = boxmodel.BoxModel(
    DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ),
    [S,I,R],
    parameter_dependencies={alpha:[(S, boxmodel.deps.index), (I, boxmodel.deps.sumover)]}
)

# the state combiner I'll use
# sort the states in S,I,R order
SIR_order = { v:i for i,v in enumerate( SIR._vars ) }
def sort_combiner( *vs ):
    return tuple( sorted( vs, key=lambda v: SIR_order[v] ) )

# for the combined variables, 'Z'
def z_namer( ss ):
    return dynamicalsystems.subscriptedsymbol( 'Z', *ss )

up = boxmodel.BoxModelCrossProduct( SIR, SIR,
    state_combiner=sort_combiner,
    vertex_namer=z_namer
)

# just to see if this works, temporarily
up = up.bind( { dynamicalsystems.subscriptedsymbol( 'alpha', x, y ):alpha
	for x in (S,I,R) for y in (S,I,R) } )

pair_ode = up.ode()

ltx = latex_output.latex_output( "unordered-pair.sage.out.tex" )

ltx.write( 'SIR pair model:\n', pair_ode )

ltx.close()

up.plot_boxes( 'unordered-pair.boxes.tex', figsize=(5,5) )

sys.exit(0r)
</source-file>

<project-file filename="unordered-pair.sage.out.tex"/>

<project-file filename="unordered-pair.boxes.crop.svg"/>

## SI Quotient

<source-file filename="SI-quotient.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py
# requires: $(SageUtils)/latex_output.py
# produces: SI-quotient.sage.out.tex
# produces: SI-quotient-ordered.boxes.tex SI-quotient-unordered.boxes.tex
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output
import boxmodel
import dynamicalsystems

S, I, alpha = SR.var( 'S I alpha' )

SI = boxmodel.BoxModel(
    DiGraph( { S:{ I:alpha*S*I } } ),
    [S,I],
    parameter_dependencies={alpha:[(S, boxmodel.deps.index), (I, boxmodel.deps.sumover)]}
)

# alternative naming: instead of S_I, X_{SI}
def x_namer( ss ):
    return dynamicalsystems.subscriptedsymbol( 'X', *ss )

# put primes on the second SI, to distinguish what's what
def primevar( var ):
    return SR.symbol( str(var)+'prime', latex_name = "{%s}^{\'}" % latex(var) )

prime_rates = dynamicalsystems.Bindings( { alpha:primevar(alpha) } )
prime_vars = dynamicalsystems.Bindings( { x:primevar(x) for x in SI._vars } )

op = boxmodel.BoxModelCrossProduct( SI, SI, #.bind(prime_rates + prime_vars),
    vertex_namer=x_namer
)

pair_ode = op.ode()

ltx = latex_output.latex_output( "SI-quotient.sage.out.tex" )

ltx.write( 'SI square:\n', pair_ode )

op.plot_boxes( 'SI-quotient-ordered.boxes.tex', figsize=(5,5) )

# the state combiner I'll use
# sort the state pair in S,I order
SI_order = { v:i for i,v in enumerate( SI._vars ) }
def sort_combiner( *vs ):
    return tuple( sorted( vs, key=lambda v: SI_order[v] ) )

def state_orderer( bm ):
    state_order = { v:i for i,v in enumerate( bm._vars ) }
    def orderer( *vs ):
	return tuple( sorted( vs, key=lambda v: state_order[v] ) )
    return orderer

# for the combined variables, 'Z'
def z_namer( ss ):
    return dynamicalsystems.subscriptedsymbol( 'Z', *ss )

up = boxmodel.BoxModelCrossProduct( SI, SI,
    state_combiner=state_orderer(SI),
    vertex_namer=z_namer
)

# just to see if this works, temporarily
#up = up.bind( { dynamicalsystems.subscriptedsymbol( 'alpha', x, y ):alpha
#	for x in (S,I) for y in (S,I) } )

pair_ode = up.ode()

ltx.write( 'SI triangle:\n', pair_ode )

ltx.close()

up.plot_boxes( 'SI-quotient-unordered.boxes.tex', figsize=(5,5) )

sys.exit(0r)
</source-file>

<project-file filename="SI-quotient.sage.out.tex"/>

<project-file filename="SI-quotient-ordered.boxes.crop.svg"/>

<project-file filename="SI-quotient-unordered.boxes.crop.svg"/>


## Notes on the quotient operation

The above is a model for pairs of people, tracking the state of each member
of the pair.  An $$(S,I)$$ pair is distinguished from an $$(I,S)$$ pair: for
example, to track the states of married men and women or something.

Sometimes we want to track pair states but without order, by combining e.g.
$$(I,S)$$ and $$(S,I)$$ into a single box.  We could call that $$(S,I)$$,
using a sort order on the compartments $$S,I,R$$, or we could use a sort
of chemical notation, $$S_1I_1$$.

Notes on how to implement this:

* Simplest case may be to call BoxModelCrossProduct more or less as it is,
but with some kind of combine() function that transforms the ordered tuples
of the raw Cartesian product of compartments into the destination compartments,
optionally in a many-to-one way.

* We'll need to combine the rates properly.  Formally, a transition rate
between combined compartments is a sum of transition rates between product
compartments, which conveniently simplifies into terms of the combined
variables.

    * This will run into trouble if the rates don't combine just so, because
we need to come out with rates that depend on the combined compartments
rather than the raw compartment-tuples.  In the cases we're thinking of
(powers of a single model) this should work right, but handle cases when it
doesn't.

* Mostly we care about powers -- should we just implement powers?

* We want to do higher powers of models efficiently, for example $$(\mathit{SIR})^{100}$$.
This means don't construct the Cartesian product before reducing it: we have
to construct the reduced product directly. I think this means don't even
construct the 100 models before reducing their product.

    * A: invoke the cross product by passing an iterator rather than a list of
models. This should allow it to use the $$\mathit{SIR}$$ model 100 times without making copies of it.

    * B: special implementation of power?

Start with simple reduce, I think, then assess how to do it on large powers, with or without doing it efficiently.
