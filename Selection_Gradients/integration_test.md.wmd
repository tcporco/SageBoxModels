---
layout: page
title: test scipy.integrate.odeint
wmd_project: test_odeint
wmd_prerequisite_projects:
  Selection_Gradients: Selection_Gradients
---

Seeing what it takes to use `odeint` with some arbitrary python code for computing the flow field at each point during integration.

<source-file filename=test_odeint.sage.step lang=sage>
# requires: $(SageUtils)/latex_output.py
# produces: test_odeint.sage.out.tex trajectory.png
from sage.all import *
from scipy.integrate import odeint
from numpy import arange
import os, sys
sys.path.append( os.environ['SageUtils'] )
from latex_output import *

ltx = latex_output( 'test_odeint.sage.out.tex' )

flow_fn = lambda y,t: [-y[0],-2*y[1]]

soln = odeint( flow_fn, [2,2], arange(0,4.0,0.01) )

ltx.write( "Solve ode from $t=0$ to $4$:" )
ltx.write_block( soln )

lp = list_plot( soln, figsize=(4,4) )
lp.save( 'trajectory.png' )

ltx.close()
</source-file>

<project-file filename=trajectory.png/>

Looks good!!

... I've put that into a LambdaODESystem class in [dynamicalsystems.py](/wmd_files/SageDynamics/dynamicalsystems.py) now...

<source-file filename=test-numerical-odes.sage.step>
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py
# produces: test.png
from sage.all import *
import os, sys
sys.path.append( os.environ['SageDynamics'] )
from dynamicalsystems import *
from numpy import array

flow_fn = lambda y,t: [-2*y[0],-y[1]]

#test_lambda_ode = LambdaODESystem( flow_fn, [SR('y_0'),SR('y_1')] )
test_lambda_ode = LambdaODESystem( lambda y,t: array([-2*y[0], -y[1]]), [SR('y_0'),SR('y_1')] )

s = test_lambda_ode.solve( [5,5] )

p = s.plot( SR('y_0'), SR('y_1'), color='red', figsize=(4,4) )
p.save( 'test.png' )
</source-file>

<project-file filename=test.png/>

<source-file filename=test-ad.sage.step project=Selection_Gradients>
# requires: $(SageUtils)/latex_output.py maclevmodels.py $(SageAdaptiveDynamics)/adaptivedynamics.py maclev-2-2-adap.sobj
# produces: test-ad.sage.out.tex test-ad.png
from sage.all import *
from sage.misc.latex import _latex_file_
from sage.misc.latex import latex
latex.add_to_preamble('\\usepackage{amsmath}')

import os, sys
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageAdaptiveDynamics'] )
from maclevmodels import *
from adaptivedynamics import *
from latex_output import *

load_session('maclev-2-2-adap')

ltx = latex_output_file( tee_to_stdout( open( 'test-ad.sage.out.tex', 'w' ) ) )

maclev_cu = MacArthurLevinsModel(
    x_indices = [0, 1], r_indices = [0, 1],
    b = indexer( lambda i: 1 ),
    m = indexer( lambda i: 1 ),
    c = indexer( lambda i: indexer( lambda l: SR('c_%s(u_%s)' % (l,i)) ) ) )

numeric_params = Bindings(
  { SR.var('r_0'): 1, SR.var('r_1'): 1,
    SR.var('w_0'): 1, SR.var('w_1'): 1,
    SR.var('K_0'): 2, SR.var('K_1'): 2,
    SR.var('gamma'): 1 } )

from sage.symbolic.function_factory import function
mad = NumericalAdaptiveDynamicsModel( maclev_cu.bind( numeric_params ), [ indexer('u') ], bindings = FunctionBindings( {
	function('c_0'): SR( '1/(1+u**2/10)' ).function(SR('u')),
	function('c_1'): SR( '1/(1+(u-1)**2/10)' ).function(SR('u'))
} ) ) 

ms = mad.solve( [ 0.9333, 0.1 ] )

P = reduce( lambda a, b: a+b, ( ms.plot( SR('t'), u, color=c, legend_label='$%s$'%latex(u) )
	for u,c in zip( mad._u_names, ( 'blue', 'red', 'green', 'purple', 'orange' ) ) ) )
P.axes_labels( [ '$t$', '$u$' ] )
P.save( 'test-ad.png', figsize=(4,4) )

ltx.close()
sys.exit()

class LogisticDynamics(PopulationDynamicsSystem) :
	def flow(self):
		return dict( (xi, SR('r_%s'%i)*xi*(1-sum(self.population_vars()))-xi) for i,xi in zip(self._population_indices,self.population_vars()) )

smod = LogisticDynamics( [], [0], indexer('X') )

ltx.write_block( smod )

smad = NumericalAdaptiveDynamicsModel( smod, [ indexer('r') ], bindings={ 'gamma': 1 } )

ltx.close()
sys.exit()
</source-file>

<project-file filename=test-ad.sage.out.latexml.html project=Selection_Gradients/>

<project-file filename=test-ad.png project=Selection_Gradients/>

<source-file filename=sage.mk>
# Makefile to connect the Sage code here with the code in SageDynamics and elsewhere
 
# When we need something from the upstream projects, make it there
$(SageDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageDynamics) $*
 
$(SageAdaptiveDynamics)/% : /proc/uptime
	$(MAKE) --no-print-directory -C $(SageAdaptiveDynamics) $*
 
# The good makefile stuff is upstream, just reuse it
-include $(SageUtils)/sage.mk
-include $(SageUtils)/step.mk
</source-file>
