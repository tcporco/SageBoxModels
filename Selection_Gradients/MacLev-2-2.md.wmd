---
layout: page
title: "Adaptive Geometry and Resource Competition: Two Species, Two Resources"
wmd_project: Selection_Gradients
---

This page investigates the adaptive dynamics of [the Macarthur-Levins resource competition model](/Selection_Gradients/MacLev.html) in the case of two species and two resources.

* See [Selection_Gradients/MacLev](/Selection_Gradients/MacLev.html) for the general model, and the adaptive dynamics formulation we're using here, including the specific questions about the $$a$$ and $$k$$ of the Lotka-Volterra framework.
* See also [Adaptive Geometry and Resource Competition - One Species, One Resource](/Selection_Gradients/MacLev-1-1.html).

We begin by creating and testing a 2-species, 2-resource model.  

<source-file filename=maclev_2_2_defs.py.step lang=python>
# requires: maclevmodels.py $(SageDynamics)/dynamicalsystems.py
from sage.all import *
from sage.misc.latex import _latex_file_

import os
import sys
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageAdaptiveDynamics'] )
from dynamicalsystems import *
from adaptivedynamics import *
from latex_output import *
from maclevmodels import *

# Create the generic 2-species, 2-resources MacLev model, with parameters
# b_i, m_i, c_ij

rescomp = ResourceCompetitionModel( x_indices = [0, 1], r_indices = [0, 1] )

maclev = MacArthurLevinsModel( x_indices = [0, 1], r_indices = [0, 1] )

# create global variables for convenience
r_0, r_1, K_0, K_1, w_0, w_1 = SR.var( 'r_0, r_1, K_0, K_1, w_0, w_1' )
X_0, X_1, R_0, R_1 = SR.var( 'X_0, X_1, R_0, R_1' )

numeric_params = Bindings(
  { r_0: 1, r_1: 1,
    w_0: 1, w_1: 1,
    K_0: 2, K_1: 2 } )

# Create variables and bindings for doing adaptive dynamics of this model:
# map b, m, c to functions of phenotype variables u_i

u_indexer = indexer('u')
u_0, u_1 = (u_indexer[0], u_indexer[1])
gamma = SR.var( 'gamma' )

def quadratic_c_func(i,j):
    if j == 0:
	return 1/(1 + u_indexer[i]**2*5)
    if j == 1:
	return 1/(1 + (u_indexer[i]-1)**2*5)
    return -inf

def quadratic_bindings(indices):
    return Bindings( dict(
        [ (rescomp._indexers['c'][i][0], quadratic_c_func(i,0))
          for i in indices
        ] +
        [ (rescomp._indexers['c'][i][1], quadratic_c_func(1,1))
          for i in indices
        ] +
	[ (rescomp._indexers['b'][i], 1) for i in indices ] +
	[ (rescomp._indexers['m'][i], 1) for i in indices ]
    ) )

def linear_c_func(i,j):
    return j + (1 - 2*j)*u_indexer[i]

def linear_bindings(indices):
    return Bindings( dict(
	(rescomp._indexers['c'][i][j], linear_c_func(i,j))
	for i in indices for j in (0,1) ) )

which_model = 'quadratic'

if which_model == 'quadratic':
	c_func = quadratic_c_func
	bindings_func = quadratic_bindings
	bmc_bindings = bindings_func( (0,1,'i') )

	initial_conditions = Bindings( {
		# in a .sage file, could just write u_0: 1/3
		# in a .py, fractions need special care
		u_0 : Rational('1/3'),
		u_1 : Rational('2/3')
	} )
else:
	c_func = linear_c_func
	bindings_func = linear_bindings
	bmc_bindings = bindings_func( (0,1,'i') )

	initial_conditions = Bindings( {
		# in a .sage file, could just write u_0: 1/3
		# in a .py, fractions need special care
		u_0 : Rational('1/3'),
		u_1 : Rational('5/11')
	} )

gamma_bindings = Bindings( { gamma: 1 } )

ad_bindings = bmc_bindings + gamma_bindings

</source-file>

<source-file filename=maclev-2-2-popdyn.sage.step lang=sage>
# requires: maclev_2_2_defs.py
# requires: $(SageDynamics)/dynamicalsystems.py maclevmodels.py
# produces: maclev-2-2-popdyn.sage.out.tex maclev-2-2-popdyn.png
from maclev_2_2_defs import *

ltx = latex_output( 'maclev-2-2-popdyn.sage.out.tex' )

ltx.write( 'The Mac-Lev model in generic form: ' )
ltx.write_block( maclev )

ltx.write( 'The Mac-Lev model with $b, m$, and $c$ bound to functions of $u$:\n' )
ltx.write_block( maclev.bind( ad_bindings ) )

maclev_initial_system = maclev.bind( ad_bindings + numeric_params + initial_conditions )
p = maclev_initial_system.plot_vector_field( (X_0, 0, 2), (X_1, 0, 2), color="gray", figsize=(5,5) )
p += maclev_initial_system.plot_ZNGIs( (X_0, 0, 2), (X_1, 0, 2), color="gray" )
s = maclev_initial_system.solve( [0, 0.02, 0.05] )
p += s.plot( X_0, X_1, color='red' )
p.save( 'maclev-2-2-popdyn.png' )

# analysis

maclev_abstract = maclev.bind( bmc_bindings ).bind( numeric_params )
int_eq = maclev_abstract.interior_equilibria()
int_eq = int_eq[0]

ltx.write( "The coexistence criteria depend on the invasion rates at the boundary equilibria.\n\n" )

for x_inv, x_res in ( (X_0, X_1), (X_1, X_0) ):
	assume( x_res > 0 )
	assume( x_inv == 0 )
	boundary_solutions = solve( maclev_abstract._flow[x_res] == 0, x_res, solution_dict=True )
	forget()
	if ( len( boundary_solutions ) != 1 ):
		raise Exception( 'wrong number of boundary solutions' )
	boundary_solution = boundary_solutions[0]
	#ltx.write_block( x_res.subs( boundary_solution ) )
	ltx.write( "Invasion of $%s$:\n" % latex( x_inv ) )
	inv_rate_abstract = maclev_abstract._flow[x_inv] / x_inv
	#ltx.write_block( inv_rate_abstract > 0 )
	inv_rate = inv_rate_abstract.subs( boundary_solution ).subs( { x_inv: 0 } )
	ltx.write_block( inv_rate.full_simplify() > 0 )

rescomp_abstract = rescomp.bind( bmc_bindings ).bind( numeric_params )

ltx.write( "But those invasion criteria are really about the resources.\n" ) # The resource levels are:\n" )
ltx.write( latex( rescomp_abstract ) )

for x_inv, x_res in ( (X_0, X_1), (X_1, X_0) ):
	#assume( x_res > 0 )
	#assume( x_inv == 0 )
	assume( R_0 > 0, R_1 > 0 )
	boundary_solutions = solve( [ rescomp_abstract._flow[v] == 0 for v in (x_res, R_0, R_1) ] + [ x_inv == 0 ], [ x_res, x_inv, R_0, R_1 ], solution_dict=True )
	forget()
	#ltx.write( "boundary solutions: $%s$\n" % latex(boundary_solutions) )
	boundary_solutions = [ s for s in boundary_solutions if s[x_res] != 0 ]
	if ( len( boundary_solutions ) != 1 ):
		raise Exception( 'wrong number of boundary solutions' )
	boundary_solution = boundary_solutions[0]
	ltx.write( "Here's a boundary solution: %s\n\n" % latex( Bindings( boundary_solution ) ) )
	#ltx.write_block( x_res.subs( boundary_solution ) )
	ltx.write( "Invasion condition for $%s$:\n" % latex( x_inv ) )
	inv_rate_abstract = rescomp_abstract._flow[x_inv] / x_inv
	#ltx.write_block( inv_rate_abstract > 0 )
	inv_rate = inv_rate_abstract.subs( { x_inv: 0 } )
	ltx.write_block( inv_rate.full_simplify() > 0 )

ltx.write( "In our initial model, $c$ values are" )
for i in ( 0, 1 ):
    for j in ( 0, 1 ):
	cij = rescomp_abstract._indexers['c'][i][j]
	ltx.write_block( cij == (initial_conditions + bmc_bindings)( cij ) )

ltx.close()

#save_session('maclev-2-2-popdyn')
</source-file>

The model equations, according to Sage:

<project-file filename=maclev-2-2-popdyn.sage.out.tex/>

State space of this population dynamics model:

<project-file filename="maclev-2-2-popdyn.png"/>

## Adaptive dynamics of $$u$$

<source-file filename=maclev-2-2-adap.sage.step lang=sage>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageAdaptiveDynamics)/adaptivedynamics.py maclevmodels.py maclev_2_2_defs.py
# produces: maclev-2-2-adap.sage.out.tex maclev-2-2-adap.sobj
# produces: maclev-2-2-u-vs-t.png maclev-2-2-u-vs-u.png maclev-2-2-c-vs-c.png
from maclev_2_2_defs import *

ltx = latex_output( 'maclev-2-2-adap.sage.out.tex' )

ltx.write( 'maclev anyone? ' )
ltx.write_block( maclev )

ltx.write( 'and with the functional and numeric bindings: ' )
ltx.write_block( maclev.bind( ad_bindings + numeric_params ) )

# I don't trust FunctionBindings any more, but I need to use it briefly
# to get tractable adaptive dynamics here.
c_to_fn_bindings = Bindings( dict(
    ( maclev._rescomp_model._indexers['c'][i][j],
      sage.symbolic.function_factory.function( 'c_%s'%j )( u_indexer[i] ) )
    for i in (0,1,'i') for j in (0,1) ) )
c_from_fn_bindings = FunctionBindings( dict(
    ( sage.symbolic.function_factory.function( 'c_%s'%j ),
      c_func(0,j).function( u_indexer[0] ) )
    for j in (0,1) ) )

print 'c_to_fn_bindings:', c_to_fn_bindings
print 'c_from_fn_bindings:', c_from_fn_bindings

print "starting adaptive dynamics"
sys.stdout.flush()

try:
    maclev_adap_c = NumericalAdaptiveDynamicsModel( maclev.bind( c_to_fn_bindings ), 
        [ u_indexer ], bindings=c_from_fn_bindings + ad_bindings + numeric_params )
    #ltx.write( maclev_adap_c._debug_output._output._str )
    ltx.write( 'adaptive dynamics of $u_\cdot$ in that model:' )
    ltx.write_block( maclev_adap_c )
except AdaptiveDynamicsException, e:
    print( r'%s\\Exception: %s' % (e._latex_str, e) )
    sys.stdout.flush()
    ltx.write( e._latex_str, r'\\Exception: %s\\' % e )

print "did adaptive dynamics"
sys.stdout.flush()

#ltx.write( '\\texttt{initial\\_conditions} = %s' % latex( initial_conditions ) )
#ltx.write( 'initial conditions: $%s$\n\n' % latex( [ 0, initial_conditions( u_0 ), initial_conditions( u_1 ) ] ) )

print 'solve'
sys.stdout.flush()

c_evolution = maclev_adap_c.solve( [0, initial_conditions( u_0 ), initial_conditions( u_1 ) ], end_points=1, step=0.02 )

# and plot u vs t
t = maclev_adap_c.time_variable()
u_timeseries = c_evolution.plot( t, u_0 )
u_timeseries += c_evolution.plot( t, u_1, color='red' )
u_timeseries.axes_labels( [ '$t$', '$u$' ] )
u_timeseries.save( 'maclev-2-2-u-vs-t.png', figsize=(4,4) )

# plot phase plane of u vs u
u_phase_plane = c_evolution.plot( u_0, u_1 )
u_phase_plane += maclev_adap_c.plot_vector_field( (u_0,0,1), (u_1,0,1), color='gray', plot_points=19 )
u_phase_plane.axes_labels( [ '$u_0$', '$u_1$' ] )
u_phase_plane.save( 'maclev-2-2-u-vs-u.png', xmin=0, xmax=1, ymin=0, ymax=1,
	figsize=(4,4) )

# plot c_0 vs c_1
c_phase_plane = c_evolution.plot( rescomp._indexers['c'][0][0], rescomp._indexers['c'][0][1] )
c_phase_plane += c_evolution.plot( rescomp._indexers['c'][1][0], rescomp._indexers['c'][1][1], color='red' )
c_phase_plane.axes_labels( [ '$c_0$', '$c_1$' ] )
c_phase_plane.save( 'maclev-2-2-c-vs-c.png', figsize=(4,4) )

#stop there for now
ltx.close()
save_session( 'maclev-2-2-adap' )
sys.exit()

ltx.write( 'And the equilibrium values $\\hat X$ and $\\hat R$:',
    '\\begin{align*}\n  \\hat X_0 &\\to ',
    latex( maclev_adap_c._bindings( Xhat ) ), ' = ',
    latex( numeric_params( maclev_adap_c._bindings( Xhat ) ) ), '\\\\\n',
    '  \\hat R_0 &\\to ',
    latex( maclev_adap_c._bindings( Rhat ) ), ' = ',
    latex( numeric_params( maclev_adap_c._bindings( Rhat ) ) ), '\n',
    '\\end{align*}\n' )

ltx.close()

save_session('maclev-2-2-adap', verbose=True)
</source-file>

Here we derive the adaptive dynamics equations when it is the uptake rates $$c_{ij}$$ that is evolving -- that is, when $$c_{ij}=c_j(u_i)$$, $$b_0=1$$, and $$m_0=1$$; and then we bind the remaining parameters to get a realization of the system that we can integrate and plot.

<project-file filename=maclev-2-2-adap.sage.out.tex/>

With these parameters, what happens to the evolving traits $$u$$?

<project-file filename=maclev-2-2-u-vs-t.png make=no/> <project-file filename=maclev-2-2-u-vs-u.png make=no/>

And behold the motion of $$c_0(u)$$ and $$c_1(u)$$ as the two populations' trait values $$u_i$$ change:

<project-file filename=maclev-2-2-c-vs-c.png make=no/>

## Adaptive Geometry

<source-file filename=maclev-2-2-geom.sage.step lang=sage>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageUtils)/latex_output.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py maclevmodels.py 
# requires: lotkavolterra.py
# requires: maclev_2_2_defs.py maclev-2-2-adap.sobj
# produces: maclev-2-2-geom.sage.out.tex
# produces: maclev-2-2-k-vs-t.png maclev-2-2-a-vs-t.png
# produces: maclev-2-2-Xhat-vs-t.png maclev-2-2-a-vs-a.png
# produces: maclev-2-2-a-vs-k.png maclev-2-2-a-arrows.png
from maclev_2_2_defs import *
from lotkavolterra import *

load_session( 'maclev-2-2-adap' )

ltx = latex_output( 'maclev-2-2-geom.sage.out.tex' )

lv_adap_c = LotkaVolterraAdaptiveDynamics( maclev_adap_c, lv_coefficient_names=('k','a') )

class SeriesOfBindings( Bindings ):
    def __init__( self, *args ):
	# this list of bindings will be applied from right to left
	self._series = args
    def substitute( self, expr ):
	return self.substitute_list( self._series, expr )
    def substitute_list( self, series, expr ):
	if not series: return expr
	return series[0]( self.substitute_list( series[1:], expr ) )
    def _latex_(self):
	from operator import add
	return reduce( add, map( latex, self._series ) )

A_to_u_bindings = SeriesOfBindings(
	bmc_bindings + numeric_params + lv_adap_c._fn_bindings
		+ lv_adap_c.population_equilibrium_bindings(),
	lv_adap_c._phenotypes_from_fn_bindings,
	lv_adap_c.dudt_bindings(),
	lv_adap_c._phenotypes_to_fn_bindings
		+ lv_adap_c._A_to_fn_bindings )

print 'printing things in LaTeX'
sys.stdout.flush()

ltx.write( 'A\_to\_u\_bindings is ' + latex( A_to_u_bindings ) )

ltx.write_equality( SR('A(0)'), lv_adap_c.A(0), lv_adap_c._fn_bindings( lv_adap_c._A_to_fn_bindings( lv_adap_c.A(0) ) ) )
ltx.write_equality( SR('A(1)'), lv_adap_c.A(1), lv_adap_c._fn_bindings( lv_adap_c._A_to_fn_bindings( lv_adap_c.A(1) ) ) )
ltx.write_equality( SR('S(A(0))'), lv_adap_c.S( lv_adap_c.A(0) ), lv_adap_c._A_to_fn_bindings( lv_adap_c.population_equilibrium_bindings()( lv_adap_c.S( lv_adap_c.A(0) ) ) ) )
ltx.write_equality( SR('S(A(1))'), lv_adap_c.S( lv_adap_c.A(1) ), lv_adap_c._A_to_fn_bindings( lv_adap_c.population_equilibrium_bindings()( lv_adap_c.S( lv_adap_c.A(1) ) ) ) ) 

ltx.write_equality( wrap_latex( 'D(u_0)' ), lv_adap_c.direct_effect(0),
	#A_to_u_bindings( lv_adap_c.direct_effect(0) ),
	initial_conditions( A_to_u_bindings( lv_adap_c.direct_effect(0) ) ) )
ltx.write_equality( wrap_latex( 'I(u_0)' ), lv_adap_c.indirect_effect(0),
	initial_conditions( A_to_u_bindings( lv_adap_c.indirect_effect(0) ) ) )

print 'plot k vs. t'
sys.stdout.flush()

# plot k values vs. time
k_timeseries = Graphics();
for i in (0, 1):
    k_timeseries += c_evolution.plot( t,
	A_to_u_bindings( lv_adap_c._glv_model._indexers['r'][i] ),
	color=[ 'blue', 'red' ][i], figsize=(4,4) )
k_timeseries.axes_labels( [ '$t$', '$k(\cdot)$' ] )
k_timeseries.save( 'maclev-2-2-k-vs-t.png' )

print 'plot a vs. t'
sys.stdout.flush()

# plot interactions vs. time in Xmas colors
a_timeseries = Graphics()
for i in (0, 1):
    for j in (0, 1):
	a_timeseries += c_evolution.plot( t,
	    A_to_u_bindings( lv_adap_c._glv_model._indexers['a'][i][j] ), 
	    color=(i == j and 'red' or 'lime'), figsize=(4,4) )
a_timeseries.axes_labels( [ '$t$', '$a(\cdot,\cdot)$' ] )
a_timeseries.save( 'maclev-2-2-a-vs-t.png' )

print 'plot X vs. t'
sys.stdout.flush()

# population size vs time
X_timeseries = Graphics()
for i in (0, 1):
    X_timeseries += c_evolution.plot( t,
	A_to_u_bindings( lv_adap_c._population_equilibrium_indexer[i] ),
	color=[ 'blue', 'red' ][i], figsize=(4,4) )
X_timeseries.axes_labels( [ '$t$', '$\hat{X}$' ] )
X_timeseries.save( 'maclev-2-2-Xhat-vs-t.png' )

print 'plot R vs. t'
sys.stdout.flush()

# population size vs time
R_timeseries = Graphics()
for i in (0, 1):
    ri = A_to_u_bindings( Bindings( { X_0: 'Xhat_0', X_1: 'Xhat_1' } )( rescomp_u._bindings( SR('R_%s'%i) ) ) )
    print ri
    print Bindings( c_evolution._timeseries[0] )( ri )
    sys.stdout.flush()
    R_timeseries += c_evolution.plot( t, ri,
	color=[ 'blue', 'red' ][i], figsize=(4,4) )
R_timeseries.axes_labels( [ '$t$', '$\hat{R}$' ] )
R_timeseries.save( 'maclev-2-2-Rhat-vs-t.png' )

print 'plot a vs. a'
sys.stdout.flush()

# plot interactions in A space
a_phase_plane = Graphics()
#from sage.plot.plot3d.base import Graphics3d
#a_3d = Graphics3d()
for i in (0, 1):
    a_phase_plane += c_evolution.plot(
	A_to_u_bindings( lv_adap_c._glv_model._indexers['a'][i][0] ),
	A_to_u_bindings( lv_adap_c._glv_model._indexers['a'][i][1] ),
	color=[ 'blue', 'red' ][i] )
    #a_3d += c_evolution.plot3d(
	#A_to_u_bindings( lv_adap_c._glv_model._indexers['a'][i][0] ),
	#A_to_u_bindings( lv_adap_c._glv_model._indexers['a'][i][1] ),
	#A_to_u_bindings( lv_adap_c._glv_model._indexers['r'][i] ),
	#color=[ 'blue', 'red' ][i] )
a_phase_plane.axes_labels( [ '$a(u_0,\cdot)$', '$a(u_1,\cdot)$' ] )
a_phase_plane.save( 'maclev-2-2-a-vs-a.png', figsize=(4,4) )
##a_3d.axes_labels( [ '$a(u_0,u)$', '$a(u_1,u)$', '$k(u)' ] )
#a_3d.save( 'maclev-2-2-a-vs-k.png' )

print 'plot a vs. a with arrows'
sys.stdout.flush()

def a_arrow( base, vec, scale=1, **args ):
    #ltx.write( 'arrow: $%s \\to %s%s$\n\n' % (latex(base),latex(scale),latex(vec)) )
    return arrow( (base[1], base[2]), (base[1] + scale*vec[1], base[2] + scale*vec[2]), **args )

a_phase_plane_annotated = a_phase_plane

last_t = -oo
scale = 1/12
Ai = A_to_u_bindings( lv_adap_c.A(i) )
SAi = A_to_u_bindings( lv_adap_c.S(lv_adap_c.A(i)) )
Di = A_to_u_bindings( lv_adap_c.direct_effect(i) )
Ii = A_to_u_bindings( lv_adap_c.indirect_effect(i) )
dAdti = A_to_u_bindings( lv_adap_c.dAdt(i) )
for p in c_evolution._timeseries:
    next_t = p[t]
    pp = Bindings( p )
    if next_t >= last_t + 0.1:
	last_t = next_t
	for i in (0,1):
	    # check equality
	    #ltx.write( '$D(%s) + I(%s) = %s \\overset{?}{=} \\frac{dA(u)}{du} = %s$\n\n' % (
	    #	latex(i), latex(i), latex(
	    #	  pp( A_to_u_bindings( Di ) ) +
	    #	  pp( A_to_u_bindings( Ii ) )
	    #	), latex(
	    #	  pp( A_to_u_bindings( dAdti ) )
	    #	) ) )
	    S_A_arrow = a_arrow(
		pp( Ai ),
		pp( SAi ),
		scale=scale, color='red' )
	    D_arrow = a_arrow(
		pp( Ai ),
		pp( Di ),
		scale=scale, color='green' )
	    I_arrow = a_arrow(
		pp( Ai + Di.apply_map( lambda x:x*scale ) ),
		pp( Ii ),
		scale=scale, color='purple' )
	    dA_du_arrow = a_arrow(
		pp( Ai ),
		pp( dAdti ),
		scale=scale, color='blue' )
	    a_phase_plane_annotated += S_A_arrow + D_arrow + I_arrow + dA_du_arrow

a_phase_plane_annotated.axes_labels( [ '$a(u_0,\cdot)$', '$a(u_1,\cdot)$' ] )
a_phase_plane_annotated.save( 'maclev-2-2-a-arrows.png', figsize=(10,10)
    #, xmin=-0.6, xmax=-0.3, ymin=-0.6, ymax=-0.3
)

#stop there for now
ltx.close()
save_session('maclev-2-2-geom')
sys.exit()

ltx.close() 
</source-file>

<project-file filename=maclev-2-2-geom.sage.out.html/>

And the motion of the Lotka-Volterra coefficients $$k$$ and $$a$$:

<project-file filename=maclev-2-2-k-vs-t.png make=no/> 
<project-file filename=maclev-2-2-a-vs-t.png make=no/>

<project-file filename=maclev-2-2-Xhat-vs-t.png make=no/>
<project-file filename=maclev-2-2-a-vs-a.png make=no/>

<project-file filename=maclev-2-2-a-arrows.png make=no/>

{% comment %}<project-file filename=maclev-2-2-a-vs-k.png make=no/>{% endcomment %}

