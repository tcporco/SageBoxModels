---
layout: page
title: "Adaptive Geometry and Resource Competition: Two Species, Two Resources"
wmd_project: Selection_Gradients
---

This page investigates the adaptive dynamics of [the Macarthur-Levins resource competition model](/Selection_Gradients/MacLev.html) in the case of two species and two resources.

* See [Selection_Gradients/MacLev](/Selection_Gradients/MacLev.html) for the general model, and the adaptive dynamics formulation we're using here, including the specific questions about the $$a$$ and $$k$$ of the Lotka-Volterra framework.
* See also [Adaptive Geometry and Resource Competition - One Species, One Resource](/Selection_Gradients/MacLev-1-1.html).

We begin by creating and testing a 2-species, 2-resource model.  

<source-file filename=maclev_2_2_defs.py.step lang=python>
# requires: maclevmodels.py $(SageDynamics)/dynamicalsystems.py
from sage.all import *
from sage.misc.latex import _latex_file_

import os
import sys
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageAdaptiveDynamics'] )
from dynamicalsystems import *
from adaptivedynamics import *
from latex_output import *
from maclevmodels import *

# Create the generic 2-species, 2-resources MacLev model, with b, m, and c
# as functions of the 2 species' traits u_0 and u_1.

rescomp_u = ResourceCompetitionModel(
    x_indices = [0, 1], r_indices = [0, 1],
    b = lambda_str_indexer( "lambda i: SR('b(u_%s)'%i)" ),
    m = lambda_str_indexer( "lambda i: SR('m(u_%s)'%i)" ),
    c = lambda_str_indexer( "lambda i: indexer( lambda j: SR('c_%s(u_%s)'%(j,i) ) )" ) )

maclev_u = MacArthurLevinsModel(
    x_indices = [0, 1], r_indices = [0, 1],
    b = lambda_str_indexer( "lambda i: SR('b(u_%s)'%i)" ),
    m = lambda_str_indexer( "lambda i: SR('m(u_%s)'%i)" ),
    c = lambda_str_indexer( "lambda i: indexer( lambda j: SR('c_%s(u_%s)'%(j,i) ) )" ) )

b_m_bindings = FunctionBindings( {
	function('b') : SR('1').function(SR('u')),
	function('m') : SR('1').function(SR('u'))
} )

quadratic_c_bindings = FunctionBindings( {
        function('c_0'): SR( '1/(1+u**2*5)' ).function(SR('u')),
        function('c_1'): SR( '1/(1+(u-1)**2*5)' ).function(SR('u'))
} )

linear_c_bindings = FunctionBindings( {
	function('c_0'): SR( '1 - u' ).function( SR('u') ),
	function('c_1'): SR( 'u' ).function( SR('u') )
} )

c_bindings = linear_c_bindings

# create global variables for convenience
r_0, r_1, K_0, K_1, w_0, w_1 = SR.var( 'r_0, r_1, K_0, K_1, w_0, w_1' )
X_0, X_1, R_0, R_1 = SR.var( 'X_0, X_1, R_0, R_1' )
u_0, u_1 = SR.var( 'u_0, u_1' )
gamma = SR.var( 'gamma' )

#b_0, m_0, b_1, m_1 =  SR.var( 'b_0, m_0, b_1, m_1' )
#c_0_0, c_0_1, c_1_0, c_1_1 = ( SR.var( 'c_%s' % s, latex_name='c_{%s}' % s ) for s in ( '00', '01', '10', '11' ) )

numeric_params = Bindings(
  { r_0: 1, r_1: 1,
    w_0: 1, w_1: 1,
    K_0: 2, K_1: 2,
    gamma: 1 } )

initial_conditions = Bindings( {
	# in a .sage file, could just write u_0: 1/3
	# in a .py, fractions need special care
	u_0 : Rational('1/3'),
	#u_1 : Rational('1/2')
	u_1 : Rational('2/3')
} )
</source-file>

<source-file filename=maclev-2-2-popdyn.sage.step lang=sage>
# requires: maclev_2_2_defs.py
# produces: maclev-2-2-popdyn.sage.out.tex maclev-2-2-popdyn.png
from maclev_2_2_defs import *

ltx = latex_output( 'maclev-2-2-popdyn.sage.out.tex' )

ltx.write( 'The Mac-Lev model with generic character $u$: ' )
ltx.write_block( maclev_u )

ltx.write( 'The Mac-Lev model with $b_i=m_i=%s$ and $c_{ij} = %s$:' % ( latex( b_m_bindings( SR('b(u_i)') ) ), latex( c_bindings( SR('c_i(u_j)') ) ) ) )
ltx.write_block( maclev_u.bind( c_bindings + b_m_bindings ) )

maclev_initial_system = maclev_u.bind( c_bindings + b_m_bindings + numeric_params + initial_conditions )
p = maclev_initial_system.plot_vector_field( (X_0, 0, 2), (X_1, 0, 2), color="gray", figsize=(5,5) )
p += maclev_initial_system.plot_ZNGIs( (X_0, 0, 2), (X_1, 0, 2), color="gray" )
s = maclev_initial_system.solve( [0, 0.02, 0.05] )
p += s.plot( X_0, X_1, color='red' )
p.save( 'maclev-2-2-popdyn.png' )

# analysis

maclev_abstract = maclev_u.bind( b_m_bindings ).bind( numeric_params )
int_eq = maclev_abstract.interior_equilibria()
int_eq = int_eq[0]

#ltx.write( "\n\nThe model's interior equilibrium:\n" )
#ltx.write_block( column_vector( [ int_eq[X_0], int_eq[X_1] ] ) )

#for v in ( r_0, r_1, K_0, K_1, w_0, w_0, X_0, X_1 ):
#	assume( v > 0 )

#ltx.write( "The criterion for a coexistence solution is for the interior equilibrium to be positive:\n" )
#ltx.write_block( column_vector( [ simplify( factor( int_eq[X_0] ) > 0 ), simplify( factor( int_eq[X_1] ) > 0 ) ] ) )

#ltx.write( "Jacobian at the interior equilibrium is" )
#ltx.write_block( maclev_abstract.jacobian_matrix( int_eq ) )

#ltx.write( "Eigenvalues at the interior equilibrium are" )
#ltx.write_block( maclev_abstract.jacobian_matrix( int_eq ).eigenvalues() )

#ltx.write( "Stability criteria for the interior equilibrium are:\n" )
#ltx.write_block( column_vector( [ simplify( real( ev ) > 0 ) for ev in maclev_abstract.jacobian_matrix( int_eq ).eigenvalues() ] ) )

ltx.write( "The coexistence criteria depend on the invasion rates at the boundary equilibria.\n\n" )

for x_inv, x_res in ( (X_0, X_1), (X_1, X_0) ):
	assume( x_res > 0 )
	assume( x_inv == 0 )
	boundary_solutions = solve( maclev_abstract._flow[x_res] == 0, x_res, solution_dict=True )
	forget()
	if ( len( boundary_solutions ) != 1 ):
		raise Exception( 'wrong number of boundary solutions' )
	boundary_solution = boundary_solutions[0]
	#ltx.write_block( x_res.subs( boundary_solution ) )
	ltx.write( "Invasion of $%s$:\n" % latex( x_inv ) )
	inv_rate_abstract = maclev_abstract._flow[x_inv] / x_inv
	#ltx.write_block( inv_rate_abstract > 0 )
	inv_rate = inv_rate_abstract.subs( boundary_solution ).subs( { x_inv: 0 } )
	ltx.write_block( inv_rate.full_simplify() > 0 )

rescomp_abstract = rescomp_u.bind( b_m_bindings ).bind( numeric_params )

ltx.write( "But those invasion criteria are really about the resources.\n" ) # The resource levels are:\n" )
ltx.write( latex( rescomp_abstract ) )

for x_inv, x_res in ( (X_0, X_1), (X_1, X_0) ):
	#assume( x_res > 0 )
	#assume( x_inv == 0 )
	assume( R_0 > 0, R_1 > 0 )
	boundary_solutions = solve( [ rescomp_abstract._flow[v] == 0 for v in (x_res, R_0, R_1) ] + [ x_inv == 0 ], [ x_res, x_inv, R_0, R_1 ], solution_dict=True )
	forget()
	#ltx.write( "boundary solutions: $%s$\n" % latex(boundary_solutions) )
	boundary_solutions = [ s for s in boundary_solutions if s[x_res] != 0 ]
	if ( len( boundary_solutions ) != 1 ):
		raise Exception( 'wrong number of boundary solutions' )
	boundary_solution = boundary_solutions[0]
	ltx.write( "Here's a boundary solution: %s\n\n" % latex( Bindings( boundary_solution ) ) )
	#ltx.write_block( x_res.subs( boundary_solution ) )
	ltx.write( "Invasion condition for $%s$:\n" % latex( x_inv ) )
	inv_rate_abstract = rescomp_abstract._flow[x_inv] / x_inv
	#ltx.write_block( inv_rate_abstract > 0 )
	inv_rate = inv_rate_abstract.subs( { x_inv: 0 } )
	ltx.write_block( inv_rate.full_simplify() > 0 )

ltx.write( "In our initial model, $c$ values are" )
for i in ( 0, 1 ):
    for j in ( 0, 1 ):
	cij = rescomp_abstract._indexers['c'][i][j]
	ltx.write_block( cij == (initial_conditions + c_bindings + b_m_bindings)( cij ) )

ltx.close()

#save_session('maclev-2-2-popdyn')
</source-file>

The model equations, according to Sage:

<project-file filename=maclev-2-2-popdyn.sage.out.tex/>

State space of this population dynamics model:

<project-file filename="maclev-2-2-popdyn.png"/>

## Adaptive dynamics of $$u$$

<source-file filename=maclev-2-2-adap.sage.step lang=sage>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageAdaptiveDynamics)/adaptivedynamics.py maclevmodels.py maclev_2_2_defs.py
# produces: maclev-2-2-adap.sage.out.tex maclev-2-2-adap.sobj
# produces: maclev-2-2-u-vs-t.png maclev-2-2-u-vs-u.png maclev-2-2-c-vs-c.png
from maclev_2_2_defs import *

ltx = latex_output( 'maclev-2-2-adap.sage.out.tex' )

ltx.write( 'maclev\_u anyone? ' )
ltx.write_block( maclev_u )

ltx.write( 'and with the functional and numeric bindings: ' )
ltx.write_block( maclev_u.bind( c_bindings + b_m_bindings + numeric_params ) )

print "starting adaptive dynamics"
sys.stdout.flush()

try:
    maclev_adap_c = NumericalAdaptiveDynamicsModel( maclev_u, 
        [ indexer('u') ], bindings=c_bindings + b_m_bindings + numeric_params )
    #ltx.write( maclev_adap_c._debug_output._output._str )
    #ltx.write( 'adaptive dynamics of $u_\cdot$ in that model:' )
    #ltx.write_block( maclev_adap_c )
except AdaptiveDynamicsException, e:
    print( r'%s\\Exception: %s' % (e._latex_str, e) )
    sys.stdout.flush()
    ltx.write( e._latex_str, r'\\Exception: %s\\' % e )

print "did adaptive dynamics"
sys.stdout.flush()

#ltx.write( '\\texttt{initial\\_conditions} = %s' % latex( initial_conditions ) )
#ltx.write( 'initial conditions: $%s$\n\n' % latex( [ 0, initial_conditions( 'u_0' ), initial_conditions( 'u_1' ) ] ) )

c_evolution = maclev_adap_c.solve( [0, initial_conditions( 'u_0' ), initial_conditions( 'u_1' ) ], end_points=2, step=0.02 )

# and plot u vs t 
t = maclev_adap_c.time_variable()
u_timeseries = c_evolution.plot( t, SR('u_0'), ylabel='$u$', figsize=(4,4) )
u_timeseries += c_evolution.plot( t, SR('u_1'), color='red' )
u_timeseries.save( 'maclev-2-2-u-vs-t.png' )

# plot phase plane of u vs u
u_phase_plane = c_evolution.plot( SR('u_0'), SR('u_1'), figsize=(4,4) )
u_phase_plane += maclev_adap_c.plot_vector_field( ('u_0',0,1), ('u_1',0,1), color='gray', plot_points=19 )
u_phase_plane.axes_labels( [ '$u_0$', '$u_1$' ] )
u_phase_plane.save( 'maclev-2-2-u-vs-u.png', xmin=0, xmax=1, ymin=0, ymax=1 )

# plot c_0 vs c_1
c_phase_plane = c_evolution.plot( SR('c_0(u_0)'), SR('c_1(u_0)'), figsize=(4,4) )
c_phase_plane += c_evolution.plot( SR('c_0(u_1)'), SR('c_1(u_1)'), color='red' )
c_phase_plane.axes_labels( [ '$c_0$', '$c_1$' ] )
c_phase_plane.save( 'maclev-2-2-c-vs-c.png' )

#stop there for now
ltx.close()
save_session('maclev-2-2-adap')
sys.exit()

# and let's also plot k_0 vs. a_00.
# these are the coefficients if you rewrite the maclev dynamics
# as dX_0/dt = X_0(k_0 + a_00 X_0)
# and why not get sage to do that, rather than type in the definitions
rhsc = maclev_c._flow[X_0].collect(X_0)
k_0 = rhsc.coeff(X_0,1)
a_00 = rhsc.coeff(X_0,2)
ltx.write( 'With and without these bindings, the Lotka-Volterra coefficients $k_0$ and $a_{00}$ are:' )
ltx.write_equality( SR.var('k_0'), k_0, numeric_params(k_0) )
ltx.write_equality( SR.var('a_00', latex_name='a_{00}' ), a_00, numeric_params(a_00) )

ltx.write( 'And the equilibrium values $\\hat X$ and $\\hat R$:',
    '\\begin{align*}\n  \\hat X_0 &\\to ',
    latex( maclev_adap_c._bindings( Xhat ) ), ' = ',
    latex( numeric_params( maclev_adap_c._bindings( Xhat ) ) ), '\\\\\n',
    '  \\hat R_0 &\\to ',
    latex( maclev_adap_c._bindings( Rhat ) ), ' = ',
    latex( numeric_params( maclev_adap_c._bindings( Rhat ) ) ), '\n',
    '\\end{align*}\n' )

c_evolution.plot( a_00, k_0, "ak.png",
  xlabel = SR.var('a_00'), ylabel = SR.var('k_0'), figsize=(4,4) )

ltx.close()

save_session('maclev-2-2-adap', verbose=True)
</source-file>

Here we derive the adaptive dynamics equations when it is the uptake rates $$c_{ij}$$ that is evolving -- that is, when $$c_{ij}=c_j(u_i)$$, $$b_0=1$$, and $$m_0=1$$; and then we bind the remaining parameters to get a realization of the system that we can integrate and plot.

<project-file filename=maclev-2-2-adap.sage.out.tex/>

With these parameters, what happens to the evolving traits $$u$$?

<project-file filename=maclev-2-2-u-vs-t.png make=no/> <project-file filename=maclev-2-2-u-vs-u.png make=no/>

And behold the motion of $$c_0(u)$$ and $$c_1(u)$$ as the two populations' trait values $$u_i$$ change:

<project-file filename=maclev-2-2-c-vs-c.png make=no/>

## Adaptive Geometry

<source-file filename=maclev-2-2-geom.sage.step lang=sage>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageUtils)/latex_output.py
# requires: $(SageAdaptiveDynamics)/adaptivedynamics.py maclevmodels.py 
# requires: maclev_2_2_defs.py maclev-2-2-adap.sobj
# produces: maclev-2-2-geom.sage.out.tex
# produces: maclev-2-2-k-vs-t.png maclev-2-2-a-vs-a.png
# produces: maclev-2-2-a-vs-k.png maclev-2-2-a-arrows.png
from maclev_2_2_defs import *

load_session( 'maclev-2-2-adap' )

ltx = latex_output( 'maclev-2-2-geom.sage.out.tex' )

## plot evolution of A and K

from sage.symbolic.function_factory import function
af = function('a')
kf = function('k')

maclev_lv = LotkaVolterraModel( maclev_u )

A_bindings = FunctionBindings( {
    af : maclev_lv._bindings( maclev_lv._indexers['a']['i']['j'] ).function( SR('u_i'), SR('u_j' ) ),
    kf : maclev_lv._bindings( maclev_lv._indexers['r']['i'] ).function( SR('u_i') )
} )

ltx.write( "The L-V coefficients are" )
ltx.write_equality( kf(SR('u_i')), A_bindings( kf(SR('u_i')) ) )
ltx.write_equality( af(SR('u_i'),SR('u_j')), A_bindings( af(SR('u_i'),SR('u_j')) ) )
#maclev_lv._bindings( maclev_lv._indexers['a']['i']['j'] ).maxima_methods().collectterms( [ SR('u_i'), SR('u_j') ] ) )

#ltx.write( "MacLev 2-2 model as Lotka-Volterra model:\n" )
#ltx.write_block( maclev_lv )

# plot k values vs. time
k_timeseries = Graphics();
for i in (0, 1):
    k_timeseries += c_evolution.plot( t,
	( c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['r'][i] ),
	color=[ 'blue', 'red' ][i], figsize=(4,4) )
k_timeseries.axes_labels( [ '$t$', '$k(u)$' ] )
k_timeseries.save( 'maclev-2-2-k-vs-t.png' )

#print ( '$a_{00}$: ' + latex( (c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings)( maclev_lv._indexers['a'][0][0] ) ) + '\n' )

# plot interactions vs. time in Xmas colors
a_timeseries = Graphics()
for i in (0, 1):
    for j in (0, 1):
	a_timeseries += c_evolution.plot( t,
	( c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][j] ), 
	color=(i == j and 'red' or 'lime'), figsize=(4,4) )
a_timeseries.axes_labels( [ '$t$', '$a(\cdot,\cdot)$' ] )
a_timeseries.save( 'maclev-2-2-a-vs-t.png' )

# plot interactions in A space
a_phase_plane = Graphics()
from sage.plot.plot3d.base import Graphics3d
a_3d = Graphics3d()
for i in (0, 1):
    a_phase_plane += c_evolution.plot(
	( c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][0] ),
	( c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][1] ),
	color=[ 'blue', 'red' ][i] )
    a_3d += c_evolution.plot3d(
	( c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][0] ),
	( c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][1] ),
	( c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['r'][i] ),
	color=[ 'blue', 'red' ][i] )
a_phase_plane.axes_labels( [ '$a(u_0,u)$', '$a(u_1,u)$' ] )
a_phase_plane.save( 'maclev-2-2-a-vs-a.png', figsize=(4,4) )
#a_3d.axes_labels( [ '$a(u_0,u)$', '$a(u_1,u)$', '$k(u)' ] )
a_3d.save( 'maclev-2-2-a-vs-k.png' )

# use unadorned GLV model to construct S(A)
glv_model = GeneralizedLotkaVolterraModel( maclev_lv._population_indices,
  r = indexer( 'k' ) )

#ltx.write( 'GLV model: ' + latex( glv_model ) )

try:
	glv_adap = AdaptiveDynamicsModel( glv_model,
	  [ indexer( 'k' ) ] + [ indexer( Lambda( 'i', '"a_"+str(i)+"_' + str(j) + '"' ) ) for j in glv_model._population_indices ],
	  equilibrium_function = Lambda( 'ad,pd', 'pd.interior_equilibria()[0]' ) )
except AdaptiveDynamicsException, e:
	ltx.write( 'AdaptiveDynamicsException: ' + e._latex_str )

#ltx.write( 'GLV adaptive dynamics: ' + latex(glv_adap) )

def A(i):
    return column_vector( 
	[ SR('k_%s'%i) ] +
	[ SR('a_%s_%s'%(i,j)) for j in glv_model._population_indices ] )

def S(A):
    return column_vector( [ glv_adap._S[a] for a in A ] )

# how we doing?

# so far so good!

# now convert those to functions of u

A_u_bindings = (
	Bindings( dict( (SR('k_%s'%i), SR('k(u_%s)'%i)) for i in glv_model._population_indices ) ) +
	Bindings( dict( (SR('a_%s_%s'%(i,j)), SR('a(u_%s,u_%s)'%(i,j))) for i in glv_model._population_indices for j in glv_model._population_indices ) ) )

#ltx.write_equality( wrap_latex( '\\texttt{A\_u\_bindings}' ), A_u_bindings )

A_to_u_bindings = c_bindings + b_m_bindings + numeric_params + maclev_lv._bindings + A_u_bindings + A_bindings

ltx.write_equality( SR('A(0)'), A(0), initial_conditions( A_to_u_bindings(A(0)) ) )
ltx.write_equality( SR('A(1)'), A(1), initial_conditions( A_to_u_bindings(A(1)) ) )
ltx.write_equality( SR('S(A(0))'), S(A(0)), initial_conditions( A_to_u_bindings(S(A(0))) ) )
ltx.write_equality( SR('S(A(1))'), S(A(1)), initial_conditions( A_to_u_bindings(S(A(1))) ) )

X_bindings = maclev_adap_c.solve_for_x_bindings( initial_conditions )

def d1A(i):
    '''"Direct effect": derivative of A(u_i) wrt u_i with u_i in the "patient"
    position, as the first argument of a(.,.).'''
    A_ij = A_u_bindings( A(i) )
    A_ij_hacked = A_ij.apply_map( lambda x: x.subs_expr( SR('a(u_%s,u_%s)'%(i,i)) == SR('a(u_%s,u_x)'%i) ) )
    return A_ij_hacked.derivative( SR('u_%s'%i) ).subs( SR('u_x') == SR('u_%s'%i) )
def direct_effect(i):
    return d1A(i).apply_map( lambda x: x*dudt(i) )

def dudt(i):
    return (X_bindings + A_to_u_bindings)( SR('gamma*X_%s'%i) * d1A(i).transpose().dot_product( S(A(i)).transpose() ) )
    return ( SR('gamma*X_%s'%i) * d1A(i).transpose().dot_product( S(A(i)).transpose() ) )
    return diff( SR('u_%s(t)'%i), SR('t') )

def d2A_component(i,j):
    '''Component of "Indirect effects" on "patient" u_i, due to "agent" u_j.  
    When j is i, this includes only the "agent" role of u_i, which is where
    it appears as the second argument of a().'''
    A_ij = A_u_bindings( A(i) )
    if j == i:
	agent_i = SR('u_x')
        A_ij_hacked = A_ij.apply_map( lambda x: x.subs_expr( SR('a(u_%s,u_%s)'%(i,i)) == SR('a(u_%s,u_x)'%i) ) )
	d2A_hacked = A_ij_hacked.derivative( agent_i )
	d2A = d2A_hacked.subs( SR('u_x') == SR('u_%s'%i) )
	#ltx.write( 'on diagonal: $\partial_2 A = %s$\n\n' % latex( d2A ) )
    else:
	d2A = A_ij.derivative( SR('u_%s'%j) )
	#ltx.write( 'off diagonal: $\partial_2 A = %s$\n\n' % latex( d2A ) )
    #ltx.write( 'multiply by dudt(%s)$ = %s$\n\n' % (j, latex( dudt(j) )) )
    return d2A.apply_map( lambda x:x * dudt(j) )
def indirect_effect(i):
    '''Complete "indirect effect": sum of indirect effects of all agents'''
    components = [d2A_component(i,j) for j in glv_model._population_indices]
    #for c in components: ltx.write( 'component: $', latex( c ), '$\n\n' )
    import operator
    return reduce( operator.add, components )

#ltx.write_equality( wrap_latex( 'D(u_0)' ), #direct_effect(0),
#    initial_conditions( A_to_u_bindings( direct_effect(0) ) ) )
#ltx.write_equality( wrap_latex( 'I(u_0)' ), #indirect_effect(0),
#    initial_conditions( A_to_u_bindings( indirect_effect(0) ) ) )

ltx.write_equality( wrap_latex( 'D(u_0)' ), direct_effect(0) )
ltx.write_equality( wrap_latex( 'I(u_0)' ), indirect_effect(0) )

# direct and indirect effects should add up to the actual tangent vector
# dA/dt
def dAdt(i):
    Au = A_u_bindings( A(i) )
    return reduce( lambda x,y: x+y, (diff( Au, SR('u_%s'%j) ) * dudt(j) for j in glv_model._population_indices) )
    return A_u_bindings( A(i) ).subs(
	dict( (SR('u_%i'%i), SR('u_%s(t)'%i)) for i in glv_model._population_indices )
    ).derivative( t ).subs(
	dict( (SR('u_%s(t)'%i), SR('u_%s'%i)) for i in glv_model._population_indices )
    )

def a_arrow( base, vec, scale=1, **args ):
    #ltx.write( 'arrow: $%s \\to %s%s$\n\n' % (latex(base),latex(scale),latex(vec)) )
    return arrow( (base[1], base[2]), (base[1] + scale*vec[1], base[2] + scale*vec[2]), **args )

a_phase_plane_annotated = a_phase_plane

last_t = -oo
scale = 1/12
for p in c_evolution._timeseries:
    next_t = p[t]
    pp = Bindings( p )
    if next_t >= last_t + 0.2:
	last_t = next_t
	# What a hack!
	X_bindings = maclev_adap_c.solve_for_x_bindings( pp )
	for i in (0,1):
	    # check equality
	    Ai = A(i)
	    SAi = S(A(i))
	    Di = direct_effect(i)
	    Ii = indirect_effect(i)
	    dAdti = dAdt(i)
	    #ltx.write( '$D(%s) + I(%s) = %s \\overset{?}{=} \\frac{dA(u)}{du} = %s$\n\n' % (
	#	latex(i), latex(i), latex(
	#	  pp( A_to_u_bindings( Di ) ) +
	#	  pp( A_to_u_bindings( Ii ) )
	#	), latex(
	#	  pp( A_to_u_bindings( dAdti ) )
	#	) ) )
	    #ltx.write( ' \\\\\n'.join( str(s.parent()) for s in (Ai, SAi, Di, Ii, dAdti) ), '\n\n' )
	    #continue
	    S_A_arrow = a_arrow(
		pp( A_to_u_bindings( Ai ) ),
		pp( A_to_u_bindings( SAi ) ),
		scale=scale, color='red' )
	    D_arrow = a_arrow(
		pp( A_to_u_bindings( Ai ) ),
		pp( A_to_u_bindings( Di ) ),
		scale=scale, color='green' )
	    I_arrow = a_arrow(
		pp( A_to_u_bindings( Ai + Di.apply_map( lambda x:x*scale ) ) ),
		pp( A_to_u_bindings( Ii ) ),
		scale=scale, color='purple' )
	    dA_du_arrow = a_arrow(
		pp( A_to_u_bindings( Ai ) ),
		pp( A_to_u_bindings( dAdti ) ),
		scale=scale, color='blue' )
	    a_phase_plane_annotated += S_A_arrow + D_arrow + I_arrow + dA_du_arrow

a_phase_plane_annotated.save( 'maclev-2-2-a-arrows.png', figsize=(10,10)
    #, xmin=-0.6, xmax=-0.3, ymin=-0.6, ymax=-0.3
)

ltx.close() 
</source-file>

<project-file filename=maclev-2-2-geom.sage.out.html/>

And the motion of the Lotka-Volterra coefficients $$k$$ and $$a$$:

<project-file filename=maclev-2-2-k-vs-t.png make=no/> 
<project-file filename=maclev-2-2-a-vs-t.png make=no/>

<project-file filename=maclev-2-2-a-vs-a.png make=no/>
<project-file filename=maclev-2-2-a-arrows.png make=no/>

<project-file filename=maclev-2-2-a-vs-k.png make=no/>

