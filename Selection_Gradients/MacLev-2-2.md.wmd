---
layout: page
title: "Adaptive Geometry and Resource Competition: Two Species, Two Resources"
wmd_project: Selection_Gradients
---

This page investigates the adaptive dynamics of [the Macarthur-Levins resource competition model](/Selection_Gradients/MacLev.html) in the case of two species and two resources.

* See [Selection_Gradients/MacLev](/Selection_Gradients/MacLev.html) for the general model, and the adaptive dynamics formulation we're using here, including the specific questions about the $$a$$ and $$k$$ of the Lotka-Volterra framework.
* See also [Adaptive Geometry and Resource Competition - One Species, One Resource](/Selection_Gradients/MacLev-1-1.html).

We begin by creating and testing a 2-species, 2-resource model.  

<source-file filename=maclev-2-2-defs.sage.step lang=sage>
# requires: maclevmodels.py $(SageDynamics)/dynamicalsystems.py
# produces: maclev-2-2-defs.sobj maclev-2-2-defs.sage.out.tex maclev-2-2-defs.png
from sage.all import *
from sage.misc.latex import _latex_file_

import os
import sys
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
from maclevmodels import *
from latex_output import *

ltx = latex_output( 'maclev-2-2-defs.sage.out.tex' )

# Create the generic 2-species, 2-resources MacLev model, with b, m, and c
# as functions of the 2 species' traits u_0 and u_1.

rescomp_u = ResourceCompetitionModel(
    x_indices = [0, 1], r_indices = [0, 1],
    b = lambda_str_indexer( "lambda i: SR('b(u_%s)'%i)" ),
    m = lambda_str_indexer( "lambda i: SR('m(u_%s)'%i)" ),
    c = lambda_str_indexer( "lambda i: indexer( lambda j: SR('c_%s(u_%s)'%(j,i) ) )" ) )

maclev_u = MacArthurLevinsModel(
    x_indices = [0, 1], r_indices = [0, 1],
    b = lambda_str_indexer( "lambda i: SR('b(u_%s)'%i)" ),
    m = lambda_str_indexer( "lambda i: SR('m(u_%s)'%i)" ),
    c = lambda_str_indexer( "lambda i: indexer( lambda j: SR('c_%s(u_%s)'%(j,i) ) )" ) )

b_m_bindings = FunctionBindings( {
	function('b') : SR('1').function(SR('u')),
	function('m') : SR('1').function(SR('u'))
} )

c_bindings = FunctionBindings( {
        function('c_0'): SR( '1/(1+u**2*5)' ).function(SR('u')),
        function('c_1'): SR( '1/(1+(u-1)**2*5)' ).function(SR('u'))
} )

numeric_params = Bindings(
  { SR.var('r_0'): 1, SR.var('r_1'): 1,
    SR.var('w_0'): 1, SR.var('w_1'): 1,
    SR.var('K_0'): 2, SR.var('K_1'): 2,
    SR.var('gamma'): 1 } )

X_0 = maclev_u._population_indexer[maclev_u._population_indices[0]]
X_1 = maclev_u._population_indexer[maclev_u._population_indices[1]]

ltx.write( 'The Mac-Lev model with generic character $u$: ' )
ltx.write_block( maclev_u )

ltx.write( 'The Mac-Lev model with $b_i=m_i=%s$ and $c_{ij} = %s$:' % ( latex( b_m_bindings( SR('b(u_i)') ) ), latex( c_bindings( SR('c_i(u_j)') ) ) ) )
ltx.write_block( maclev_u.bind( c_bindings ) )

# create global variables for convenience
r_0, r_1, K_0, K_1, w_0, w_1 = SR.var( 'r_0, r_1, K_0, K_1, w_0, w_1' )
#b_0, m_0, b_1, m_1 =  SR.var( 'b_0, m_0, b_1, m_1' )
#c_0_0, c_0_1, c_1_0, c_1_1 = ( SR.var( 'c_%s' % s, latex_name='c_{%s}' % s ) for s in ( '00', '01', '10', '11' ) )
X_0, X_1, R_0, R_1 = SR.var( 'X_0, X_1, R_0, R_1' )
u_0, u_1 = SR.var( 'u_0, u_1' )

initial_conditions = Bindings( {
	u_0 : 1/3,
	u_1 : 1/2
} )

maclev_initial_system = maclev_u.bind( c_bindings ).bind( b_m_bindings ).bind( numeric_params ).bind( initial_conditions )
p = maclev_initial_system.plot_vector_field( (X_0, 0, 2), (X_1, 0, 2), color="gray", figsize=(5,5) )
p += maclev_initial_system.plot_ZNGIs( (X_0, 0, 2), (X_1, 0, 2), color="gray" )
s = maclev_initial_system.solve( [0, 0.05, 0.02] )
p += s.plot( X_0, X_1, color='red' )
p.save( 'maclev-2-2-defs.png' )

# analysis

maclev_abstract = maclev_u.bind( b_m_bindings ).bind( numeric_params )
int_eq = maclev_abstract.interior_equilibria()
int_eq = int_eq[0]

#ltx.write( "\n\nThe model's interior equilibrium:\n" )
#ltx.write_block( column_vector( [ int_eq[X_0], int_eq[X_1] ] ) )

#for v in ( r_0, r_1, K_0, K_1, w_0, w_0, X_0, X_1 ):
#	assume( v > 0 )

#ltx.write( "The criterion for a coexistence solution is for the interior equilibrium to be positive:\n" )
#ltx.write_block( column_vector( [ simplify( factor( int_eq[X_0] ) > 0 ), simplify( factor( int_eq[X_1] ) > 0 ) ] ) )

#ltx.write( "Jacobian at the interior equilibrium is" )
#ltx.write_block( maclev_abstract.jacobian_matrix( int_eq ) )

#ltx.write( "Eigenvalues at the interior equilibrium are" )
#ltx.write_block( maclev_abstract.jacobian_matrix( int_eq ).eigenvalues() )

#ltx.write( "Stability criteria for the interior equilibrium are:\n" )
#ltx.write_block( column_vector( [ simplify( real( ev ) > 0 ) for ev in maclev_abstract.jacobian_matrix( int_eq ).eigenvalues() ] ) )

ltx.write( "The coexistence criteria depend on the invasion rates at the boundary equilibria.\n\n" )

for x_inv, x_res in ( (X_0, X_1), (X_1, X_0) ):
	assume( x_res > 0 )
	assume( x_inv == 0 )
	boundary_solutions = solve( maclev_abstract._flow[x_res] == 0, x_res, solution_dict=True )
	forget()
	if ( len( boundary_solutions ) != 1 ):
		raise Exception( 'wrong number of boundary solutions' )
	boundary_solution = boundary_solutions[0]
	#ltx.write_block( x_res.subs( boundary_solution ) )
	ltx.write( "Invasion of $%s$:\n" % latex( x_inv ) )
	inv_rate_abstract = maclev_abstract._flow[x_inv] / x_inv
	#ltx.write_block( inv_rate_abstract > 0 )
	inv_rate = inv_rate_abstract.subs( boundary_solution ).subs( { x_inv: 0 } )
	ltx.write_block( inv_rate.full_simplify() > 0 )

rescomp_abstract = rescomp_u.bind( b_m_bindings ).bind( numeric_params )

ltx.write( "But those invasion criteria are really about the resources.\n" ) # The resource levels are:\n" )
ltx.write( latex( rescomp_abstract ) )

for x_inv, x_res in ( (X_0, X_1), (X_1, X_0) ):
	#assume( x_res > 0 )
	#assume( x_inv == 0 )
	assume( R_0 > 0, R_1 > 0 )
	boundary_solutions = solve( [ rescomp_abstract._flow[v] == 0 for v in (x_res, R_0, R_1) ] + [ x_inv == 0 ], [ x_res, x_inv, R_0, R_1 ], solution_dict=True )
	forget()
	#ltx.write( "boundary solutions: $%s$\n" % latex(boundary_solutions) )
	boundary_solutions = [ s for s in boundary_solutions if s[x_res] != 0 ]
	if ( len( boundary_solutions ) != 1 ):
		raise Exception( 'wrong number of boundary solutions' )
	boundary_solution = boundary_solutions[0]
	ltx.write( "Here's a boundary solution: %s\n\n" % latex( Bindings( boundary_solution ) ) )
	#ltx.write_block( x_res.subs( boundary_solution ) )
	ltx.write( "Invasion condition for $%s$:\n" % latex( x_inv ) )
	inv_rate_abstract = rescomp_abstract._flow[x_inv] / x_inv
	#ltx.write_block( inv_rate_abstract > 0 )
	inv_rate = inv_rate_abstract.subs( { x_inv: 0 } )
	ltx.write_block( inv_rate.full_simplify() > 0 )

ltx.write( "In our initial model, $c$ values are" )
for i in ( 0, 1 ):
    for j in ( 0, 1 ):
	cij = rescomp_abstract._indexers['c'][i][j]
	ltx.write_block( cij == initial_conditions( c_bindings( cij ) ) )

ltx.close()

save_session('maclev-2-2-defs')
</source-file>

The model equations, according to Sage:

<project-file filename=maclev-2-2-defs.sage.out.tex/>

State space of this population dynamics model:

<project-file filename="maclev-2-2-defs.png"/>

## Adaptive dynamics of $$u$$

<source-file filename=maclev-2-2-adap.sage.step lang=sage>
# requires: $(SageDynamics)/dynamicalsystems.py $(SageAdaptiveDynamics)/adaptivedynamics.py maclevmodels.py #maclev-2-2-defs.sobj
# produces: maclev-2-2-adap.sage.out.tex maclev-2-2-adap.sobj
# produces: maclev-2-2-u-vs-t.png maclev-2-2-u-vs-u.png maclev-2-2-c-vs-c.png
# produces: maclev-2-2-k-vs-t.png maclev-2-2-a-vs-a.png maclev-2-2-a-vs-k.png
from sage.all import *
from sage.misc.latex import _latex_file_
from sage.misc.latex import latex
latex.add_to_preamble('\\usepackage{amsmath}')

import os, sys
sys.path.append( os.environ['SageUtils'] )
sys.path.append( os.environ['SageDynamics'] )
sys.path.append( os.environ['SageAdaptiveDynamics'] )
from maclevmodels import *
from adaptivedynamics import *
from latex_output import *
from maclev2_defs import *

#load_session('maclev-2-2-defs')

ltx = latex_output( 'maclev-2-2-adap.sage.out.tex' )

# not pickling right?

maclev_u = MacArthurLevinsModel(
    x_indices = [0, 1], r_indices = [0, 1],
    b = lambda_str_indexer( "lambda i: SR('b(u_%s)'%i)" ),
    m = lambda_str_indexer( "lambda i: SR('m(u_%s)'%i)" ),
    c = lambda_str_indexer( "lambda i: indexer( lambda j: SR('c_%s(u_%s)'%(j,i) ) )" ) )

c_bindings = FunctionBindings( {
	function('b') : SR('1').function(SR('u')),
	function('m') : SR('1').function(SR('u')),
        function('c_0'): SR( '1/(1+u**2*5)' ).function(SR('u')),
        function('c_1'): SR( '1/(1+(u-1)**2*5)' ).function(SR('u'))
} )

numeric_params = Bindings(
  { SR.var('r_0'): 1, SR.var('r_1'): 1,
    SR.var('w_0'): 1, SR.var('w_1'): 1,
    SR.var('K_0'): 2, SR.var('K_1'): 2,
    SR.var('gamma'): 1 } )

initial_conditions = Bindings( {
	SR('u_0') : 1/3,
	SR('u_1') : 1/2
} )

X_0 = maclev_u._population_indexer[maclev_u._population_indices[0]]
X_1 = maclev_u._population_indexer[maclev_u._population_indices[1]]

ltx.write( 'maclev\_u anyone? ' )
ltx.write_block( maclev_u )

ltx.write( 'and with the c\_bindings: ' )
ltx.write_block( maclev_u.bind( c_bindings ) )

ltx.write( 'c\_bindings is ' + latex( c_bindings ) )

print "starting adaptive dynamics"
sys.stdout.flush()

try:
    maclev_adap_c = NumericalAdaptiveDynamicsModel( maclev_u, 
        [ indexer('u') ], bindings=c_bindings.merge( numeric_params ) )
    #ltx.write( maclev_adap_c._debug_output._output._str )
    #ltx.write( 'adaptive dynamics of $u_\cdot$ in that model:' )
    #ltx.write_block( maclev_adap_c )
except AdaptiveDynamicsException, e:
    print( r'%s\\Exception: %s' % (e._latex_str, e) )
    sys.stdout.flush()
    ltx.write( e._latex_str, r'\\Exception: %s\\' % e )

print "did adaptive dynamics"
sys.stdout.flush()

c_evolution = maclev_adap_c.solve( [0, initial_conditions( 'u_0' ), initial_conditions( 'u_1' ) ], end_points=3, step=0.02 )

# and plot u vs t 
t = maclev_adap_c.time_variable()
u_timeseries = c_evolution.plot( t, SR('u_0'), ylabel='$u$', figsize=(4,4) )
u_timeseries += c_evolution.plot( t, SR('u_1'), color='red' )
u_timeseries.save( 'maclev-2-2-u-vs-t.png' )

# plot phase plane of u vs u
u_phase_plane = c_evolution.plot( SR('u_0'), SR('u_1'), figsize=(4,4) )
u_phase_plane += maclev_adap_c.plot_vector_field( ('u_0',0,1), ('u_1',0,1), color='gray', plot_points=19 )
u_phase_plane.axes_labels( [ '$u_0$', '$u_1$' ] )
u_phase_plane.save( 'maclev-2-2-u-vs-u.png', xmin=0, xmax=1, ymin=0, ymax=1 )

# plot c_0 vs c_1
c_phase_plane = c_evolution.plot( SR('c_0(u_0)'), SR('c_1(u_0)'), figsize=(4,4) )
c_phase_plane += c_evolution.plot( SR('c_0(u_1)'), SR('c_1(u_1)'), color='red' )
c_phase_plane.axes_labels( [ '$c_0$', '$c_1$' ] )
c_phase_plane.save( 'maclev-2-2-c-vs-c.png' )

## now the A and K part

def get_coeff( expr, vars, power ):
    for c, p in expr.coefficients( vars ):
        if p == power:
            return c

from sage.symbolic.function_factory import function
af = function('a')
kf = function('k')

# this might work only for MacLevModels
def LotkaVolterraModel( model ):
    ij_model = deepcopy(model)
    ij_model.set_population_indices( [ 'i', 'j' ] )
    lvi = ij_model._flow[SR('X_i')].expand()
    A_bindings = FunctionBindings(
      { af: get_coeff( get_coeff( lvi, SR('X_i'), 1), SR('X_j'), 1).function(SR('u_i'), SR('u_j')),
        kf: get_coeff( get_coeff( lvi, SR('X_i'), 1), SR('X_j'), 0).function(SR('u_i')) } )
    return GeneralizedLotkaVolterraModel( model._population_indices,
      r = indexer(lambda i: kf(SR('u_%s'%i))),
      a = indexer(lambda i: indexer(lambda j: af(SR('u_%s'%i),SR('u_%s'%j)))) ).bind( A_bindings )

maclev_lv = LotkaVolterraModel( maclev_u )

ltx.write( "The L-V coefficients are" )
ltx.write_equality( kf(SR('i')), maclev_lv._bindings( maclev_lv._indexers['r']['i'] ) )
ltx.write_equality( af(SR('i'),SR('j')), maclev_lv._bindings( maclev_lv._indexers['a']['i']['j'] ).maxima_methods().collectterms( [ SR('u_i'), SR('u_j') ] ) )

ltx.write( "MacLev 2-2 model as Lotka-Volterra model:\n" )
ltx.write_block( maclev_lv )

# plot k values vs. time
k_timeseries = Graphics();
for i in (0, 1):
    k_timeseries += c_evolution.plot( t,
	( c_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['r'][i] ),
	color=[ 'blue', 'red' ][i], ylabel='$k(u)$', figsize=(4,4) )
k_timeseries.save( 'maclev-2-2-k-vs-t.png' )

print ( '$a_{00}$: ' + latex( (c_bindings + numeric_params + maclev_lv._bindings)( maclev_lv._indexers['a'][0][0] ) ) + '\n' )

# plot interactions in A space
a_phase_plane = Graphics()
from sage.plot.plot3d.base import Graphics3d
a_3d = Graphics3d()
for i in (0, 1):
    a_phase_plane += c_evolution.plot(
	( c_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][0] ),
	( c_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][1] ),
	color=[ 'blue', 'red' ][i] )
    a_3d += c_evolution.plot3d(
	( c_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][0] ),
	( c_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['a'][i][1] ),
	( c_bindings + numeric_params + maclev_lv._bindings )( maclev_lv._indexers['r'][i] ),
	color=[ 'blue', 'red' ][i] )
a_phase_plane.axes_labels( [ '$a(u_0,u)$', '$a(u_1,u)$' ] )
a_phase_plane.save( 'maclev-2-2-a-vs-a.png', figsize=(4,4) )
#a_3d.axes_labels( [ '$a(u_0,u)$', '$a(u_1,u)$', '$k(u)' ] )
a_3d.save( 'maclev-2-2-a-vs-k.png' )

#stop there for now
ltx.close()
save_session('maclev-2-2-adap')
sys.exit()

# and let's also plot k_0 vs. a_00.
# these are the coefficients if you rewrite the maclev dynamics
# as dX_0/dt = X_0(k_0 + a_00 X_0)
# and why not get sage to do that, rather than type in the definitions
rhsc = maclev_c._flow[X_0].collect(X_0)
k_0 = rhsc.coeff(X_0,1)
a_00 = rhsc.coeff(X_0,2)
ltx.write( 'With and without these bindings, the Lotka-Volterra coefficients $k_0$ and $a_{00}$ are:' )
ltx.write_equality( SR.var('k_0'), k_0, numeric_params(k_0) )
ltx.write_equality( SR.var('a_00', latex_name='a_{00}' ), a_00, numeric_params(a_00) )

ltx.write( 'And the equilibrium values $\\hat X$ and $\\hat R$:',
    '\\begin{align*}\n  \\hat X_0 &\\to ',
    latex( maclev_adap_c._bindings( Xhat ) ), ' = ',
    latex( numeric_params( maclev_adap_c._bindings( Xhat ) ) ), '\\\\\n',
    '  \\hat R_0 &\\to ',
    latex( maclev_adap_c._bindings( Rhat ) ), ' = ',
    latex( numeric_params( maclev_adap_c._bindings( Rhat ) ) ), '\n',
    '\\end{align*}\n' )

c_evolution.plot( a_00, k_0, "ak.png",
  xlabel = SR.var('a_00'), ylabel = SR.var('k_0'), figsize=(4,4) )

ltx.close()

save_session('maclev-2-2-adap')
</source-file>

Here we derive the adaptive dynamics equations when it is the uptake rates $$c_{ij}$$ that is evolving -- that is, when $$c_{ij}=c_j(u_i)$$, $$b_0=1$$, and $$m_0=1$$; and then we bind the remaining parameters to get a realization of the system that we can integrate and plot.

<project-file filename=maclev-2-2-adap.sage.out.tex/>

With these parameters, what happens to the evolving traits $$u$$?

<project-file filename=maclev-2-2-u-vs-t.png make=no/> <project-file filename=maclev-2-2-u-vs-u.png make=no/>

And behold the motion of $$c_0(u)$$ and $$c_1(u)$$ as the two populations' trait values $$u_i$$ change:

<project-file filename=maclev-2-2-c-vs-c.png make=no/>

And the motion of the Lotka-Volterra coefficients $$k$$ and $$a$$:

<project-file filename=maclev-2-2-k-vs-t.png make=no/> <project-file filename=maclev-2-2-a-vs-a.png make=no/>

<project-file filename=maclev-2-2-a-vs-k.png/>
