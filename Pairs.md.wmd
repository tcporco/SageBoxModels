---
layout: page
title: Pair Models
wmd_project: Box_Models
wmd_enable_make: false
---

When we cross a disease model with itself, we get a model of ordered pairs of
people. We want to check it carefully to get it just right, and investigate
how to transform it to a smaller model of *unordered* pairs.

## The unreduced product

<source-file filename="ordered-pair.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py boxmodelproduct.py
# requires: $(SageUtils)/latex_output.py
# produces: ordered-pair.boxes.tex ordered-pair.boxes.tex-inline
# produces: ordered-pair-ode.tex
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output
import boxmodel, boxmodelproduct
import dynamicalsystems

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SI = boxmodel.BoxModel(
    DiGraph( { S:{ I:alpha*S*I } } ),
    [S,I]
)

op = boxmodelproduct.power( SI, 2 )

try:
    op.plot_boxes( 'ordered-pair.boxes.tex', figsize=(5,5) )
    op.plot_boxes( 'ordered-pair.boxes.tex-inline', figsize=(5,5), inline=True )
except NotImplementedError:
    P = op.plot()
    P.save( 'ordered-pair.boxes.crop.svg', figsize=(5,5) )

op.ode().write_latex( 'ordered-pair-ode.tex' )

#sys.exit(0r)
</source-file>

Here is an SI ordered pair model.

<project-file filename="ordered-pair.boxes.crop.svg"/>

And the pair model's equations.

<project-file filename='ordered-pair-ode.tex'/>

Next to do:

* suitable internal representation of these stratified quantities, to allow
the reduction
* do the reduction

## Reducing to unordered pairs

Here we construct a reduced model, by combining pairs of states. We use
$$X_{{\cdot}{\cdot}}$$ for states of the unreduced model (above), and
$$Z_{\cdot\cdot}$$ for the reduced ones:

{$\begin{align*}
  Z_{SS} &= X_{SS} \\
  Z_{SI} &= X_{SI} + X_{IS} \\
  Z_{II} &= X_{II}
\end{align*}$}

<source-file filename="unordered-pair.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py boxmodelproduct.py
# requires: $(SageUtils)/latex_output.py
# produces: unordered-pair-ode.tex
# produces: unordered-pair.boxes.tex unordered-pair.boxes.tex-inline
# produces: vc-eqns.tex
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output
import boxmodel, boxmodelproduct
import dynamicalsystems

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SI = boxmodel.BoxModel(
    DiGraph( { S:{ I:alpha*S*I } } ),
    [S,I],
    parameter_dependencies={alpha:[]} #{alpha:[(S, boxmodel.deps.index), (I, boxmodel.deps.sumover)]}
)
#SIR = boxmodel.BoxModel(
#    DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ),
#    [S,I,R],
#    parameter_dependencies={alpha:[(S, boxmodel.deps.index), (I, boxmodel.deps.sumover)]}
#)

# the state combiner I'll use
# sort the states in S,I,R order
SIR_order = { v:i for i,v in enumerate( [S,I,R] ) }
def sort_combiner( *vs ):
    return tuple( sorted( vs, key=lambda v: SIR_order[v] ) )

# for the combined variables, 'Z'
def z_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'Z', *ss )

up = boxmodelproduct.BoxModelProduct( SI, SI,
    state_combiner=sort_combiner,
    vertex_namer=z_namer
)

# just to see if this works, temporarily
upa = up.bind( { dynamicalsystems.subscriptedsymbol( 'alpha', x, y ):alpha
	for x in (S,I,R) for y in (S,I,R) } )

upa.ode().write_latex( 'unordered-pair-ode.tex' )

upa.plot_boxes( 'unordered-pair.boxes.tex', figsize=(5,5) )
upa.plot_boxes( 'unordered-pair.boxes.tex-inline', figsize=(5,5), inline=True )

#ltx = latex_output.latex_output( 'vc-eqns.tex' )
#for vv in up._vc_eqns:
#    ltx.write_block( vv )
#ltx.close()

sys.exit(0r)
</source-file>

Making this substitution, we are able to combine the transition rates
into expressions free of $X$ variables:

<project-file filename="unordered-pair-ode.tex"/>

<project-file filename="unordered-pair.boxes.crop.svg"/>

<source-file filename=tex-newpage.tex display=none texdisplay=tex-newpage.tex>
\newpage
</source-file>

## Triples are problematic

Unfortunately, this doesn't work for unordered triples:

<source-file filename="unordered-triple.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py boxmodelproduct.py
# requires: $(SageUtils)/latex_output.py
# produces: ordered-triple.boxes.tex ordered-triple.boxes.tex-inline
# produces: unordered-triple-ode.tex
# produces: unordered-triple.boxes.tex unordered-triple.boxes.tex-inline
# produces: triple-vc-eqns.tex
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output
import boxmodel, boxmodelproduct
import dynamicalsystems

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SI = boxmodel.BoxModel(
    DiGraph( { S:{ I:alpha*S*I } } ),
    [S,I],
    parameter_dependencies={alpha:[]} #{alpha:[(S, boxmodel.deps.index), (I, boxmodel.deps.sumover)]}
)
#SIR = boxmodel.BoxModel(
#    DiGraph( { S:{ I:alpha*S*I }, I:{ R:mu*I } } ),
#    [S,I,R],
#    parameter_dependencies={alpha:[(S, boxmodel.deps.index), (I, boxmodel.deps.sumover)]}
#)

# for the combined variables, 'Z'
def x_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'X', *ss )

op = boxmodelproduct.BoxModelProduct( SI, SI, SI,
    vertex_namer=x_namer
)

op.plot_boxes( 'ordered-triple.boxes.tex', figsize=(5,5) )
op.plot_boxes( 'ordered-triple.boxes.tex-inline', figsize=(5,5), inline=True )

# sort the states in S,I,R order
SIR_order = { v:i for i,v in enumerate( [S,I,R] ) }
def sort_combiner( *vs ):
    return tuple( sorted( vs, key=lambda v: SIR_order[v] ) )

# for the combined variables, 'Z'
def z_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'Z', *ss )

up = boxmodelproduct.BoxModelProduct( SI, SI, SI,
    state_combiner=sort_combiner,
    vertex_namer=z_namer
)

# just to see if this works, temporarily
upa = up.bind( { dynamicalsystems.subscriptedsymbol( 'alpha', x, y ):alpha
	for x in (S,I,R) for y in (S,I,R) } )

upa.ode().write_latex( 'unordered-triple-ode.tex' )

upa.plot_boxes( 'unordered-triple.boxes.tex', figsize=(5,5) )
upa.plot_boxes( 'unordered-triple.boxes.tex-inline', figsize=(5,5), inline=True )

sys.exit(0r)
</source-file>

<project-file filename="ordered-triple.boxes.crop.svg"/>

<project-file filename="unordered-triple.boxes.crop.svg"/>

<!-- <project-file filename="unordered-triple-ode.tex"/> -->

In order to get the middle arrow to reduce to a function of
$$Z_{SSI}Z_{SII}$$, it would need to have nine
$$X_{\cdot\cdot\cdot}X_{\cdot\cdot\cdot}$$
terms, where it only has six.

## SIR model doesn't square properly

<source-file filename="SIR2.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py boxmodelproduct.py
# requires: $(SageUtils)/latex_output.py
# produces: SIR-ordered-pair.boxes.tex SIR-ordered-pair.boxes.tex-inline
# produces: SIR-ordered-pair-ode.tex
# produces: SIR-unordered-pair-ode.tex
# produces: SIR-unordered-pair.boxes.tex SIR-unordered-pair.boxes.tex-inline
# produces: SIR-vc-eqns.tex
import os, sys
sys.path.append( os.environ['SageUtils'] )
import latex_output
import boxmodel, boxmodelproduct
import dynamicalsystems

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )

SIR = boxmodel.BoxModel(
    DiGraph( { S:{ I:alpha*S*I}, I:{ R:mu*I } } ),
    [S,I,R],
    parameter_dependencies={ alpha:[], mu:[] }
)

def primevar( var ):
    return SR.symbol( str(var)+'prime', latex_name = "{%s}^{\'}" % latex(var) )

primer = dynamicalsystems.Bindings( {
    x:primevar(x) for x in (S,I,R,mu,alpha)
} )

# alternative naming: instead of S_I, X_{SI}
def x_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'X', *ss )

op = boxmodelproduct.BoxModelProduct( SIR, SIR,
    vertex_namer=x_namer
)

op.plot_boxes( 'SIR-ordered-pair.boxes.tex', figsize=(5,5) )
op.plot_boxes( 'SIR-ordered-pair.boxes.tex-inline', figsize=(5,5), inline=True )

op.ode().write_latex( 'SIR-ordered-pair-ode.tex' )

# for the combined variables, 'Z'
def z_namer( *ss ):
    return dynamicalsystems.subscriptedsymbol( 'Z', *ss )

# sort the states in S,I,R order
SIR_order = { v:i for i,v in enumerate( [S,I,R] ) }
def sort_combiner( *vs ):
    return tuple( sorted( vs, key=lambda v: SIR_order[v] ) )

up = boxmodelproduct.BoxModelProduct( SIR, SIR,
    state_combiner=sort_combiner,
    vertex_namer=z_namer
)

# just to see if this works, temporarily
#upa = up.bind( { dynamicalsystems.subscriptedsymbol( 'alpha', x, y ):alpha
#	for x in (S,I,R) for y in (S,I,R) } )

up.ode().write_latex( 'SIR-unordered-pair-ode.tex' )

up.plot_boxes( 'SIR-unordered-pair.boxes.tex', figsize=(5,5) )
up.plot_boxes( 'SIR-unordered-pair.boxes.tex-inline', figsize=(5,5), inline=True )

ltx = latex_output.latex_output( 'SIR-vc-eqns.tex' )
for vv in up._vc_eqns:
    ltx.write_block( vv )
ltx.close()

sys.exit(0r)
</source-file>

The straightforward square of an SIR model looks like this:

<project-file filename="SIR-ordered-pair.boxes.crop.svg"/>

<project-file filename='SIR-ordered-pair-ode.tex'/>

And when we reduce to undordered pairs, it all works except for the
$$Z_{SR}\to Z_{IR}$$ transition.

<project-file filename="SIR-unordered-pair.boxes.crop.svg"/>

<project-file filename="SIR-unordered-pair-ode.tex"/>

In order for that transition to be a function of $$Z$$ variables, it
would have to be $$Z_{SR}Z_{IR} = (X_{SR}+X_{RS})(X_{IR}+X_{RI})$$, but
we are missing two of those $$X$$ products.  Our simple cross doesn't allow the
$$S$$ in an $$(S,R)$$ pair to be infected by the $$I$$ in an $$(R,I)$$,
pair, and the other way around.

## What about the Rushton-Mautner expansion?

Do we want to say that $X_{SS}$ transitions to $X_{IS}$ due to contact
with $X_{IS}$ but not with $X_{II}$? That is, do we want the rate to be
$\alpha X_{SS} X_{IS}$, or should it be
$X_{SS} \left(\alpha_{11} X_{IS} + \alpha_{12} X_{II}\right)$?

What is the precise interpretation of these pairs?  Is $X_{IS}$ the
density of cohabiting couples with infected first partner (male, or
arbitrarily-designated
"head of household", or whatever) and uninfected second partner?  If so,
are males only infected by the males of other households?  Because otherwise
the transition from $X_{SS}$ to $X_{IS}$ needs to also include contact with
$X_{SI}$.  This deserves careful thought.


## A simple, biological model for infection among couples

I think we're concerned with models here of couples infecting each other,
rather than say an HIV model where infection happens within couples.

For simplicity let's model an idealized world where everybody is gendered
male/female and nobody is unpaired.  Then e.g. $$X_{IR}$$ is the number
of couples in which the male is infected and the female is recovered.

Couples are well mixed by having dinner parties or whatever, so any $$I$$
can infect any $$S$$.

Then our transitions should be

<source-file filename="couples.sage.step" texdisplay=none>
# requires: $(SageDynamics)/dynamicalsystems.py boxmodel.py boxmodelproduct.py
# requires: $(SageUtils)/latex_output.py
# produces: couples-X-ode.tex Ieqn-X.tex
# produces: couples-X.boxes.tex couples-X.boxes.tex-inline
# produces: couples-Z-ode.tex Ieqn-Z.tex
# produces: couples-Z.boxes.tex couples-Z.boxes.tex-inline
import os, sys
sys.path.append( os.environ['SageUtils'] )
import boxmodel, boxmodelproduct
import dynamicalsystems
import latex_output

S, I, R, mu, alpha = SR.var( 'S I R mu alpha' )
II = SR.var( 'II', latex_name='\mathcal{I}' )

X = dynamicalsystems.indexer_2d('X')
Ieqn = ( II == X[S][I] + X[R][I] + X[I][S] + 2*X[I][I] + X[I][R] )

couples = boxmodel.BoxModel(
    DiGraph( {
	X[S][S]: {
	    X[S][I]: alpha*X[S][S]*II,
	    X[I][S]: alpha*X[S][S]*II
	},
	X[S][I]: {
	    X[I][I]: alpha*X[S][I]*II,
	    X[S][R]: mu*X[S][I]
	},
	X[S][R]: {
	    X[I][R]: alpha*X[S][R]*II
	},
	X[I][S]: {
	    X[I][I]: alpha*X[I][S]*II,
	    X[R][S]: mu*X[I][S]
	},
	X[I][I]: {
	    X[R][I]: mu*X[I][I],
	    X[I][R]: mu*X[I][I]
	},
	X[I][R]: {
	    X[R][R]: mu*X[I][R]
	},
	X[R][S]: {
	    X[R][I]: alpha*X[R][S]*II,
	},
	X[R][I]: {
	    X[R][R]: mu*X[R][I]
	}
    }, pos = { X[(S,I,R)[i]][(S,I,R)[j]]: (j,-i) for i in (0,1,2) for j in (0,1,2) }
    ),
    [ X[x][y] for x in (S,I,R) for y in (S,I,R) ],
    parameter_dependencies={ alpha:[], mu:[] }
)

couples.plot_boxes( 'couples-X.boxes.tex', figsize=(5,5) )
couples.plot_boxes( 'couples-X.boxes.tex-inline', figsize=(5,5), inline=True )

couples.ode().write_latex( 'couples-X-ode.tex' )

ltx = latex_output.latex_output( 'Ieqn-X.tex' )
ltx.write_inline( Ieqn )
ltx.close()

Z = dynamicalsystems.indexer_2d('Z')
Ieqn = ( II == Z[S][I] + 2*Z[I][I] + Z[I][R] )

couples = boxmodel.BoxModel(
    DiGraph( {
	Z[S][S]: {
	    Z[S][I]: 2*alpha*Z[S][S]*II
	},
	Z[S][I]: {
	    Z[I][I]: alpha*Z[S][I]*II,
	    Z[S][R]: mu*Z[S][I]
	},
	Z[S][R]: {
	    Z[I][R]: alpha*Z[S][R]*II
	},
	Z[I][I]: {
	    Z[I][R]: 2*mu*Z[I][I]
	},
	Z[I][R]: {
	    Z[R][R]: mu*Z[I][R]
	}
    }, pos = {
	Z[(S,I,R)[i]][(S,I,R)[j]]: (j,-i)
	for i,j in ((0,0),(0,1),(0,2),(1,1),(1,2),(2,2))
    } ),
    [ Z[x][y] for x,y in ((S,S),(S,I),(S,R),(I,I),(I,R),(R,R)) ],
    parameter_dependencies={ alpha:[], mu:[] }
)

couples.plot_boxes( 'couples-Z.boxes.tex', figsize=(5,5) )
couples.plot_boxes( 'couples-Z.boxes.tex-inline', figsize=(5,5), inline=True )

couples.ode().write_latex( 'couples-Z-ode.tex' )

ltx = latex_output.latex_output( 'Ieqn-Z.tex' )
ltx.write_inline( Ieqn )
ltx.close()

exit(0r)
</source-file>

<project-file filename=couples-X.boxes.crop.svg/>

where <project-file filename=Ieqn-X.tex/>:

<project-file filename=couples-X-ode.tex/>

This reduces to $$Z$$ variables cleanly, with <project-file filename=Ieqn-Z.tex/>:

<project-file filename=couples-Z.boxes.crop.svg/>

And the reduced model's classes are e.g. couples in which one is infected
and one is recovered, regardless of order.

If we think this is the appropriate way to square this model, then we
need to work out how to get the code to use this $$\mathcal I$$...

## Notes on reduction of products

Notes to myself on implementing these reduced products in code:

* Simplest case may be to call BoxModelProduct more or less as it is,
but with some kind of combine() function that transforms the ordered tuples
of the raw Cartesian product of compartments into the destination compartments,
optionally in a many-to-one way.  This is what I've done here, and I'm
using it to produce the above diagrams and equations.

* As we see above, we need to be very careful to combine the rates properly. 
A transition
rate between reduced compartments is a sum of the transition rates between
unreduced compartments, which conveniently simplifies into terms of the
reduced variables. 

    * The current Sage implementation (here) does this literally and
explicitly, by constructing the sum of $X$ rates and then using
Maxima to simplify it into the $Z$
variables.  Of course, this isn't practical for higher powers.  I'm just
doing it now to make sure the reduction is correct.

    * We run into trouble if the rates don't combine just so, because
we need to come out with rates that depend on the combined variables
rather than combinations of the raw compartment variables.

* Mostly we care about powers -- should we just implement powers and not
even accept reduced products of heterogeneous box models?

* We want to do higher powers of models efficiently, for example $$(\mathit{SIR})^{100}$$.
This means don't construct the Cartesian product before reducing it: we have
to construct the reduced product directly. I think this means don't even
construct the 100 models before reducing their product. If it's 100 
references to a single model, this should be okay (python does that shallowly),
but it needs to be done carefully.

I think we should start with simple reduce, then assess how to do it on
large powers, with or without doing it efficiently.  This is what I'm
doing here.

## Links

* Kretzschmar et al., 1994. [The basic reproduction ratio $R_0$ for a sexually transmitted disease in pair formation model with two types of pairs](http://www.sciencedirect.com/science/article/pii/0025556494900426). *Mathematical BioSciences* 124:2, 181-205.

* Ong et al., 2012. [Comparability of Results from Pair and Classical Model Formulations for Different Sexually Transmitted Infections](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3384672/). *PLoS One*, 7(6): e39575. [http://dx.doi.org/10.1371%2Fjournal.pone.0039575](http://dx.doi.org/10.1371%2Fjournal.pone.0039575).

